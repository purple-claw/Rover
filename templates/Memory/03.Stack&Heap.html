<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rover | Stack vs Heap Memory</title>
    
    <style>
        /* ==================== FONT IMPORT ==================== */
        @import url('https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400;500;600;700&display=swap');

        /* ==================== GLASSMORPHISM THEME ==================== */
        :root {
            /* Pure Black Base */
            --bg-primary: #000000;
            --bg-secondary: #0a0a0a;
            
            /* Glass Effect Colors */
            --glass-white: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-highlight: rgba(255, 255, 255, 0.15);
            
            /* McLaren Orange */
            --mclaren-orange: #FF8000;
            --mclaren-glow: rgba(255, 128, 0, 0.3);
            --mclaren-light: #FFA040;
            --mclaren-dark: #CC6600;
            
            /* RedBull Red */
            --redbull-red: #DC0000;
            --redbull-blue: #1E41FF;
            --redbull-glow: rgba(220, 0, 0, 0.3);
            --redbull-light: #FF3333;
            
            /* Meta Blue */
            --meta-blue: #0081FB;
            --meta-glow: rgba(0, 129, 251, 0.3);
            --meta-light: #33A3FF;
            --meta-dark: #0066CC;
            
            /* Text Colors - Ultra White */
            --text-primary: #FFFFFF;
            --text-secondary: #FFFFFF;
            --text-muted: rgba(255, 255, 255, 0.9);
            --text-dim: rgba(255, 255, 255, 0.7);
            
            /* Code Syntax */
            --code-bg: rgba(20, 20, 20, 0.6);
            --code-keyword: #FF8000;
            --code-function: #0081FB;
            --code-string: #3fb950;
            --code-comment: rgba(255, 255, 255, 0.4);
            --code-number: #DC0000;
            --code-variable: #FFA040;
            
            /* Layout */
            --container-width: 1100px;
            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 2.5rem;
            --spacing-2xl: 3rem;
            
            /* Border Radius */
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-xl: 24px;
            
            /* Animations */
            --transition-fast: 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-normal: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            overflow-x: hidden;
            width: 100%;
        }

        body {
            font-family: 'Quicksand', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #000000;
            color: #FFFFFF;
            line-height: 1.7;
            overflow-x: hidden;
            position: relative;
            font-size: 16px;
            font-weight: 400;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            width: 100%;
            max-width: 100vw;
        }

        h1, h2, h3, h4 {
            font-family: 'Quicksand', sans-serif;
            font-weight: 600;
            letter-spacing: -0.03em;
        }

        code, pre {
            font-family: 'Courier New', monospace;
            font-weight: 400;
        }

        /* Progress Bar */
        #reading-progress {
            position: fixed;
            top: 0;
            left: 0;
            width: 0%;
            height: 3px;
            background: linear-gradient(90deg, var(--mclaren-orange), var(--mclaren-light));
            box-shadow: 0 0 10px var(--mclaren-glow);
            z-index: 9999;
            transition: width 0.1s ease;
        }

        /* Container */
        .container {
            max-width: var(--container-width);
            margin: 0 auto;
            padding: 0 var(--spacing-lg);
            position: relative;
            z-index: 1;
        }

        /* Navigation */
        nav {
            position: sticky;
            top: 0;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(24px) saturate(180%);
            -webkit-backdrop-filter: blur(24px) saturate(180%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.12);
            padding: 0.75rem 0;
            box-shadow: 
                0 1px 3px rgba(0, 0, 0, 0.5),
                0 1px 20px rgba(255, 128, 0, 0.1),
                inset 0 -1px 0 rgba(255, 255, 255, 0.05);
        }

        nav::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, 
                transparent,
                rgba(255, 128, 0, 0.3) 20%,
                rgba(255, 128, 0, 0.5) 50%,
                rgba(255, 128, 0, 0.3) 80%,
                transparent
            );
            opacity: 0.8;
        }

        .nav-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 2rem;
            padding: 0 var(--spacing-lg);
            max-width: var(--container-width);
            margin: 0 auto;
        }

        .nav-logo {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--mclaren-orange);
            text-decoration: none;
            letter-spacing: 0.1em;
        }

        .nav-links {
            display: flex;
            gap: 2rem;
            list-style: none;
        }

        .nav-link {
            color: rgba(255, 255, 255, 0.8);
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            transition: all var(--transition-fast);
            position: relative;
            padding: 0.5rem 0;
        }

        .nav-link:hover {
            color: var(--mclaren-orange);
            text-shadow: 0 0 20px var(--mclaren-glow);
        }

        .nav-link.active::after {
            content: '';
            position: absolute;
            bottom: -3px;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--mclaren-orange);
            box-shadow: 0 0 10px var(--mclaren-glow);
        }

        /* Hero Section */
        .hero {
            padding: var(--spacing-2xl) 0;
            text-align: center;
            position: relative;
            margin-bottom: var(--spacing-xl);
            z-index: 1;
        }

        .hero h1 {
            font-size: 3.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: var(--mclaren-orange);
            background: linear-gradient(135deg, 
                var(--mclaren-orange) 0%, 
                var(--mclaren-light) 50%, 
                var(--mclaren-orange) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: glow 3s ease-in-out infinite;
        }

        @supports not (background-clip: text) {
            .hero h1 {
                color: var(--mclaren-orange) !important;
                -webkit-text-fill-color: var(--mclaren-orange) !important;
            }
        }

        @keyframes glow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }

        .hero p {
            font-size: 1.2rem;
            color: var(--text-muted);
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.8;
        }

        /* Sections */
        .section {
            margin-bottom: var(--spacing-2xl);
            opacity: 0;
            transform: translateY(30px);
            transition: all 0.8s ease;
        }

        .section.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .section-header {
            border-bottom: 1px solid var(--glass-border);
            padding-bottom: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
        }

        .section-title {
            font-size: 2.2rem;
            color: var(--text-primary);
            margin-bottom: 0.75rem;
            font-weight: 700;
        }

        .section-subtitle {
            color: var(--text-muted);
            font-size: 1.1rem;
        }

        /* Content Block */
        .content-block {
            background: var(--glass-white);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            padding: var(--spacing-lg);
            margin: var(--spacing-md) 0;
        }

        .content-block h3 {
            font-size: 1.7rem;
            margin-bottom: var(--spacing-md);
            color: var(--text-primary);
            font-weight: 600;
        }

        .content-block h4 {
            font-size: 1.35rem;
            margin: var(--spacing-md) 0 var(--spacing-sm) 0;
            color: var(--mclaren-light);
            font-weight: 600;
        }

        .content-block p {
            margin: var(--spacing-sm) 0;
            line-height: 1.8;
            font-size: 1.05rem;
        }

        .content-block ul, .content-block ol {
            margin-left: var(--spacing-lg);
            margin-top: var(--spacing-sm);
            margin-bottom: var(--spacing-sm);
        }

        .content-block li {
            margin: 0.5rem 0;
            line-height: 1.8;
        }

        /* Code Blocks */
        .code-block {
            background: linear-gradient(135deg, rgba(20, 20, 20, 0.8), rgba(10, 10, 10, 0.9));
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            padding: var(--spacing-md);
            margin: var(--spacing-md) 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            position: relative;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: all var(--transition-normal);
        }

        .code-block:hover {
            border-color: rgba(255, 128, 0, 0.3);
            box-shadow: 0 6px 20px rgba(255, 128, 0, 0.15);
        }

        .code-block pre {
            margin: 0;
            white-space: pre;
        }

        .code-block code {
            color: var(--text-primary);
        }

        /* Syntax Highlighting */
        .keyword {
            color: var(--code-keyword);
            font-weight: 600;
        }

        .function {
            color: var(--code-function);
        }

        .string {
            color: var(--code-string);
        }

        .comment {
            color: var(--code-comment);
            font-style: italic;
        }

        .number {
            color: var(--code-number);
        }

        .variable {
            color: var(--code-variable);
        }

        /* Interactive Demo */
        .interactive-demo {
            background: var(--glass-white);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            padding: var(--spacing-lg);
            margin: var(--spacing-md) 0;
        }

        .demo-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: var(--spacing-md);
            flex-wrap: wrap;
            align-items: center;
        }

        .control-button {
            background: linear-gradient(135deg, var(--mclaren-orange), var(--mclaren-light));
            color: white;
            border: none;
            padding: 0.5rem 1.25rem;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: 0.95rem;
            font-family: 'Quicksand', sans-serif;
            font-weight: 600;
            transition: all var(--transition-fast);
            box-shadow: 0 4px 12px var(--mclaren-glow);
        }

        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px var(--mclaren-glow);
        }

        .control-button:disabled {
            background: var(--glass-white);
            color: var(--text-dim);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .demo-output {
            background: var(--code-bg);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-sm);
            padding: var(--spacing-md);
            margin-top: var(--spacing-md);
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            max-height: 400px;
            overflow-y: auto;
        }

        input[type="number"], input[type="text"], select {
            padding: 0.5rem;
            background: var(--code-bg);
            border: 1px solid var(--glass-border);
            color: white;
            border-radius: var(--radius-sm);
            font-family: 'Quicksand', sans-serif;
        }

        /* Memory Visualization */
        .memory-visual {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: var(--spacing-md);
            background: var(--code-bg);
            border-radius: var(--radius-sm);
            margin: var(--spacing-md) 0;
        }

        .memory-row {
            display: flex;
            align-items: center;
            padding: 10px;
            background: var(--glass-white);
            border: 1px solid var(--glass-border);
            border-radius: 4px;
            transition: all var(--transition-fast);
            font-family: 'Courier New', monospace;
        }

        .memory-row:hover {
            background: rgba(255, 128, 0, 0.1);
            border-color: var(--mclaren-orange);
            transform: translateX(5px);
        }

        .memory-addr {
            width: 150px;
            color: var(--meta-blue);
            font-weight: bold;
        }

        .memory-content {
            flex: 1;
            color: var(--text-primary);
            margin-left: 20px;
        }

        .memory-type {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 600;
            margin-left: auto;
        }

        .stack-mem {
            background: var(--meta-blue);
            color: white;
        }

        .heap-mem {
            background: var(--mclaren-orange);
            color: white;
        }

        /* Feynman Deep Dive */
        .feynman-dive {
            background: linear-gradient(135deg, 
                rgba(255, 128, 0, 0.03), 
                rgba(255, 128, 0, 0.01));
            border: 1px solid rgba(255, 128, 0, 0.2);
            border-left: 4px solid var(--mclaren-orange);
            border-radius: var(--radius-md);
            padding: var(--spacing-lg);
            margin: var(--spacing-lg) 0;
            position: relative;
        }

        .feynman-dive h3 {
            color: var(--mclaren-orange);
            font-size: 1.8rem;
            margin-bottom: var(--spacing-md);
            font-weight: 700;
        }

        .feynman-dive h4 {
            color: var(--mclaren-light);
            font-size: 1.3rem;
            margin: var(--spacing-md) 0 var(--spacing-sm) 0;
            font-weight: 600;
        }

        /* Callout Boxes */
        .callout {
            border-left: 4px solid var(--mclaren-orange);
            background: rgba(255, 128, 0, 0.1);
            padding: var(--spacing-md);
            margin: var(--spacing-md) 0;
            border-radius: var(--radius-sm);
        }

        .callout-title {
            font-weight: 700;
            color: var(--mclaren-orange);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }

        .callout.warning {
            border-left-color: var(--redbull-red);
            background: rgba(220, 0, 0, 0.1);
        }

        .callout.warning .callout-title {
            color: var(--redbull-red);
        }

        .callout.success {
            border-left-color: #3fb950;
            background: rgba(63, 185, 80, 0.1);
        }

        .callout.success .callout-title {
            color: #3fb950;
        }

        /* Footer */
        footer {
            background: var(--glass-white);
            padding: var(--spacing-xl) 0;
            margin-top: var(--spacing-2xl);
            text-align: center;
            color: var(--text-muted);
            border-top: 1px solid var(--glass-border);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .hero h1 {
                font-size: 2.5rem;
            }
            
            .section-title {
                font-size: 1.8rem;
            }
            
            .nav-links {
                display: none;
            }
            
            .content-block {
                padding: var(--spacing-md);
            }
            
            .demo-controls {
                flex-direction: column;
                align-items: stretch;
            }
        }
    </style>
</head>
<body>
    <!-- Progress Bar -->
    <div id="reading-progress"></div>
    
    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="#" class="nav-logo">ROVER</a>
            <ul class="nav-links" id="navLinks">
                <li><a href="#intro" class="nav-link active">Introduction</a></li>
                <li><a href="#stack" class="nav-link">Stack Memory</a></li>
                <li><a href="#heap" class="nav-link">Heap Memory</a></li>
                <li><a href="#comparison" class="nav-link">Comparison</a></li>
                <li><a href="#best-practices" class="nav-link">Best Practices</a></li>
            </ul>
                    <button class="hamburger-menu" id="hamburgerMenu" aria-label="Toggle navigation menu">
                <span class="hamburger-line"></span>
                <span class="hamburger-line"></span>
                <span class="hamburger-line"></span>
            </button>
        </div>
    </nav>
    
    <!-- Hero Section -->
    <section class="hero">
        <div class="container">
            <h1>Stack vs Heap Memory</h1>
            <p>Deep dive into memory management, understand allocation strategies, and master the fundamental concepts that power modern computing.</p>
        </div>
    </section>

    <main class="container">
        <!-- Introduction Section -->
        <article id="intro" class="section">
            <div class="section-header">
                <h2 class="section-title">Memory Management Fundamentals</h2>
                <p class="section-subtitle">Understanding how programs use memory</p>
            </div>
            
            <!-- Feynman-Style Deep Dive -->
            <div class="feynman-dive">
                <h3>Feynman's Approach: Building Memory Understanding from First Principles</h3>
                <div class="feynman-content">
                    <p class="feynman-intro">
                        If you can't explain the difference between stack and heap to a beginner, you don't truly understand memory management. Let's build this knowledge from the ground up.
                    </p>
                    
                    <h4>The Physical Reality of Program Memory</h4>
                    <p>
                        When your program runs, the operating system gives it a chunk of virtual memory space. This space is divided into several segments, but the two most important for programmers are the stack and the heap.
                    </p>
                    
                    <div style="margin-top: 1rem; padding: 1rem; background: rgba(0, 129, 251, 0.05); border-left: 3px solid var(--meta-blue);">
                        <p><strong>Memory Layout (from high to low addresses):</strong></p>
                        <ul style="margin: 0.5rem 0 0 1.5rem; font-family: monospace;">
                            <li>0xFFFFFFFF - Kernel Space (OS)</li>
                            <li>0xC0000000 - Stack (grows downward ↓)</li>
                            <li>... (free space)</li>
                            <li>0x40000000 - Heap (grows upward ↑)</li>
                            <li>0x08048000 - Data Segment (globals)</li>
                            <li>0x00000000 - Text Segment (code)</li>
                        </ul>
                        <p style="margin-top: 0.5rem;"><strong>Key Insight:</strong> Stack and heap grow toward each other, maximizing memory utilization.</p>
                    </div>
                </div>
            </div>
            
            <div class="content-block">
                <h3>Why Two Different Memory Regions?</h3>
                <p>The stack and heap serve fundamentally different purposes in program execution:</p>
                
                <ul>
                    <li><strong>Stack:</strong> Manages function calls and local variables with automatic, fast allocation</li>
                    <li><strong>Heap:</strong> Provides flexible, dynamic memory for data of unknown or variable size</li>
                </ul>
                
                <div style="margin-top: 1rem; padding: 1rem; background: rgba(255, 128, 0, 0.05); border-left: 3px solid var(--mclaren-orange);">
                    <p><strong>Historical Context:</strong></p>
                    <p>The stack/heap model emerged from the need to balance two competing requirements:</p>
                    <ol style="margin: 0.5rem 0 0 1.5rem;">
                        <li>Fast, automatic memory management for function calls (stack)</li>
                        <li>Flexible, long-lived memory for complex data structures (heap)</li>
                    </ol>
                    <p style="margin-top: 0.5rem;">This dual-model has proven so effective that it's used by virtually every modern programming language and operating system.</p>
                </div>
            </div>
        </article>

        <!-- Stack Memory Section -->
        <article id="stack" class="section">
            <div class="section-header">
                <h2 class="section-title">Stack Memory: The Speed Demon</h2>
                <p class="section-subtitle">LIFO structure for automatic memory management</p>
            </div>
            
            <div class="content-block">
                <h3>How Stack Memory Works</h3>
                <p>The stack is a contiguous block of memory that operates on a Last-In-First-Out (LIFO) principle. It's managed entirely by the CPU with dedicated registers.</p>
                
                <div class="code-block">
                    <pre><code><span class="keyword">void</span> <span class="function">functionA</span>() {
    <span class="keyword">int</span> <span class="variable">x</span> = <span class="number">10</span>;        <span class="comment">// Pushed to stack</span>
    <span class="keyword">char</span> <span class="variable">arr</span>[<span class="number">100</span>];    <span class="comment">// 100 bytes pushed to stack</span>
    
    <span class="function">functionB</span>();       <span class="comment">// New stack frame created</span>
    
    <span class="comment">// When function returns:</span>
    <span class="comment">// 1. Stack pointer moves back</span>
    <span class="comment">// 2. Memory is "freed" instantly (O(1))</span>
    <span class="comment">// 3. No fragmentation possible</span>
}</code></pre>
                </div>
                
                <h4>Stack Characteristics</h4>
                <div style="margin-top: 1rem; padding: 1rem; background: rgba(0, 129, 251, 0.05); border-left: 3px solid var(--meta-blue);">
                    <p><strong>Technical Details:</strong></p>
                    <ul style="margin: 0.5rem 0 0 1.5rem;">
                        <li><strong>Speed:</strong> Allocation is just SUB RSP, size (single CPU instruction)</li>
                        <li><strong>Size Limit:</strong> Typically 1-8MB (ulimit -s to check on Linux)</li>
                        <li><strong>Memory Access:</strong> Excellent cache locality - sequential access pattern</li>
                        <li><strong>Thread Safety:</strong> Each thread gets its own stack - no synchronization needed</li>
                        <li><strong>Stack Overflow:</strong> Occurs when stack pointer exceeds limit (recursive functions)</li>
                    </ul>
                </div>
                
                <h4>Stack Frame Structure</h4>
                <div class="code-block">
                    <pre><code><span class="comment">/* Stack frame layout (x86-64) */</span>
<span class="comment">High Address</span>
+------------------+
| Return Address   |  <span class="comment">← Saved by CALL instruction</span>
+------------------+
| Saved RBP        |  <span class="comment">← Previous frame pointer</span>
+------------------+
| Local Variables  |  <span class="comment">← Current function's data</span>
| ...              |
+------------------+
| Saved Registers  |  <span class="comment">← Callee-saved registers</span>
+------------------+ <span class="comment">← RSP (Stack Pointer)</span>
<span class="comment">Low Address</span></code></pre>
                </div>
            </div>
            
            <!-- Deep Dive: Stack Operations at Assembly Level -->
            <div class="feynman-dive">
                <h3>Deep Dive: Stack Operations Under the Hood</h3>
                <div class="feynman-content">
                    <p class="feynman-intro">
                        To truly understand stack operations, we need to examine what happens at the assembly level when functions are called and variables are allocated.
                    </p>
                    
                    <h4>Function Prologue: Setting Up the Stack Frame</h4>
                    <p>
                        When a function is called, the CPU performs a carefully choreographed sequence of operations known as the function prologue. This sets up the new stack frame.
                    </p>
                    
                    <div class="code-block">
                        <pre><code><span class="comment">; Assembly code for function entry (x86-64)</span>
<span class="function">my_function</span>:
    <span class="keyword">push</span>   <span class="variable">rbp</span>              <span class="comment">; Save old base pointer (8 bytes)</span>
    <span class="keyword">mov</span>    <span class="variable">rbp</span>, <span class="variable">rsp</span>         <span class="comment">; Set new base pointer</span>
    <span class="keyword">sub</span>    <span class="variable">rsp</span>, <span class="number">0x30</span>        <span class="comment">; Allocate 48 bytes for locals</span>
    
    <span class="comment">; Save callee-saved registers if needed</span>
    <span class="keyword">push</span>   <span class="variable">rbx</span>
    <span class="keyword">push</span>   <span class="variable">r12</span>
    <span class="keyword">push</span>   <span class="variable">r13</span>
    
    <span class="comment">; Function body here...</span>
    <span class="keyword">mov</span>    <span class="variable">DWORD PTR</span> [<span class="variable">rbp</span>-<span class="number">0x4</span>], <span class="number">42</span>  <span class="comment">; Local int x = 42</span>
    <span class="keyword">lea</span>    <span class="variable">rax</span>, [<span class="variable">rbp</span>-<span class="number">0x20</span>]            <span class="comment">; Address of local array</span></code></pre>
                    </div>
                    
                    <div style="margin-top: 1rem; padding: 1rem; background: rgba(0, 129, 251, 0.05); border-left: 3px solid var(--meta-blue);">
                        <p><strong>CPU Cycle Analysis:</strong></p>
                        <ul style="margin: 0.5rem 0 0 1.5rem;">
                            <li><strong>PUSH instruction:</strong> 1-2 cycles (writes to L1 cache)</li>
                            <li><strong>MOV rbp, rsp:</strong> 0 cycles (register rename in modern CPUs)</li>
                            <li><strong>SUB rsp, size:</strong> 1 cycle (simple arithmetic)</li>
                            <li><strong>Total overhead:</strong> ~3-5 cycles for stack frame setup</li>
                        </ul>
                        <p style="margin-top: 0.5rem;">Compare this to heap allocation which can take 100-1000+ cycles!</p>
                    </div>
                    
                    <h4>Stack Allocation: Why It's So Fast</h4>
                    <p>
                        Stack allocation is just pointer arithmetic. The CPU maintains the stack pointer (RSP/ESP) in a dedicated register, and allocation is simply subtracting from it.
                    </p>
                    
                    <div class="code-block">
                        <pre><code><span class="comment">// C code</span>
<span class="keyword">void</span> <span class="function">example</span>() {
    <span class="keyword">int</span> <span class="variable">array</span>[<span class="number">100</span>];  <span class="comment">// Need 400 bytes</span>
}

<span class="comment">; Compiles to just:</span>
<span class="keyword">sub</span>    <span class="variable">rsp</span>, <span class="number">0x190</span>    <span class="comment">; Allocate 400 bytes in ONE instruction!</span></code></pre>
                    </div>
                    
                    <h4>Function Epilogue: Tearing Down the Stack Frame</h4>
                    <div class="code-block">
                        <pre><code><span class="comment">; Function exit sequence</span>
    <span class="comment">; Restore callee-saved registers</span>
    <span class="keyword">pop</span>    <span class="variable">r13</span>
    <span class="keyword">pop</span>    <span class="variable">r12</span>
    <span class="keyword">pop</span>    <span class="variable">rbx</span>
    
    <span class="keyword">mov</span>    <span class="variable">rsp</span>, <span class="variable">rbp</span>         <span class="comment">; Restore stack pointer</span>
    <span class="keyword">pop</span>    <span class="variable">rbp</span>              <span class="comment">; Restore old base pointer</span>
    <span class="keyword">ret</span>                     <span class="comment">; Return (pops return address)</span></code></pre>
                    </div>
                    
                    <div style="margin-top: 1rem; padding: 1rem; background: rgba(255, 128, 0, 0.05); border-left: 3px solid var(--mclaren-orange);">
                        <p><strong>The Beauty of Stack Deallocation:</strong></p>
                        <p>Notice that we don't actually "clear" the memory. We just move the stack pointer back. The old data remains in memory but is considered "freed" because it's below the stack pointer. This is why:</p>
                        <ul style="margin: 0.5rem 0 0 1.5rem;">
                            <li>Stack deallocation is O(1) - just change a pointer</li>
                            <li>Uninitialized stack variables contain garbage (old data)</li>
                            <li>Stack memory can be reused immediately</li>
                            <li>No fragmentation is possible</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <!-- Red Zone and Stack Optimizations -->
            <div class="content-block">
                <h3>Advanced Stack Concepts</h3>
                
                <h4>The Red Zone (System V ABI)</h4>
                <p>On x86-64 Linux/Unix systems, there's a 128-byte area below the stack pointer called the "red zone" that functions can use without adjusting RSP.</p>
                
                <div class="code-block">
                    <pre><code><span class="comment">; Leaf function optimization using red zone</span>
<span class="function">leaf_function</span>:
    <span class="comment">; No need to adjust RSP for small locals!</span>
    <span class="keyword">mov</span>    <span class="variable">QWORD PTR</span> [<span class="variable">rsp</span>-<span class="number">8</span>], <span class="variable">rdi</span>   <span class="comment">; Use red zone</span>
    <span class="keyword">mov</span>    <span class="variable">QWORD PTR</span> [<span class="variable">rsp</span>-<span class="number">16</span>], <span class="variable">rsi</span>  <span class="comment">; Still in red zone</span>
    
    <span class="comment">; Do work...</span>
    
    <span class="keyword">ret</span>    <span class="comment">; No cleanup needed!</span></code></pre>
                </div>
                
                <h4>Stack Alignment Requirements</h4>
                <p>Modern CPUs require stack alignment for optimal performance. The x86-64 ABI mandates 16-byte alignment before function calls.</p>
                
                <div class="callout warning">
                    <div class="callout-title">Alignment Pitfall</div>
                    <p>Misaligned stack can cause crashes with SIMD instructions (SSE/AVX) or significant performance degradation. Always maintain proper alignment!</p>
                    <div class="code-block" style="margin-top: 0.5rem;">
                        <pre><code><span class="comment">; Ensure 16-byte alignment before call</span>
<span class="keyword">and</span>    <span class="variable">rsp</span>, <span class="number">-16</span>       <span class="comment">; Align to 16-byte boundary</span>
<span class="keyword">call</span>   <span class="function">some_function</span></code></pre>
                    </div>
                </div>
                
                <h4>Stack Canaries: Security Protection</h4>
                <p>Modern compilers insert "canary" values to detect stack buffer overflows:</p>
                
                <div class="code-block">
                    <pre><code><span class="comment">; GCC -fstack-protector generates:</span>
<span class="function">protected_function</span>:
    <span class="keyword">push</span>   <span class="variable">rbp</span>
    <span class="keyword">mov</span>    <span class="variable">rbp</span>, <span class="variable">rsp</span>
    <span class="keyword">sub</span>    <span class="variable">rsp</span>, <span class="number">0x110</span>
    
    <span class="comment">; Load canary value</span>
    <span class="keyword">mov</span>    <span class="variable">rax</span>, <span class="variable">QWORD PTR fs</span>:<span class="number">0x28</span>
    <span class="keyword">mov</span>    <span class="variable">QWORD PTR</span> [<span class="variable">rbp</span>-<span class="number">8</span>], <span class="variable">rax</span>
    
    <span class="comment">; Function body...</span>
    
    <span class="comment">; Check canary before return</span>
    <span class="keyword">mov</span>    <span class="variable">rdx</span>, <span class="variable">QWORD PTR</span> [<span class="variable">rbp</span>-<span class="number">8</span>]
    <span class="keyword">xor</span>    <span class="variable">rdx</span>, <span class="variable">QWORD PTR fs</span>:<span class="number">0x28</span>
    <span class="keyword">je</span>     <span class="variable">.safe_return</span>
    <span class="keyword">call</span>   <span class="function">__stack_chk_fail</span>  <span class="comment">; Abort if canary corrupted</span></code></pre>
                </div>
            </div>

            <!-- Stack Visualizer Demo -->
            <div class="interactive-demo">
                <h3>Interactive Stack Frame Visualizer</h3>
                <p>Watch how function calls create and destroy stack frames in real-time.</p>
                
                <div class="demo-controls">
                    <button class="control-button" onclick="stackDemo.callFunction()">Call Function</button>
                    <button class="control-button" onclick="stackDemo.returnFunction()">Return</button>
                    <button class="control-button" onclick="stackDemo.allocateLocal()">Allocate Local</button>
                    <button class="control-button" onclick="stackDemo.reset()">Reset</button>
                </div>
                
                <div class="memory-visual" id="stack-visual">
                    <!-- Stack frames will be visualized here -->
                </div>
                
                <div id="stack-trace" class="demo-output">
                    <div style="font-weight: 600; color: var(--meta-blue);">STACK TRACE:</div>
                    <!-- Stack operations will be logged here -->
                </div>
            </div>
            
            <!-- Assembly-Level Stack Operations Demo -->
            <div class="interactive-demo">
                <h3>Assembly-Level Stack Operations Visualizer</h3>
                <p>Watch actual assembly instructions manipulate the stack in real-time. See how PUSH, POP, CALL, and RET work at the CPU level.</p>
                
                <div class="demo-controls">
                    <select id="asm-instruction" style="padding: 0.5rem; margin-right: 1rem;">
                        <option value="push-reg">PUSH register</option>
                        <option value="push-imm">PUSH immediate</option>
                        <option value="pop">POP register</option>
                        <option value="call">CALL function</option>
                        <option value="ret">RET</option>
                        <option value="sub-rsp">SUB RSP (allocate)</option>
                        <option value="add-rsp">ADD RSP (deallocate)</option>
                    </select>
                    <button class="control-button" onclick="asmStackDemo.execute()">Execute</button>
                    <button class="control-button" onclick="asmStackDemo.step()">Single Step</button>
                    <button class="control-button" onclick="asmStackDemo.reset()">Reset</button>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-top: 1rem;">
                    <!-- Registers View -->
                    <div>
                        <h4 style="color: var(--meta-blue); margin-bottom: 1rem;">CPU Registers</h4>
                        <div style="background: var(--code-bg); border: 1px solid var(--glass-border); border-radius: var(--radius-sm); padding: 1rem; font-family: monospace;">
                            <div id="register-rsp" style="margin: 0.5rem 0;">RSP: <span style="color: var(--mclaren-orange);">0x7FFFFFFFE000</span></div>
                            <div id="register-rbp" style="margin: 0.5rem 0;">RBP: <span style="color: var(--mclaren-orange);">0x7FFFFFFFE020</span></div>
                            <div id="register-rax" style="margin: 0.5rem 0;">RAX: <span style="color: var(--meta-blue);">0x0000000000000000</span></div>
                            <div id="register-rbx" style="margin: 0.5rem 0;">RBX: <span style="color: var(--meta-blue);">0x0000000000000000</span></div>
                            <div id="register-rip" style="margin: 0.5rem 0;">RIP: <span style="color: #3fb950;">0x0000000000401000</span></div>
                        </div>
                    </div>
                    
                    <!-- Stack Memory View -->
                    <div>
                        <h4 style="color: var(--mclaren-orange); margin-bottom: 1rem;">Stack Memory</h4>
                        <div id="asm-stack-memory" style="background: var(--code-bg); border: 1px solid var(--glass-border); border-radius: var(--radius-sm); padding: 1rem; font-family: monospace; height: 300px; overflow-y: auto;">
                            <!-- Stack memory will be visualized here -->
                        </div>
                    </div>
                </div>
                
                <!-- Assembly Code Display -->
                <div style="margin-top: 1rem;">
                    <h4 style="color: #3fb950; margin-bottom: 0.5rem;">Assembly Code</h4>
                    <div id="asm-code-display" class="code-block" style="font-size: 0.9rem;">
                        <pre><code id="asm-code-content"><span class="comment">; Ready to execute instructions...</span></code></pre>
                    </div>
                </div>
                
                <div id="asm-trace" class="demo-output">
                    <div style="font-weight: 600; color: var(--meta-blue);">INSTRUCTION TRACE:</div>
                    <!-- Assembly operations will be logged here -->
                </div>
            </div>
        </article>

        <!-- Heap Memory Section -->
        <article id="heap" class="section">
            <div class="section-header">
                <h2 class="section-title">Heap Memory: The Flexible Giant</h2>
                <p class="section-subtitle">Dynamic allocation for complex data structures</p>
            </div>
            
            <div class="content-block">
                <h3>How Heap Memory Works</h3>
                <p>The heap is a pool of memory used for dynamic allocation. Unlike the stack, heap allocation is managed by complex algorithms and requires explicit deallocation.</p>
                
                <div class="code-block">
                    <pre><code><span class="comment">// C example</span>
<span class="keyword">int</span>* <span class="variable">array</span> = (<span class="keyword">int</span>*)<span class="function">malloc</span>(<span class="number">1000</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));
<span class="comment">// malloc does:</span>
<span class="comment">// 1. Search free list for suitable block</span>
<span class="comment">// 2. Split block if necessary</span>
<span class="comment">// 3. Update metadata (size, status)</span>
<span class="comment">// 4. Return pointer to usable memory</span>

<span class="comment">// Use the memory...</span>

<span class="function">free</span>(<span class="variable">array</span>);  <span class="comment">// Return memory to free list</span>
<span class="comment">// free does:</span>
<span class="comment">// 1. Mark block as free</span>
<span class="comment">// 2. Coalesce with adjacent free blocks</span>
<span class="comment">// 3. Update free list</span></code></pre>
                </div>
                
                <h4>Heap Management Algorithms</h4>
                <div style="margin-top: 1rem; padding: 1rem; background: rgba(255, 128, 0, 0.05); border-left: 3px solid var(--mclaren-orange);">
                    <p><strong>Common Allocation Strategies:</strong></p>
                    <ul style="margin: 0.5rem 0 0 1.5rem;">
                        <li><strong>First Fit:</strong> Use the first free block that's large enough (fast, more fragmentation)</li>
                        <li><strong>Best Fit:</strong> Find the smallest block that fits (slower, less fragmentation)</li>
                        <li><strong>Buddy System:</strong> Split blocks in powers of 2 (internal fragmentation, fast coalescing)</li>
                        <li><strong>Slab Allocation:</strong> Pre-allocate fixed-size blocks (used in kernel)</li>
                    </ul>
                </div>
                
                <h4>Heap Metadata Structure</h4>
                <div class="code-block">
                    <pre><code><span class="keyword">typedef struct</span> <span class="variable">heap_block</span> {
    <span class="keyword">size_t</span> <span class="variable">size</span>;          <span class="comment">// Block size (including metadata)</span>
    <span class="keyword">struct</span> <span class="variable">heap_block</span>* <span class="variable">next</span>; <span class="comment">// Next free block</span>
    <span class="keyword">struct</span> <span class="variable">heap_block</span>* <span class="variable">prev</span>; <span class="comment">// Previous free block</span>
    <span class="keyword">int</span> <span class="variable">is_free</span>;         <span class="comment">// Allocation status</span>
} <span class="variable">heap_block_t</span>;

<span class="comment">// Each allocation has overhead:</span>
<span class="comment">// - Metadata: 16-32 bytes</span>
<span class="comment">// - Alignment: Rounded to 8/16 bytes</span>
<span class="comment">// - Fragmentation: Wasted space between blocks</span></code></pre>
                </div>
                
                <div class="callout warning">
                    <div class="callout-title">Common Heap Problems</div>
                    <ul>
                        <li><strong>Memory Leaks:</strong> Forgetting to free allocated memory</li>
                        <li><strong>Double Free:</strong> Freeing the same memory twice</li>
                        <li><strong>Use After Free:</strong> Accessing memory after freeing it</li>
                        <li><strong>Heap Fragmentation:</strong> Many small free blocks that can't be used</li>
                        <li><strong>Buffer Overflow:</strong> Writing beyond allocated bounds</li>
                    </ul>
                </div>
            </div>
            
            <!-- Deep Dive: Heap Implementation Details -->
            <div class="feynman-dive">
                <h3>Deep Dive: How malloc Really Works</h3>
                <div class="feynman-content">
                    <p class="feynman-intro">
                        The heap allocator is one of the most complex pieces of system software. Let's examine how malloc and free actually manage memory.
                    </p>
                    
                    <h4>The Free List: Managing Available Memory</h4>
                    <p>
                        Most allocators maintain a linked list of free blocks. Each block contains metadata about its size and pointers to other free blocks.
                    </p>
                    
                    <div class="code-block">
                        <pre><code><span class="comment">/* Simplified malloc implementation */</span>
<span class="keyword">typedef struct</span> <span class="variable">block</span> {
    <span class="keyword">size_t</span> <span class="variable">size</span>;           <span class="comment">// Size of this block</span>
    <span class="keyword">struct</span> <span class="variable">block</span>* <span class="variable">next</span>;    <span class="comment">// Next free block</span>
    <span class="keyword">struct</span> <span class="variable">block</span>* <span class="variable">prev</span>;    <span class="comment">// Previous free block</span>
    <span class="keyword">int</span> <span class="variable">free</span>;              <span class="comment">// 1 if free, 0 if allocated</span>
} <span class="variable">block_t</span>;

<span class="keyword">void</span>* <span class="function">my_malloc</span>(<span class="keyword">size_t</span> <span class="variable">size</span>) {
    <span class="comment">// Align size to 8-byte boundary</span>
    <span class="variable">size</span> = (<span class="variable">size</span> + <span class="number">7</span>) & ~<span class="number">7</span>;
    
    <span class="comment">// Search free list for suitable block</span>
    <span class="variable">block_t</span>* <span class="variable">current</span> = <span class="variable">free_list_head</span>;
    <span class="keyword">while</span> (<span class="variable">current</span>) {
        <span class="keyword">if</span> (<span class="variable">current</span>-><span class="variable">free</span> && <span class="variable">current</span>-><span class="variable">size</span> >= <span class="variable">size</span>) {
            <span class="comment">// Found suitable block</span>
            <span class="keyword">if</span> (<span class="variable">current</span>-><span class="variable">size</span> > <span class="variable">size</span> + <span class="keyword">sizeof</span>(<span class="variable">block_t</span>) + <span class="number">16</span>) {
                <span class="comment">// Split the block if it's much larger</span>
                <span class="function">split_block</span>(<span class="variable">current</span>, <span class="variable">size</span>);
            }
            <span class="variable">current</span>-><span class="variable">free</span> = <span class="number">0</span>;
            <span class="keyword">return</span> (<span class="keyword">char</span>*)<span class="variable">current</span> + <span class="keyword">sizeof</span>(<span class="variable">block_t</span>);
        }
        <span class="variable">current</span> = <span class="variable">current</span>-><span class="variable">next</span>;
    }
    
    <span class="comment">// No suitable block found, request more from OS</span>
    <span class="keyword">return</span> <span class="function">request_from_os</span>(<span class="variable">size</span>);
}</code></pre>
                    </div>
                    
                    <h4>Memory Coalescing: Preventing Fragmentation</h4>
                    <p>
                        When freeing memory, the allocator tries to merge adjacent free blocks to prevent fragmentation.
                    </p>
                    
                    <div class="code-block">
                        <pre><code><span class="keyword">void</span> <span class="function">my_free</span>(<span class="keyword">void</span>* <span class="variable">ptr</span>) {
    <span class="keyword">if</span> (!<span class="variable">ptr</span>) <span class="keyword">return</span>;
    
    <span class="comment">// Get block header</span>
    <span class="variable">block_t</span>* <span class="variable">block</span> = (<span class="variable">block_t</span>*)((<span class="keyword">char</span>*)<span class="variable">ptr</span> - <span class="keyword">sizeof</span>(<span class="variable">block_t</span>));
    <span class="variable">block</span>-><span class="variable">free</span> = <span class="number">1</span>;
    
    <span class="comment">// Coalesce with previous block if free</span>
    <span class="keyword">if</span> (<span class="variable">block</span>-><span class="variable">prev</span> && <span class="variable">block</span>-><span class="variable">prev</span>-><span class="variable">free</span>) {
        <span class="variable">block</span>-><span class="variable">prev</span>-><span class="variable">size</span> += <span class="keyword">sizeof</span>(<span class="variable">block_t</span>) + <span class="variable">block</span>-><span class="variable">size</span>;
        <span class="variable">block</span>-><span class="variable">prev</span>-><span class="variable">next</span> = <span class="variable">block</span>-><span class="variable">next</span>;
        <span class="keyword">if</span> (<span class="variable">block</span>-><span class="variable">next</span>) {
            <span class="variable">block</span>-><span class="variable">next</span>-><span class="variable">prev</span> = <span class="variable">block</span>-><span class="variable">prev</span>;
        }
        <span class="variable">block</span> = <span class="variable">block</span>-><span class="variable">prev</span>;
    }
    
    <span class="comment">// Coalesce with next block if free</span>
    <span class="keyword">if</span> (<span class="variable">block</span>-><span class="variable">next</span> && <span class="variable">block</span>-><span class="variable">next</span>-><span class="variable">free</span>) {
        <span class="variable">block</span>-><span class="variable">size</span> += <span class="keyword">sizeof</span>(<span class="variable">block_t</span>) + <span class="variable">block</span>-><span class="variable">next</span>-><span class="variable">size</span>;
        <span class="variable">block</span>-><span class="variable">next</span> = <span class="variable">block</span>-><span class="variable">next</span>-><span class="variable">next</span>;
        <span class="keyword">if</span> (<span class="variable">block</span>-><span class="variable">next</span>) {
            <span class="variable">block</span>-><span class="variable">next</span>-><span class="variable">prev</span> = <span class="variable">block</span>;
        }
    }
}</code></pre>
                    </div>
                    
                    <div style="margin-top: 1rem; padding: 1rem; background: rgba(220, 0, 0, 0.05); border-left: 3px solid var(--redbull-red);">
                        <p><strong>Performance Implications of Heap Operations:</strong></p>
                        <ul style="margin: 0.5rem 0 0 1.5rem;">
                            <li><strong>malloc() complexity:</strong> O(n) worst case, where n = number of free blocks</li>
                            <li><strong>free() complexity:</strong> O(1) with coalescing</li>
                            <li><strong>Fragmentation overhead:</strong> 10-50% memory waste typical</li>
                            <li><strong>Metadata overhead:</strong> 8-16 bytes per allocation</li>
                            <li><strong>Thread contention:</strong> Global heap requires locking</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <!-- Modern Heap Allocators -->
            <div class="content-block">
                <h3>Modern Heap Allocator Implementations</h3>
                
                <h4>tcmalloc (Thread-Caching Malloc)</h4>
                <p>Google's tcmalloc uses thread-local caches to reduce contention:</p>
                
                <div class="code-block">
                    <pre><code><span class="comment">/* tcmalloc architecture */</span>
<span class="keyword">struct</span> <span class="variable">ThreadCache</span> {
    <span class="comment">// Small object bins (8, 16, 32, ... bytes)</span>
    <span class="variable">FreeList</span> <span class="variable">list</span>[<span class="variable">kNumClasses</span>];
    
    <span class="comment">// No locking needed for thread-local access!</span>
    <span class="keyword">void</span>* <span class="function">Allocate</span>(<span class="keyword">size_t</span> <span class="variable">size</span>) {
        <span class="keyword">if</span> (<span class="variable">size</span> <= <span class="variable">kMaxSize</span>) {
            <span class="keyword">int</span> <span class="variable">cl</span> = <span class="function">SizeClass</span>(<span class="variable">size</span>);
            <span class="keyword">return</span> <span class="variable">list</span>[<span class="variable">cl</span>].<span class="function">Pop</span>();  <span class="comment">// Fast path - no locks!</span>
        }
        <span class="keyword">return</span> <span class="function">CentralAlloc</span>(<span class="variable">size</span>);  <span class="comment">// Large objects</span>
    }
};</code></pre>
                </div>
                
                <h4>jemalloc: Size Classes and Arenas</h4>
                <p>Facebook's jemalloc uses multiple arenas to reduce contention and size classes to reduce fragmentation:</p>
                
                <div style="margin-top: 1rem; padding: 1rem; background: rgba(0, 129, 251, 0.05); border-left: 3px solid var(--meta-blue);">
                    <p><strong>jemalloc Size Classes:</strong></p>
                    <ul style="margin: 0.5rem 0 0 1.5rem; font-family: monospace;">
                        <li>Small: 8, 16, 32, 48, 64, 80, 96, 112, 128...</li>
                        <li>Large: 4KB, 8KB, 12KB, 16KB...</li>
                        <li>Huge: > 4MB (mmap directly)</li>
                    </ul>
                    <p style="margin-top: 0.5rem;">Each size class has its own free list, eliminating external fragmentation within the class.</p>
                </div>
                
                <h4>Memory Allocator Comparison</h4>
                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background: var(--glass-white);">
                            <th style="padding: 1rem; text-align: left; border-bottom: 2px solid var(--mclaren-orange);">Allocator</th>
                            <th style="padding: 1rem; text-align: left; border-bottom: 2px solid var(--mclaren-orange);">Best For</th>
                            <th style="padding: 1rem; text-align: left; border-bottom: 2px solid var(--mclaren-orange);">Trade-offs</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border);"><strong>glibc (ptmalloc)</strong></td>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border);">General purpose</td>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border);">Good all-around, higher fragmentation</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border);"><strong>tcmalloc</strong></td>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border);">Multi-threaded apps</td>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border);">Fast, higher memory usage</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border);"><strong>jemalloc</strong></td>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border);">Long-running servers</td>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border);">Low fragmentation, complex</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem;"><strong>mimalloc</strong></td>
                            <td style="padding: 0.75rem;">Performance critical</td>
                            <td style="padding: 0.75rem;">Very fast, newer/less tested</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <!-- Live Malloc/Free Algorithm Visualizer -->
            <div class="interactive-demo">
                <h3>Live Malloc/Free Algorithm Visualizer</h3>
                <p>Step through actual allocation algorithms and watch how they search, split, and coalesce memory blocks.</p>
                
                <div class="demo-controls">
                    <input type="number" id="malloc-size" value="64" min="8" max="256" placeholder="Size">
                    <select id="malloc-algorithm" style="padding: 0.5rem; margin-right: 1rem;">
                        <option value="first-fit">First Fit</option>
                        <option value="best-fit">Best Fit</option>
                        <option value="worst-fit">Worst Fit</option>
                        <option value="buddy">Buddy System</option>
                    </select>
                    <button class="control-button" onclick="mallocDemo.malloc()">malloc()</button>
                    <button class="control-button" onclick="mallocDemo.freeBlock()">free()</button>
                    <button class="control-button" onclick="mallocDemo.stepThrough()" id="step-btn">Step Through</button>
                    <button class="control-button" onclick="mallocDemo.reset()">Reset</button>
                </div>
                
                <!-- Free List Visualization -->
                <div style="margin-top: 1rem;">
                    <h4 style="color: var(--mclaren-orange); margin-bottom: 0.5rem;">Free List Structure</h4>
                    <div id="free-list-visual" style="background: var(--code-bg); border: 1px solid var(--glass-border); border-radius: var(--radius-sm); padding: 1rem; min-height: 100px;">
                        <!-- Free list will be visualized here -->
                    </div>
                </div>
                
                <!-- Heap Memory Map -->
                <div style="margin-top: 1rem;">
                    <h4 style="color: var(--meta-blue); margin-bottom: 0.5rem;">Heap Memory Map</h4>
                    <div id="malloc-heap-map" style="background: var(--code-bg); border: 1px solid var(--glass-border); border-radius: var(--radius-sm); padding: 1rem; position: relative; height: 200px;">
                        <!-- Heap blocks will be visualized here as a memory map -->
                    </div>
                </div>
                
                <!-- Algorithm Steps -->
                <div id="malloc-steps" style="margin-top: 1rem; padding: 1rem; background: rgba(0, 129, 251, 0.05); border-left: 3px solid var(--meta-blue); border-radius: var(--radius-sm);">
                    <h4 style="color: var(--meta-blue); margin-bottom: 0.5rem;">Algorithm Steps</h4>
                    <ol id="step-list" style="margin-left: 1.5rem; line-height: 1.8;">
                        <li>Ready to allocate or free memory...</li>
                    </ol>
                </div>
                
                <div id="malloc-trace" class="demo-output">
                    <div style="font-weight: 600; color: var(--mclaren-orange);">ALLOCATOR TRACE:</div>
                    <!-- Malloc/free operations will be logged here -->
                </div>
            </div>
            
            <!-- Memory Coalescing Demo -->
            <div class="interactive-demo">
                <h3>Memory Coalescing Visualizer</h3>
                <p>Watch how the allocator merges adjacent free blocks to prevent fragmentation.</p>
                
                <div class="demo-controls">
                    <button class="control-button" onclick="coalesceDemo.createFragmentation()">Create Fragmentation</button>
                    <button class="control-button" onclick="coalesceDemo.freeMiddle()">Free Middle Block</button>
                    <button class="control-button" onclick="coalesceDemo.coalesce()">Coalesce Now</button>
                    <button class="control-button" onclick="coalesceDemo.reset()">Reset</button>
                </div>
                
                <div style="margin-top: 1rem;">
                    <h4 style="color: #3fb950; margin-bottom: 0.5rem;">Before Coalescing</h4>
                    <div id="coalesce-before" style="background: var(--code-bg); border: 1px solid var(--glass-border); border-radius: var(--radius-sm); padding: 1rem; display: flex; gap: 4px; overflow-x: auto;">
                        <!-- Fragmented blocks will be shown here -->
                    </div>
                </div>
                
                <div style="margin-top: 1rem;">
                    <h4 style="color: #3fb950; margin-bottom: 0.5rem;">After Coalescing</h4>
                    <div id="coalesce-after" style="background: var(--code-bg); border: 1px solid var(--glass-border); border-radius: var(--radius-sm); padding: 1rem; display: flex; gap: 4px; overflow-x: auto;">
                        <!-- Coalesced blocks will be shown here -->
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-top: 1rem;">
                    <div style="text-align: center; padding: 1rem; background: var(--glass-white); border-radius: var(--radius-sm);">
                        <div style="font-size: 2rem; font-weight: bold; color: var(--redbull-red);">
                            <span id="fragment-count">0</span>
                        </div>
                        <div style="color: var(--text-muted);">Fragments</div>
                    </div>
                    <div style="text-align: center; padding: 1rem; background: var(--glass-white); border-radius: var(--radius-sm);">
                        <div style="font-size: 2rem; font-weight: bold; color: var(--mclaren-orange);">
                            <span id="wasted-bytes">0</span> B
                        </div>
                        <div style="color: var(--text-muted);">Wasted</div>
                    </div>
                    <div style="text-align: center; padding: 1rem; background: var(--glass-white); border-radius: var(--radius-sm);">
                        <div style="font-size: 2rem; font-weight: bold; color: #3fb950;">
                            <span id="recovered-bytes">0</span> B
                        </div>
                        <div style="color: var(--text-muted);">Recovered</div>
                    </div>
                </div>
                
                <div id="coalesce-trace" class="demo-output">
                    <div style="font-weight: 600; color: #3fb950;">COALESCING TRACE:</div>
                    <!-- Coalescing operations will be logged here -->
                </div>
            </div>

            <!-- Heap Allocator Demo -->
            <div class="interactive-demo">
                <h3>Interactive Heap Allocator Simulator</h3>
                <p>Visualize heap allocation, fragmentation, and memory management strategies.</p>
                
                <div class="demo-controls">
                    <input type="number" id="alloc-size" value="32" min="8" max="256" placeholder="Size">
                    <select id="alloc-strategy">
                        <option value="first-fit">First Fit</option>
                        <option value="best-fit">Best Fit</option>
                        <option value="worst-fit">Worst Fit</option>
                    </select>
                    <button class="control-button" onclick="heapDemo.allocate()">Allocate</button>
                    <button class="control-button" onclick="heapDemo.freeRandom()">Free Random</button>
                    <button class="control-button" onclick="heapDemo.defragment()">Defragment</button>
                    <button class="control-button" onclick="heapDemo.reset()">Reset</button>
                </div>
                
                <div class="memory-visual" id="heap-visual">
                    <!-- Heap blocks will be visualized here -->
                </div>
                
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-top: 1rem;">
                    <div style="text-align: center; padding: 1rem; background: var(--glass-white); border-radius: var(--radius-sm);">
                        <div style="font-size: 2rem; font-weight: bold; color: #3fb950;">
                            <span id="heap-allocated">0</span> B
                        </div>
                        <div style="color: var(--text-muted);">Allocated</div>
                    </div>
                    <div style="text-align: center; padding: 1rem; background: var(--glass-white); border-radius: var(--radius-sm);">
                        <div style="font-size: 2rem; font-weight: bold; color: var(--mclaren-orange);">
                            <span id="heap-free">1024</span> B
                        </div>
                        <div style="color: var(--text-muted);">Free</div>
                    </div>
                    <div style="text-align: center; padding: 1rem; background: var(--glass-white); border-radius: var(--radius-sm);">
                        <div style="font-size: 2rem; font-weight: bold; color: var(--redbull-red);">
                            <span id="heap-fragmentation">0</span>%
                        </div>
                        <div style="color: var(--text-muted);">Fragmentation</div>
                    </div>
                </div>
                
                <div id="heap-trace" class="demo-output">
                    <div style="font-weight: 600; color: var(--mclaren-orange);">HEAP TRACE:</div>
                    <!-- Heap operations will be logged here -->
                </div>
            </div>
        </article>

        <!-- Comparison Section -->
        <article id="comparison" class="section">
            <div class="section-header">
                <h2 class="section-title">Stack vs Heap: Detailed Comparison</h2>
                <p class="section-subtitle">When to use each type of memory</p>
            </div>
            
            <div class="content-block">
                <h3>Performance Comparison</h3>
                
                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background: var(--glass-white);">
                            <th style="padding: 1rem; text-align: left; border-bottom: 2px solid var(--mclaren-orange);">Aspect</th>
                            <th style="padding: 1rem; text-align: left; border-bottom: 2px solid var(--mclaren-orange);">Stack</th>
                            <th style="padding: 1rem; text-align: left; border-bottom: 2px solid var(--mclaren-orange);">Heap</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border);"><strong>Speed</strong></td>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border); color: #3fb950;">Very Fast (O(1))</td>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border); color: var(--mclaren-orange);">Slower (O(log n) typical)</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border);"><strong>Size Limit</strong></td>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border);">Limited (1-8 MB)</td>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border);">System RAM limit</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border);"><strong>Allocation</strong></td>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border);">Automatic</td>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border);">Manual (malloc/new)</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border);"><strong>Deallocation</strong></td>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border);">Automatic (scope-based)</td>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border);">Manual (free/delete)</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border);"><strong>Fragmentation</strong></td>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border); color: #3fb950;">No fragmentation</td>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border); color: var(--redbull-red);">Can fragment</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border);"><strong>Cache Performance</strong></td>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border); color: #3fb950;">Excellent locality</td>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border); color: var(--mclaren-orange);">Poor locality</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border);"><strong>Thread Safety</strong></td>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border); color: #3fb950;">Thread-local</td>
                            <td style="padding: 0.75rem; border-bottom: 1px solid var(--glass-border); color: var(--redbull-red);">Requires synchronization</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem;"><strong>Typical Use</strong></td>
                            <td style="padding: 0.75rem;">Local variables, function parameters</td>
                            <td style="padding: 0.75rem;">Dynamic data, large objects, shared data</td>
                        </tr>
                    </tbody>
                </table>
                
                <h4>Memory Access Patterns</h4>
                <div class="code-block">
                    <pre><code><span class="comment">// Stack allocation - predictable, cache-friendly</span>
<span class="keyword">void</span> <span class="function">stackExample</span>() {
    <span class="keyword">int</span> <span class="variable">arr</span>[<span class="number">1000</span>];  <span class="comment">// Contiguous, cache-line aligned</span>
    <span class="keyword">for</span>(<span class="keyword">int</span> <span class="variable">i</span> = <span class="number">0</span>; i < <span class="number">1000</span>; i++) {
        <span class="variable">arr</span>[i] = i;  <span class="comment">// Sequential access, ~95% cache hits</span>
    }
}  <span class="comment">// Automatic cleanup, no fragmentation</span>

<span class="comment">// Heap allocation - flexible but slower</span>
<span class="keyword">void</span> <span class="function">heapExample</span>() {
    <span class="keyword">int</span>* <span class="variable">arr</span> = <span class="function">malloc</span>(<span class="number">1000</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));
    <span class="comment">// May not be cache-aligned</span>
    <span class="comment">// Allocation involves free list traversal</span>
    <span class="keyword">for</span>(<span class="keyword">int</span> <span class="variable">i</span> = <span class="number">0</span>; i < <span class="number">1000</span>; i++) {
        <span class="variable">arr</span>[i] = i;  <span class="comment">// Still sequential, but initial misses</span>
    }
    <span class="function">free</span>(<span class="variable">arr</span>);  <span class="comment">// Manual cleanup required</span>
}</code></pre>
                </div>
            </div>
        </article>

        <!-- Best Practices Section -->
        <article id="best-practices" class="section">
            <div class="section-header">
                <h2 class="section-title">Best Practices & Optimization</h2>
                <p class="section-subtitle">Guidelines for efficient memory usage</p>
            </div>
            
            <div class="content-block">
                <h3>Stack Best Practices</h3>
                <ul>
                    <li>✓ Use stack for small, fixed-size data (< 1KB typically)</li>
                    <li>✓ Prefer stack allocation when lifetime is scope-bound</li>
                    <li>✓ Be careful with large arrays - can cause stack overflow</li>
                    <li>✓ Use recursion carefully - each call adds a stack frame</li>
                    <li>✓ Profile stack usage in embedded systems</li>
                </ul>
                
                <div class="callout success">
                    <div class="callout-title">Stack Optimization Tip</div>
                    <p>Modern compilers can optimize tail recursion into loops, eliminating stack frame overhead. Use -O2 or -O3 optimization flags.</p>
                </div>
                
                <h3>Heap Best Practices</h3>
                <ul>
                    <li>✓ Always match malloc/free or new/delete pairs</li>
                    <li>✓ Use RAII in C++ or smart pointers to prevent leaks</li>
                    <li>✓ Consider object pooling for frequent allocations</li>
                    <li>✓ Minimize heap fragmentation with consistent sizes</li>
                    <li>✓ Use memory profilers (Valgrind, AddressSanitizer)</li>
                </ul>
                
                <div class="callout warning">
                    <div class="callout-title">Common Pitfall</div>
                    <p>Never return pointers to stack-allocated variables! The memory becomes invalid when the function returns.</p>
                    <div class="code-block" style="margin-top: 0.5rem;">
                        <pre><code><span class="comment">// WRONG - Undefined behavior!</span>
<span class="keyword">int</span>* <span class="function">badFunction</span>() {
    <span class="keyword">int</span> <span class="variable">x</span> = <span class="number">42</span>;
    <span class="keyword">return</span> &<span class="variable">x</span>;  <span class="comment">// x is destroyed when function returns!</span>
}</code></pre>
                    </div>
                </div>
                
                <h3>Memory Debugging Tools</h3>
                <div style="margin-top: 1rem; padding: 1rem; background: rgba(63, 185, 80, 0.05); border-left: 3px solid #3fb950;">
                    <p><strong>Essential Tools for Memory Debugging:</strong></p>
                    <ul style="margin: 0.5rem 0 0 1.5rem;">
                        <li><strong>Valgrind (Linux):</strong> Detects leaks, corruption, and invalid accesses</li>
                        <li><strong>AddressSanitizer:</strong> Fast memory error detector (GCC/Clang)</li>
                        <li><strong>Visual Studio Diagnostics:</strong> Built-in heap profiler for Windows</li>
                        <li><strong>Instruments (macOS):</strong> Leak detection and allocation tracking</li>
                        <li><strong>tcmalloc/jemalloc:</strong> Alternative allocators with profiling</li>
                    </ul>
                </div>
            </div>
        </article>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2025 ROVER. Master Data Structures & Algorithms from the ground up.</p>
        </div>
    </footer>

    <!-- JavaScript for Interactive Features -->
    <script>
        // Reading Progress Bar
        window.addEventListener('scroll', () => {
            const windowHeight = window.innerHeight;
            const documentHeight = document.documentElement.scrollHeight - windowHeight;
            const scrolled = window.scrollY;
            const progress = (scrolled / documentHeight) * 100;
            document.getElementById('reading-progress').style.width = progress + '%';
        });

        // Intersection Observer for Fade-in Sections
        const sections = document.querySelectorAll('.section');
        const observerOptions = {
            threshold: 0.1,
            rootMargin: '0px 0px -100px 0px'
        };

        const sectionObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('visible');
                }
            });
        }, observerOptions);

        sections.forEach(section => {
            sectionObserver.observe(section);
        });

        // Active Navigation Link
        window.addEventListener('scroll', () => {
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.clientHeight;
                if (window.scrollY >= sectionTop - 200) {
                    current = section.getAttribute('id');
                }
            });

            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        });

        // Stack Demo with Enhanced Step Trace
        const stackDemo = {
            frames: [],
            stackPointer: 0x7FFFFFFFE000,
            traceLog: [],
            
            addTrace(operation, detail) {
                const timestamp = new Date().toLocaleTimeString();
                this.traceLog.unshift({operation, detail, timestamp});
                if (this.traceLog.length > 10) this.traceLog.pop();
                this.updateTraceDisplay();
            },
            
            updateTraceDisplay() {
                const traceElement = document.getElementById('stack-trace');
                if (traceElement) {
                    const titleHtml = '<div style="font-weight: 600; color: var(--meta-blue);">STACK TRACE:</div>';
                    traceElement.innerHTML = titleHtml + 
                        this.traceLog.map(entry => `
                            <div style="padding: 0.25rem; margin: 0.25rem 0; background: rgba(255, 255, 255, 0.02); border-left: 2px solid var(--meta-blue); font-size: 0.85rem;">
                                <span style="color: var(--text-dim);">[${entry.timestamp}]</span> 
                                <strong>${entry.operation}:</strong> ${entry.detail}
                            </div>
                        `).join('');
                }
            },
            
            callFunction() {
                const funcName = `func_${this.frames.length}`;
                const frameSize = 32 + Math.floor(Math.random() * 64);
                this.stackPointer -= frameSize;
                
                this.frames.push({
                    name: funcName,
                    address: `0x${this.stackPointer.toString(16).toUpperCase()}`,
                    size: frameSize,
                    locals: Math.floor(frameSize / 8)
                });
                
                this.addTrace('Function Call', `${funcName}() called. Frame size: ${frameSize} bytes. Stack grows down to ${this.frames[this.frames.length - 1].address}`);
                this.render();
            },
            
            returnFunction() {
                if (this.frames.length > 0) {
                    const frame = this.frames.pop();
                    this.stackPointer += frame.size;
                    this.addTrace('Function Return', `${frame.name}() returned. Released ${frame.size} bytes. Stack pointer restored to 0x${this.stackPointer.toString(16).toUpperCase()}`);
                } else {
                    this.addTrace('Return Failed', 'No active stack frames to return from');
                }
                this.render();
            },
            
            allocateLocal() {
                if (this.frames.length > 0) {
                    const size = 8 + Math.floor(Math.random() * 32);
                    this.stackPointer -= size;
                    this.frames[this.frames.length - 1].size += size;
                    this.frames[this.frames.length - 1].locals++;
                    this.addTrace('Local Allocation', `Allocated ${size} bytes for local variable in ${this.frames[this.frames.length - 1].name}()`);
                } else {
                    this.addTrace('Allocation Failed', 'No active stack frame for allocation');
                }
                this.render();
            },
            
            reset() {
                this.frames = [];
                this.stackPointer = 0x7FFFFFFFE000;
                this.traceLog = [];
                this.addTrace('Stack Reset', 'Stack cleared and pointer reset to initial position');
                this.render();
            },
            
            render() {
                const visual = document.getElementById('stack-visual');
                if (visual) {
                    visual.innerHTML = '';
                    
                    // Render from top (high address) to bottom (low address)
                    for (let i = this.frames.length - 1; i >= 0; i--) {
                        const frame = this.frames[i];
                        const row = document.createElement('div');
                        row.className = 'memory-row';
                        row.innerHTML = `
                            <span class="memory-addr">${frame.address}</span>
                            <span class="memory-content">${frame.name}() - ${frame.locals} locals, ${frame.size} bytes</span>
                            <span class="memory-type stack-mem">STACK</span>
                        `;
                        visual.appendChild(row);
                    }
                    
                    if (this.frames.length === 0) {
                        visual.innerHTML = '<div style="text-align: center; color: var(--text-dim); padding: 2rem;">Stack is empty - call a function to start</div>';
                    }
                }
            },
            
            init() {
                this.addTrace('Initialization', 'Stack demo initialized. Stack starts at 0x7FFFFFFFE000 and grows downward.');
                this.render();
            }
        };

        // Heap Demo with Enhanced Allocator Simulation
        const heapDemo = {
            blocks: [],
            heapSize: 1024,
            nextId: 0,
            traceLog: [],
            
            addTrace(operation, detail) {
                const timestamp = new Date().toLocaleTimeString();
                this.traceLog.unshift({operation, detail, timestamp});
                if (this.traceLog.length > 10) this.traceLog.pop();
                this.updateTraceDisplay();
            },
            
            updateTraceDisplay() {
                const traceElement = document.getElementById('heap-trace');
                if (traceElement) {
                    const titleHtml = '<div style="font-weight: 600; color: var(--mclaren-orange);">HEAP TRACE:</div>';
                    traceElement.innerHTML = titleHtml + 
                        this.traceLog.map(entry => `
                            <div style="padding: 0.25rem; margin: 0.25rem 0; background: rgba(255, 255, 255, 0.02); border-left: 2px solid ${entry.operation.includes('Free') || entry.operation.includes('Defrag') ? '#3fb950' : 'var(--mclaren-orange)'}; font-size: 0.85rem;">
                                <span style="color: var(--text-dim);">[${entry.timestamp}]</span> 
                                <strong>${entry.operation}:</strong> ${entry.detail}
                            </div>
                        `).join('');
                }
            },
            
            allocate() {
                const size = parseInt(document.getElementById('alloc-size').value) || 32;
                const strategy = document.getElementById('alloc-strategy').value;
                
                // Find free space based on strategy
                let position = this.findFreeSpace(size, strategy);
                
                if (position !== -1) {
                    const id = this.nextId++;
                    this.blocks.push({
                        id: id,
                        start: position,
                        size: size,
                        free: false
                    });
                    
                    this.addTrace('Heap Allocation', `Allocated ${size} bytes at position ${position} using ${strategy} strategy (Block ID: ${id})`);
                } else {
                    this.addTrace('Allocation Failed', `No suitable free space for ${size} bytes using ${strategy}`);
                }
                
                this.render();
                this.updateStats();
            },
            
            findFreeSpace(size, strategy) {
                const allocatedRanges = this.blocks
                    .filter(b => !b.free)
                    .sort((a, b) => a.start - b.start);
                
                let freeSpaces = [];
                let lastEnd = 0;
                
                for (let block of allocatedRanges) {
                    if (block.start - lastEnd >= size) {
                        freeSpaces.push({start: lastEnd, size: block.start - lastEnd});
                    }
                    lastEnd = block.start + block.size;
                }
                
                if (this.heapSize - lastEnd >= size) {
                    freeSpaces.push({start: lastEnd, size: this.heapSize - lastEnd});
                }
                
                if (freeSpaces.length === 0) return -1;
                
                switch(strategy) {
                    case 'first-fit':
                        return freeSpaces[0].start;
                    case 'best-fit':
                        freeSpaces.sort((a, b) => a.size - b.size);
                        return freeSpaces[0].start;
                    case 'worst-fit':
                        freeSpaces.sort((a, b) => b.size - a.size);
                        return freeSpaces[0].start;
                    default:
                        return freeSpaces[0].start;
                }
            },
            
            freeRandom() {
                const allocated = this.blocks.filter(b => !b.free);
                if (allocated.length > 0) {
                    const block = allocated[Math.floor(Math.random() * allocated.length)];
                    block.free = true;
                    this.addTrace('Memory Freed', `Freed block ${block.id} (${block.size} bytes at position ${block.start})`);
                } else {
                    this.addTrace('Free Failed', 'No allocated blocks to free');
                }
                this.render();
                this.updateStats();
            },
            
            defragment() {
                // Remove free blocks and compact
                this.blocks = this.blocks.filter(b => !b.free);
                this.blocks.sort((a, b) => a.start - b.start);
                
                let position = 0;
                for (let block of this.blocks) {
                    block.start = position;
                    position += block.size;
                }
                
                this.addTrace('Defragmentation', `Heap defragmented. Compacted ${this.blocks.length} blocks.`);
                this.render();
                this.updateStats();
            },
            
            reset() {
                this.blocks = [];
                this.nextId = 0;
                this.traceLog = [];
                this.addTrace('Heap Reset', `Heap cleared. ${this.heapSize} bytes available.`);
                this.render();
                this.updateStats();
            },
            
            updateStats() {
                const allocated = this.blocks.filter(b => !b.free).reduce((sum, b) => sum + b.size, 0);
                const free = this.heapSize - allocated;
                
                // Calculate fragmentation
                const allocatedBlocks = this.blocks.filter(b => !b.free).sort((a, b) => a.start - b.start);
                let fragments = 0;
                let lastEnd = 0;
                
                for (let block of allocatedBlocks) {
                    if (block.start > lastEnd) fragments++;
                    lastEnd = block.start + block.size;
                }
                
                const fragmentation = allocatedBlocks.length > 0 ? Math.round((fragments / (allocatedBlocks.length + 1)) * 100) : 0;
                
                document.getElementById('heap-allocated').textContent = allocated;
                document.getElementById('heap-free').textContent = free;
                document.getElementById('heap-fragmentation').textContent = fragmentation;
            },
            
            render() {
                const visual = document.getElementById('heap-visual');
                if (visual) {
                    visual.innerHTML = '';
                    
                    // Sort blocks by position
                    const sortedBlocks = [...this.blocks].sort((a, b) => a.start - b.start);
                    
                    for (let block of sortedBlocks) {
                        const row = document.createElement('div');
                        row.className = 'memory-row';
                        row.style.opacity = block.free ? '0.5' : '1';
                        row.innerHTML = `
                            <span class="memory-addr">0x${(0x10000000 + block.start).toString(16).toUpperCase()}</span>
                            <span class="memory-content">Block ${block.id}: ${block.size} bytes ${block.free ? '(FREE)' : '(ALLOCATED)'}</span>
                            <span class="memory-type heap-mem">HEAP</span>
                        `;
                        visual.appendChild(row);
                    }
                    
                    if (this.blocks.length === 0) {
                        visual.innerHTML = '<div style="text-align: center; color: var(--text-dim); padding: 2rem;">Heap is empty - allocate memory to start</div>';
                    }
                }
            },
            
            init() {
                this.addTrace('Initialization', `Heap allocator initialized with ${this.heapSize} bytes`);
                this.render();
                this.updateStats();
            }
        };

        // Assembly Stack Demo
        const asmStackDemo = {
            registers: {
                rsp: 0x7FFFFFFFE000,
                rbp: 0x7FFFFFFFE020,
                rax: 0,
                rbx: 0,
                rip: 0x401000
            },
            stack: [],
            traceLog: [],
            
            execute() {
                const instruction = document.getElementById('asm-instruction').value;
                let asmCode = '';
                
                switch(instruction) {
                    case 'push-reg':
                        this.registers.rsp -= 8;
                        this.stack.unshift({ addr: this.registers.rsp, value: this.registers.rax, type: 'register' });
                        asmCode = `push   rax        ; RSP -= 8, [RSP] = RAX`;
                        this.addTrace('PUSH RAX', `Pushed RAX (0x${this.registers.rax.toString(16)}) to stack at 0x${this.registers.rsp.toString(16).toUpperCase()}`);
                        break;
                        
                    case 'push-imm':
                        this.registers.rsp -= 8;
                        const immValue = 0x42;
                        this.stack.unshift({ addr: this.registers.rsp, value: immValue, type: 'immediate' });
                        asmCode = `push   0x42      ; RSP -= 8, [RSP] = 0x42`;
                        this.addTrace('PUSH 0x42', `Pushed immediate value 0x42 to stack at 0x${this.registers.rsp.toString(16).toUpperCase()}`);
                        break;
                        
                    case 'pop':
                        if (this.stack.length > 0) {
                            const popped = this.stack.shift();
                            this.registers.rax = popped.value;
                            this.registers.rsp += 8;
                            asmCode = `pop    rax        ; RAX = [RSP], RSP += 8`;
                            this.addTrace('POP RAX', `Popped 0x${popped.value.toString(16)} from stack into RAX`);
                        }
                        break;
                        
                    case 'call':
                        const returnAddr = this.registers.rip + 5; // CALL instruction is 5 bytes
                        this.registers.rsp -= 8;
                        this.stack.unshift({ addr: this.registers.rsp, value: returnAddr, type: 'return' });
                        this.registers.rip = 0x402000; // Jump to function
                        asmCode = `call   0x402000  ; Push return addr, jump to function`;
                        this.addTrace('CALL', `Pushed return address 0x${returnAddr.toString(16).toUpperCase()}, jumped to 0x402000`);
                        break;
                        
                    case 'ret':
                        if (this.stack.length > 0 && this.stack[0].type === 'return') {
                            const retAddr = this.stack.shift();
                            this.registers.rip = retAddr.value;
                            this.registers.rsp += 8;
                            asmCode = `ret              ; RIP = [RSP], RSP += 8`;
                            this.addTrace('RET', `Returned to 0x${retAddr.value.toString(16).toUpperCase()}`);
                        }
                        break;
                        
                    case 'sub-rsp':
                        const allocSize = 0x20;
                        this.registers.rsp -= allocSize;
                        asmCode = `sub    rsp, 0x20 ; Allocate 32 bytes on stack`;
                        this.addTrace('SUB RSP', `Allocated 32 bytes on stack, RSP now 0x${this.registers.rsp.toString(16).toUpperCase()}`);
                        break;
                        
                    case 'add-rsp':
                        const deallocSize = 0x20;
                        this.registers.rsp += deallocSize;
                        asmCode = `add    rsp, 0x20 ; Deallocate 32 bytes from stack`;
                        this.addTrace('ADD RSP', `Deallocated 32 bytes from stack, RSP now 0x${this.registers.rsp.toString(16).toUpperCase()}`);
                        break;
                }
                
                this.updateDisplay(asmCode);
            },
            
            step() {
                // Simplified step-through for demonstration
                this.execute();
            },
            
            reset() {
                this.registers = {
                    rsp: 0x7FFFFFFFE000,
                    rbp: 0x7FFFFFFFE020,
                    rax: 0,
                    rbx: 0,
                    rip: 0x401000
                };
                this.stack = [];
                this.traceLog = [];
                this.addTrace('RESET', 'Stack and registers reset to initial state');
                this.updateDisplay('');
            },
            
            updateDisplay(asmCode) {
                // Update registers
                document.getElementById('register-rsp').innerHTML = `RSP: <span style="color: var(--mclaren-orange);">0x${this.registers.rsp.toString(16).toUpperCase()}</span>`;
                document.getElementById('register-rbp').innerHTML = `RBP: <span style="color: var(--mclaren-orange);">0x${this.registers.rbp.toString(16).toUpperCase()}</span>`;
                document.getElementById('register-rax').innerHTML = `RAX: <span style="color: var(--meta-blue);">0x${this.registers.rax.toString(16).padStart(16, '0').toUpperCase()}</span>`;
                document.getElementById('register-rip').innerHTML = `RIP: <span style="color: #3fb950;">0x${this.registers.rip.toString(16).padStart(16, '0').toUpperCase()}</span>`;
                
                // Update stack memory view
                const stackMemory = document.getElementById('asm-stack-memory');
                if (stackMemory) {
                    let html = '';
                    for (let i = 0; i < Math.max(5, this.stack.length); i++) {
                        const addr = this.registers.rsp + i * 8;
                        const item = this.stack[i];
                        const value = item ? `0x${item.value.toString(16).padStart(16, '0').toUpperCase()}` : '0x0000000000000000';
                        const highlight = i === 0 ? 'style="background: rgba(255, 128, 0, 0.1); border-left: 2px solid var(--mclaren-orange);"' : '';
                        const label = item ? (item.type === 'return' ? ' (return addr)' : item.type === 'register' ? ' (saved reg)' : '') : '';
                        html += `<div ${highlight}>0x${addr.toString(16).toUpperCase()}: ${value}${label}</div>`;
                    }
                    stackMemory.innerHTML = html || '<div style="color: var(--text-dim);">Stack is empty</div>';
                }
                
                // Update assembly code display
                if (asmCode) {
                    document.getElementById('asm-code-content').innerHTML = `<span class="keyword">${asmCode.split(' ')[0]}</span>   ${asmCode.substring(asmCode.indexOf(' ') + 1)}`;
                }
            },
            
            addTrace(operation, detail) {
                const timestamp = new Date().toLocaleTimeString();
                this.traceLog.unshift({operation, detail, timestamp});
                if (this.traceLog.length > 8) this.traceLog.pop();
                
                const traceElement = document.getElementById('asm-trace');
                if (traceElement) {
                    const titleHtml = '<div style="font-weight: 600; color: var(--meta-blue);">INSTRUCTION TRACE:</div>';
                    traceElement.innerHTML = titleHtml + 
                        this.traceLog.map(entry => `
                            <div style="padding: 0.25rem; margin: 0.25rem 0; background: rgba(255, 255, 255, 0.02); border-left: 2px solid var(--meta-blue); font-size: 0.85rem;">
                                <span style="color: var(--text-dim);">[${entry.timestamp}]</span> 
                                <strong>${entry.operation}:</strong> ${entry.detail}
                            </div>
                        `).join('');
                }
            },
            
            init() {
                this.reset();
            }
        };
        
        // Malloc/Free Algorithm Demo
        const mallocDemo = {
            heap: [],
            freeList: [],
            totalSize: 1024,
            traceLog: [],
            stepMode: false,
            currentStep: 0,
            steps: [],
            
            malloc() {
                const size = parseInt(document.getElementById('malloc-size').value) || 64;
                const algorithm = document.getElementById('malloc-algorithm').value;
                
                this.steps = [];
                this.currentStep = 0;
                
                // Find a suitable block based on algorithm
                let selectedBlock = null;
                let selectedIndex = -1;
                
                switch(algorithm) {
                    case 'first-fit':
                        this.steps.push('Searching for first block >= ' + size + ' bytes');
                        for (let i = 0; i < this.freeList.length; i++) {
                            if (this.freeList[i].size >= size) {
                                selectedBlock = this.freeList[i];
                                selectedIndex = i;
                                this.steps.push(`Found block at position ${selectedBlock.start}, size ${selectedBlock.size}`);
                                break;
                            }
                        }
                        break;
                        
                    case 'best-fit':
                        this.steps.push('Searching for smallest block >= ' + size + ' bytes');
                        let bestSize = Infinity;
                        for (let i = 0; i < this.freeList.length; i++) {
                            if (this.freeList[i].size >= size && this.freeList[i].size < bestSize) {
                                selectedBlock = this.freeList[i];
                                selectedIndex = i;
                                bestSize = this.freeList[i].size;
                            }
                        }
                        if (selectedBlock) {
                            this.steps.push(`Found best fit at position ${selectedBlock.start}, size ${selectedBlock.size}`);
                        }
                        break;
                        
                    case 'worst-fit':
                        this.steps.push('Searching for largest available block');
                        let worstSize = 0;
                        for (let i = 0; i < this.freeList.length; i++) {
                            if (this.freeList[i].size >= size && this.freeList[i].size > worstSize) {
                                selectedBlock = this.freeList[i];
                                selectedIndex = i;
                                worstSize = this.freeList[i].size;
                            }
                        }
                        if (selectedBlock) {
                            this.steps.push(`Found worst fit at position ${selectedBlock.start}, size ${selectedBlock.size}`);
                        }
                        break;
                }
                
                if (selectedBlock) {
                    // Allocate from the selected block
                    const allocated = {
                        start: selectedBlock.start,
                        size: size,
                        id: Date.now(),
                        free: false
                    };
                    this.heap.push(allocated);
                    
                    // Split the block if necessary
                    if (selectedBlock.size > size + 16) { // Min block size = 16
                        this.steps.push(`Splitting block: keeping ${size} bytes, returning ${selectedBlock.size - size} bytes to free list`);
                        this.freeList[selectedIndex] = {
                            start: selectedBlock.start + size,
                            size: selectedBlock.size - size
                        };
                    } else {
                        this.steps.push('Block fully allocated (no splitting needed)');
                        this.freeList.splice(selectedIndex, 1);
                    }
                    
                    this.addTrace('MALLOC SUCCESS', `Allocated ${size} bytes at position ${allocated.start} using ${algorithm}`);
                    this.steps.push(`✓ Allocation complete: ${size} bytes at address 0x${allocated.start.toString(16).toUpperCase()}`);
                } else {
                    this.steps.push('✗ No suitable block found - allocation failed');
                    this.addTrace('MALLOC FAILED', `No block found for ${size} bytes using ${algorithm}`);
                }
                
                if (this.stepMode) {
                    this.showStep();
                } else {
                    this.showAllSteps();
                }
                this.render();
            },
            
            freeBlock() {
                if (this.heap.length === 0) return;
                
                // Free a random allocated block
                const allocated = this.heap.filter(b => !b.free);
                if (allocated.length === 0) return;
                
                const block = allocated[Math.floor(Math.random() * allocated.length)];
                block.free = true;
                
                // Add back to free list
                this.freeList.push({
                    start: block.start,
                    size: block.size
                });
                
                // Sort free list by start position
                this.freeList.sort((a, b) => a.start - b.start);
                
                // Attempt to coalesce
                this.coalesceFreelist();
                
                this.addTrace('FREE', `Freed ${block.size} bytes at position ${block.start}`);
                this.render();
            },
            
            coalesceFreelist() {
                let i = 0;
                while (i < this.freeList.length - 1) {
                    if (this.freeList[i].start + this.freeList[i].size === this.freeList[i + 1].start) {
                        // Merge blocks
                        this.freeList[i].size += this.freeList[i + 1].size;
                        this.freeList.splice(i + 1, 1);
                        this.addTrace('COALESCE', `Merged adjacent free blocks at position ${this.freeList[i].start}`);
                    } else {
                        i++;
                    }
                }
            },
            
            stepThrough() {
                this.stepMode = !this.stepMode;
                document.getElementById('step-btn').textContent = this.stepMode ? 'Auto Mode' : 'Step Through';
                if (this.stepMode && this.steps.length > 0) {
                    this.currentStep = 0;
                    this.showStep();
                }
            },
            
            showStep() {
                const stepList = document.getElementById('step-list');
                if (stepList && this.currentStep < this.steps.length) {
                    stepList.innerHTML = this.steps.slice(0, this.currentStep + 1).map((step, i) => 
                        `<li style="${i === this.currentStep ? 'color: var(--mclaren-orange); font-weight: 600;' : ''}">${step}</li>`
                    ).join('');
                    this.currentStep++;
                }
            },
            
            showAllSteps() {
                const stepList = document.getElementById('step-list');
                if (stepList) {
                    stepList.innerHTML = this.steps.map(step => `<li>${step}</li>`).join('');
                }
            },
            
            reset() {
                this.heap = [];
                this.freeList = [{ start: 0, size: this.totalSize }];
                this.traceLog = [];
                this.steps = ['Heap reset: 1024 bytes available'];
                this.currentStep = 0;
                this.stepMode = false;
                document.getElementById('step-btn').textContent = 'Step Through';
                this.showAllSteps();
                this.addTrace('RESET', 'Heap reset to initial state');
                this.render();
            },
            
            render() {
                // Render free list
                const freeListVisual = document.getElementById('free-list-visual');
                if (freeListVisual) {
                    if (this.freeList.length > 0) {
                        freeListVisual.innerHTML = this.freeList.map(block => 
                            `<div style="display: inline-block; margin: 0.25rem; padding: 0.5rem; background: rgba(63, 185, 80, 0.2); border: 1px solid #3fb950; border-radius: 4px; font-family: monospace;">
                                <strong>Free Block</strong><br>
                                Start: 0x${block.start.toString(16).toUpperCase()}<br>
                                Size: ${block.size} bytes
                            </div>`
                        ).join('→');
                    } else {
                        freeListVisual.innerHTML = '<div style="color: var(--text-dim);">Free list is empty (heap full)</div>';
                    }
                }
                
                // Render heap map
                const heapMap = document.getElementById('malloc-heap-map');
                if (heapMap) {
                    heapMap.innerHTML = '';
                    
                    // Create visual blocks
                    const allBlocks = [];
                    
                    // Add allocated blocks
                    this.heap.forEach(block => {
                        if (!block.free) {
                            allBlocks.push({ ...block, type: 'allocated' });
                        }
                    });
                    
                    // Add free blocks
                    this.freeList.forEach(block => {
                        allBlocks.push({ ...block, type: 'free' });
                    });
                    
                    // Sort by position
                    allBlocks.sort((a, b) => a.start - b.start);
                    
                    // Render blocks
                    allBlocks.forEach(block => {
                        const width = (block.size / this.totalSize) * 100;
                        const left = (block.start / this.totalSize) * 100;
                        const div = document.createElement('div');
                        div.style.cssText = `
                            position: absolute;
                            left: ${left}%;
                            width: ${width}%;
                            height: 60px;
                            top: 50%;
                            transform: translateY(-50%);
                            background: ${block.type === 'allocated' ? 'var(--mclaren-orange)' : 'rgba(63, 185, 80, 0.3)'};
                            border: 1px solid ${block.type === 'allocated' ? 'var(--mclaren-light)' : '#3fb950'};
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            color: white;
                            font-size: 0.8rem;
                            font-family: monospace;
                            overflow: hidden;
                        `;
                        div.textContent = `${block.size}B`;
                        div.title = `${block.type === 'allocated' ? 'Allocated' : 'Free'} - Start: ${block.start}, Size: ${block.size}`;
                        heapMap.appendChild(div);
                    });
                }
            },
            
            addTrace(operation, detail) {
                const timestamp = new Date().toLocaleTimeString();
                this.traceLog.unshift({operation, detail, timestamp});
                if (this.traceLog.length > 8) this.traceLog.pop();
                
                const traceElement = document.getElementById('malloc-trace');
                if (traceElement) {
                    const titleHtml = '<div style="font-weight: 600; color: var(--mclaren-orange);">ALLOCATOR TRACE:</div>';
                    traceElement.innerHTML = titleHtml + 
                        this.traceLog.map(entry => `
                            <div style="padding: 0.25rem; margin: 0.25rem 0; background: rgba(255, 255, 255, 0.02); border-left: 2px solid ${entry.operation.includes('FREE') || entry.operation.includes('COALESCE') ? '#3fb950' : 'var(--mclaren-orange)'}; font-size: 0.85rem;">
                                <span style="color: var(--text-dim);">[${entry.timestamp}]</span> 
                                <strong>${entry.operation}:</strong> ${entry.detail}
                            </div>
                        `).join('');
                }
            },
            
            init() {
                this.reset();
            }
        };
        
        // Coalescing Demo
        const coalesceDemo = {
            blocks: [],
            traceLog: [],
            
            createFragmentation() {
                // Create a fragmented heap
                this.blocks = [
                    { start: 0, size: 64, free: false, id: 1 },
                    { start: 64, size: 32, free: true, id: 2 },
                    { start: 96, size: 128, free: false, id: 3 },
                    { start: 224, size: 48, free: true, id: 4 },
                    { start: 272, size: 96, free: false, id: 5 },
                    { start: 368, size: 64, free: true, id: 6 },
                    { start: 432, size: 80, free: false, id: 7 },
                    { start: 512, size: 32, free: true, id: 8 }
                ];
                
                this.addTrace('FRAGMENTATION CREATED', '8 blocks created, 4 free blocks scattered');
                this.render();
                this.updateStats();
            },
            
            freeMiddle() {
                // Free some middle blocks to create adjacent free blocks
                const middleBlocks = [3, 5];
                middleBlocks.forEach(id => {
                    const block = this.blocks.find(b => b.id === id);
                    if (block && !block.free) {
                        block.free = true;
                        this.addTrace('FREED BLOCK', `Block ${id} (${block.size} bytes) freed at position ${block.start}`);
                    }
                });
                this.render();
                this.updateStats();
            },
            
            coalesce() {
                let merged = 0;
                let i = 0;
                
                while (i < this.blocks.length - 1) {
                    if (this.blocks[i].free && this.blocks[i + 1].free && 
                        this.blocks[i].start + this.blocks[i].size === this.blocks[i + 1].start) {
                        // Merge adjacent free blocks
                        const mergedSize = this.blocks[i].size + this.blocks[i + 1].size;
                        const mergedStart = this.blocks[i].start;
                        
                        this.blocks[i].size = mergedSize;
                        this.blocks.splice(i + 1, 1);
                        merged++;
                        
                        this.addTrace('COALESCED', `Merged blocks at ${mergedStart} and ${mergedStart + this.blocks[i].size - this.blocks[i + 1].size}, new size: ${mergedSize} bytes`);
                    } else {
                        i++;
                    }
                }
                
                if (merged > 0) {
                    this.addTrace('COALESCING COMPLETE', `Merged ${merged} pairs of adjacent free blocks`);
                } else {
                    this.addTrace('NO COALESCING', 'No adjacent free blocks found');
                }
                
                this.render();
                this.updateStats();
            },
            
            reset() {
                this.blocks = [];
                this.traceLog = [];
                this.addTrace('RESET', 'Heap cleared');
                this.render();
                this.updateStats();
            },
            
            render() {
                // Render before state
                const beforeDiv = document.getElementById('coalesce-before');
                const afterDiv = document.getElementById('coalesce-after');
                
                const renderBlocks = (container, blocks) => {
                    container.innerHTML = blocks.map(block => 
                        `<div style="
                            min-width: ${block.size}px;
                            height: 60px;
                            background: ${block.free ? 'rgba(63, 185, 80, 0.3)' : 'var(--mclaren-orange)'};
                            border: 2px solid ${block.free ? '#3fb950' : 'var(--mclaren-light)'};
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            color: white;
                            font-family: monospace;
                            font-size: 0.8rem;
                            border-radius: 4px;
                        ">
                            ${block.size}B<br>
                            ${block.free ? 'FREE' : `ID:${block.id}`}
                        </div>`
                    ).join('');
                };
                
                if (beforeDiv) {
                    renderBlocks(beforeDiv, this.blocks);
                }
                
                // Simulate coalesced state for after view
                if (afterDiv) {
                    const simulatedBlocks = [...this.blocks];
                    let i = 0;
                    while (i < simulatedBlocks.length - 1) {
                        if (simulatedBlocks[i].free && simulatedBlocks[i + 1].free && 
                            simulatedBlocks[i].start + simulatedBlocks[i].size === simulatedBlocks[i + 1].start) {
                            simulatedBlocks[i].size += simulatedBlocks[i + 1].size;
                            simulatedBlocks.splice(i + 1, 1);
                        } else {
                            i++;
                        }
                    }
                    renderBlocks(afterDiv, simulatedBlocks);
                }
            },
            
            updateStats() {
                const freeBlocks = this.blocks.filter(b => b.free);
                const fragmentCount = freeBlocks.length;
                const wastedBytes = freeBlocks.reduce((sum, b) => sum + (b.size < 32 ? b.size : 0), 0);
                
                // Calculate potential recovery
                let recoverable = 0;
                for (let i = 0; i < this.blocks.length - 1; i++) {
                    if (this.blocks[i].free && this.blocks[i + 1].free && 
                        this.blocks[i].start + this.blocks[i].size === this.blocks[i + 1].start) {
                        recoverable += Math.min(this.blocks[i].size, this.blocks[i + 1].size);
                    }
                }
                
                document.getElementById('fragment-count').textContent = fragmentCount;
                document.getElementById('wasted-bytes').textContent = wastedBytes;
                document.getElementById('recovered-bytes').textContent = recoverable;
            },
            
            addTrace(operation, detail) {
                const timestamp = new Date().toLocaleTimeString();
                this.traceLog.unshift({operation, detail, timestamp});
                if (this.traceLog.length > 8) this.traceLog.pop();
                
                const traceElement = document.getElementById('coalesce-trace');
                if (traceElement) {
                    const titleHtml = '<div style="font-weight: 600; color: #3fb950;">COALESCING TRACE:</div>';
                    traceElement.innerHTML = titleHtml + 
                        this.traceLog.map(entry => `
                            <div style="padding: 0.25rem; margin: 0.25rem 0; background: rgba(255, 255, 255, 0.02); border-left: 2px solid #3fb950; font-size: 0.85rem;">
                                <span style="color: var(--text-dim);">[${entry.timestamp}]</span> 
                                <strong>${entry.operation}:</strong> ${entry.detail}
                            </div>
                        `).join('');
                }
            },
            
            init() {
                this.reset();
            }
        };
        
        // Initialize demos

        // Hamburger Menu Toggle
        const hamburgerMenu = document.getElementById('hamburgerMenu');
        const navElement = document.getElementById('navLinks') || document.getElementById('navActions');
        
        if (hamburgerMenu && navElement) {
            hamburgerMenu.addEventListener('click', function() {
                hamburgerMenu.classList.toggle('active');
                navElement.classList.toggle('active');
            });
            
            // Close menu when clicking on a nav link (mobile)
            if (document.getElementById('navLinks')) {
                document.querySelectorAll('.nav-link').forEach(link => {
                    link.addEventListener('click', function() {
                        if (window.innerWidth <= 768) {
                            hamburgerMenu.classList.remove('active');
                            navElement.classList.remove('active');
                        }
                    });
                });
            }
            
            // Close menu when clicking outside
            document.addEventListener('click', function(event) {
                if (window.innerWidth <= 768) {
                    if (!hamburgerMenu.contains(event.target) && !navElement.contains(event.target)) {
                        hamburgerMenu.classList.remove('active');
                        navElement.classList.remove('active');
                    }
                }
            });
        }


                document.addEventListener('DOMContentLoaded', () => {
            stackDemo.init();
            heapDemo.init();
            asmStackDemo.init();
            mallocDemo.init();
            coalesceDemo.init();
        });
    </script>
</body>
</html>
