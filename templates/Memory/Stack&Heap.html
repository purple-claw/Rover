<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stack vs Heap Memory | DS-Rover</title>
    
    <!-- Netflix Sans Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Netflix+Sans:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            /* Modern Color Palette */
            --primary-bg: #0d1117;
            --secondary-bg: #161b22;
            --card-bg: #21262d;
            --border-color: #30363d;
            --text-primary: #f0f6fc;
            --text-muted: #8b949e;
            --text-secondary: #c9d1d9;
            
            /* Accent Colors */
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-orange: #f78166;
            --accent-red: #ff6b6b;
            --accent-purple: #a855f7;
            
            /* Code Colors */
            --code-bg: #0d1117;
            --code-keyword: #ff7b72;
            --code-function: #d2a8ff;
            --code-string: #a5d6ff;
            --code-comment: #8b949e;
            --code-number: #79c0ff;
            --code-variable: #ffa657;
            
            /* Layout */
            --max-width: 1200px;
            --border-radius: 12px;
            --animation-speed: 0.3s;
            --shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            --shadow-lg: 0 16px 64px rgba(0, 0, 0, 0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Netflix Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--primary-bg);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
        }

        .container {
            max-width: var(--max-width);
            margin: 0 auto;
            padding: 0 2rem;
        }

        /* Navigation */
        nav {
            position: sticky;
            top: 0;
            background: rgba(13, 17, 23, 0.9);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-color);
            z-index: 100;
            padding: 1rem 0;
        }

        .nav-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .nav-logo {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-blue);
        }

        .nav-links {
            display: flex;
            list-style: none;
            gap: 2rem;
        }

        .nav-links a {
            color: var(--text-muted);
            text-decoration: none;
            font-weight: 500;
            transition: color var(--animation-speed);
            position: relative;
        }

        .nav-links a:hover,
        .nav-links a.active {
            color: var(--accent-blue);
        }

        .nav-links a.active::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--accent-blue);
        }

        /* Progress Bar */
        .progress-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: var(--secondary-bg);
            z-index: 1000;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple));
            width: 0%;
            transition: width 0.1s ease;
        }

        /* Hero Section */
        .hero {
            text-align: center;
            padding: 4rem 0;
            background: linear-gradient(135deg, rgba(88, 166, 255, 0.1), rgba(168, 85, 247, 0.1));
            border-radius: var(--border-radius);
            margin: 2rem 0;
        }

        .hero h1 {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .hero p {
            font-size: 1.2rem;
            color: var(--text-muted);
            max-width: 800px;
            margin: 0 auto;
        }

        /* Cards */
        .card {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 2rem;
            margin: 2rem 0;
            box-shadow: var(--shadow);
            transition: all var(--animation-speed);
        }

        .card:hover {
            transform: translateY(-4px);
            box-shadow: var(--shadow-lg);
            border-color: var(--accent-blue);
        }

        .card-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .card-header .icon {
            font-size: 2rem;
        }

        .card-header h3 {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Memory Visualization */
        .memory-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin: 2rem 0;
        }

        .memory-section {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            box-shadow: var(--shadow);
        }

        .memory-title {
            font-size: 1.2rem;
            font-weight: 600;
            text-align: center;
            margin-bottom: 1rem;
            color: var(--accent-blue);
        }

        .memory-visual {
            height: 300px;
            background: var(--code-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            margin-bottom: 1rem;
        }

        .memory-block {
            position: absolute;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            color: var(--primary-bg);
            padding: 0.5rem;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            font-weight: 600;
            text-align: center;
            transition: all var(--animation-speed);
            cursor: pointer;
        }

        .memory-block:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 16px rgba(88, 166, 255, 0.3);
        }

        .stack-block {
            background: linear-gradient(135deg, var(--accent-green), var(--accent-blue));
            width: calc(100% - 20px);
            height: 30px;
            left: 10px;
        }

        .heap-block {
            background: linear-gradient(135deg, var(--accent-orange), var(--accent-red));
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn {
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            color: var(--primary-bg);
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 8px;
            font-family: inherit;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--animation-speed);
            text-decoration: none;
            display: inline-block;
            text-align: center;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(88, 166, 255, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.green {
            background: linear-gradient(135deg, var(--accent-green), #22c55e);
        }

        .btn.orange {
            background: linear-gradient(135deg, var(--accent-orange), #f97316);
        }

        .btn.red {
            background: linear-gradient(135deg, var(--accent-red), #ef4444);
        }

        /* Code Blocks */
        .code-container {
            margin: 2rem 0;
        }

        .code-title {
            background: var(--secondary-bg);
            color: var(--text-muted);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            padding: 0.8rem 1.5rem;
            border-top-left-radius: var(--border-radius);
            border-top-right-radius: var(--border-radius);
            border: 1px solid var(--border-color);
            border-bottom: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .copy-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-muted);
            padding: 0.3rem 0.8rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all var(--animation-speed);
        }

        .copy-btn:hover {
            background: var(--accent-blue);
            color: var(--primary-bg);
            border-color: var(--accent-blue);
        }

        pre {
            background: var(--code-bg);
            border: 1px solid var(--border-color);
            border-top: none;
            border-bottom-left-radius: var(--border-radius);
            border-bottom-right-radius: var(--border-radius);
            padding: 1.5rem;
            overflow-x: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .code-title + pre {
            border-top-left-radius: 0;
            border-top-right-radius: 0;
        }

        /* Syntax Highlighting */
        .keyword { color: var(--code-keyword); }
        .function { color: var(--code-function); }
        .string { color: var(--code-string); }
        .comment { color: var(--code-comment); }
        .number { color: var(--code-number); }
        .variable { color: var(--code-variable); }

        /* Callouts */
        .callout {
            border-left: 4px solid var(--accent-blue);
            background: rgba(88, 166, 255, 0.1);
            padding: 1.5rem;
            margin: 2rem 0;
            border-radius: 0 var(--border-radius) var(--border-radius) 0;
        }

        .callout-title {
            font-weight: 600;
            color: var(--accent-blue);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.8rem;
        }

        .callout.warning {
            border-left-color: var(--accent-orange);
            background: rgba(247, 129, 102, 0.1);
        }

        .callout.warning .callout-title {
            color: var(--accent-orange);
        }

        .callout.danger {
            border-left-color: var(--accent-red);
            background: rgba(255, 107, 107, 0.1);
        }

        .callout.danger .callout-title {
            color: var(--accent-red);
        }

        .callout.success {
            border-left-color: var(--accent-green);
            background: rgba(63, 185, 80, 0.1);
        }

        .callout.success .callout-title {
            color: var(--accent-green);
        }

        /* Feature Lists */
        .feature-list {
            list-style: none;
            padding-left: 0;
        }

        .feature-list li {
            padding: 0.5rem 0;
            position: relative;
            padding-left: 2rem;
        }

        .feature-list li::before {
            content: '✓';
            position: absolute;
            left: 0;
            color: var(--accent-green);
            font-weight: bold;
        }

        /* Comparison Table */
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 2rem 0;
            background: var(--card-bg);
            border-radius: var(--border-radius);
            overflow: hidden;
            border: 1px solid var(--border-color);
        }

        .comparison-table th,
        .comparison-table td {
            padding: 1rem 1.5rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        .comparison-table th {
            background: var(--secondary-bg);
            font-weight: 600;
            color: var(--text-primary);
        }

        .comparison-table tr:last-child td {
            border-bottom: none;
        }

        .comparison-table tr:hover {
            background: rgba(88, 166, 255, 0.05);
        }

        /* Interactive Demo */
        .interactive-demo {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 2rem;
            margin: 2rem 0;
            box-shadow: var(--shadow);
        }

        .demo-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .demo-output {
            background: var(--code-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            min-height: 200px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            overflow-y: auto;
        }

        /* Benchmark Results */
        .benchmark-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.8rem 0;
            border-bottom: 1px solid var(--border-color);
        }

        .benchmark-item:last-child {
            border-bottom: none;
        }

        .benchmark-time {
            color: var(--accent-green);
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
        }

        .benchmark-ratio {
            color: var(--accent-blue);
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
        }

        /* Notification */
        .notification {
            position: fixed;
            top: 100px;
            right: 20px;
            background: var(--accent-green);
            color: var(--primary-bg);
            padding: 1rem 1.5rem;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
            z-index: 1000;
            opacity: 0;
            transform: translateX(100%);
            transition: all var(--animation-speed);
            font-weight: 600;
        }

        .notification.show {
            opacity: 1;
            transform: translateX(0);
        }

        .notification.error {
            background: var(--accent-red);
        }

        .notification.warning {
            background: var(--accent-orange);
        }

        /* Animations */
        .fade-in {
            animation: fadeIn 0.6s ease-in-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 0 1rem;
            }

            .nav-links {
                display: none;
            }

            .memory-container {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .hero h1 {
                font-size: 2rem;
            }

            .hero p {
                font-size: 1rem;
            }

            .card {
                padding: 1.5rem;
            }

            .demo-controls {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }
        }

        @media (max-width: 480px) {
            .hero {
                padding: 2rem 0;
            }

            .hero h1 {
                font-size: 1.8rem;
            }

            .card {
                padding: 1rem;
            }

            .memory-visual {
                height: 200px;
            }

            .comparison-table th,
            .comparison-table td {
                padding: 0.8rem;
                font-size: 0.9rem;
            }
        }

        /* Focus States for Accessibility */
        .btn:focus,
        button:focus {
            outline: 2px solid var(--accent-blue);
            outline-offset: 2px;
        }

        /* Section Spacing */
        section {
            margin: 3rem 0;
        }

        section h2 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 2rem;
            color: var(--text-primary);
        }

        /* Code Explanation Styles */
        .code-explanation {
            background: linear-gradient(135deg, var(--card-bg), rgba(88, 166, 255, 0.05));
            border: 1px solid rgba(88, 166, 255, 0.2);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            margin-top: 1rem;
            transition: all var(--animation-speed);
        }

        .code-explanation:hover {
            border-color: rgba(88, 166, 255, 0.4);
            box-shadow: 0 4px 20px rgba(88, 166, 255, 0.1);
            transform: translateY(-2px);
        }

        .explanation-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
            cursor: pointer;
        }

        .explanation-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            color: var(--accent-blue);
            font-size: 1.1rem;
        }

        .explanation-toggle {
            background: var(--accent-blue);
            color: var(--primary-bg);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--animation-speed);
        }

        .explanation-toggle:hover {
            background: #4a9fff;
            transform: scale(1.05);
        }

        .explanation-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease;
        }

        .explanation-content.expanded {
            max-height: 1000px;
        }

        .explanation-section {
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 8px;
            border-left: 3px solid var(--accent-green);
        }

        .explanation-section:last-child {
            margin-bottom: 0;
        }

        .explanation-section h4 {
            color: var(--accent-green);
            margin-bottom: 0.8rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1rem;
        }

        .line-by-line {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .code-line {
            display: flex;
            margin-bottom: 0.8rem;
            padding: 0.5rem;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .code-line:hover {
            background: rgba(88, 166, 255, 0.1);
        }

        .line-number {
            color: var(--text-muted);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            min-width: 2rem;
            margin-right: 1rem;
        }

        .line-code {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            color: var(--text-secondary);
            flex: 1;
        }

        .line-explanation {
            color: var(--text-muted);
            font-size: 0.85rem;
            margin-left: 1rem;
            font-style: italic;
            border-left: 2px solid var(--accent-orange);
            padding-left: 0.8rem;
        }

        .memory-impact {
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.1), rgba(255, 107, 107, 0.05));
            border: 1px solid rgba(255, 107, 107, 0.3);
            border-radius: 6px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .memory-impact h5 {
            color: var(--accent-red);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .best-practices {
            background: linear-gradient(135deg, rgba(59, 185, 80, 0.1), rgba(59, 185, 80, 0.05));
            border: 1px solid rgba(59, 185, 80, 0.3);
            border-radius: 6px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .best-practices h5 {
            color: var(--accent-green);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .best-practices ul {
            margin-left: 1rem;
        }

        .performance-note {
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.1), rgba(168, 85, 247, 0.05));
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 6px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .performance-note h5 {
            color: var(--accent-purple);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
    </style>
</head>
<body>
    <!-- Progress Bar -->
    <div class="progress-container">
        <div class="progress-bar" id="progressBar"></div>
    </div>
    
    <!-- Navigation -->
    <nav>
        <div class="container nav-container">
            <div class="nav-logo">
                <span>Rover</span> | Stack vs Heap Memory
            </div>
            <ul class="nav-links">
                <li><a href="#overview" class="active">Overview</a></li>
                <li><a href="#stack">Stack</a></li>
                <li><a href="#heap">Heap</a></li>
                <li><a href="#comparison">Comparison</a></li>
                <li><a href="#demo">Interactive Demo</a></li>
                <li><a href="#best-practices">Best Practices</a></li>
            </ul>
        </div>
    </nav>

    <main class="container">
        <!-- Hero Section -->
        <section class="hero">
            <h1>Stack vs Heap Memory</h1>
            <p>Master the fundamental concepts of memory management in programming. Understand the critical differences between stack and heap memory allocation, their performance characteristics, and when to use each approach.</p>
        </section>

        <!-- Overview Section -->
        <section id="overview">
            <h2>🧠 Memory Management Overview</h2>
            
            <div class="card">
                <div class="card-header">
                    <div class="icon">🎯</div>
                    <h3>Understanding Memory Types</h3>
                </div>
                <p>Memory management is one of the most critical aspects of programming. The way your program stores and accesses data can dramatically impact performance, stability, and resource utilization. In most programming languages, memory is divided into two primary regions: the stack and the heap.</p>
                <p>Each memory type serves distinct purposes and has unique characteristics that make them suitable for different scenarios. Understanding these differences is essential for writing efficient, robust applications.</p>
            </div>

            <div class="callout">
                <div class="callout-title">💡 Key Insight</div>
                <p>The choice between stack and heap allocation isn't just about performance—it's about the lifetime, scope, and size of your data. Stack memory is fast but limited, while heap memory is flexible but requires careful management.</p>
            </div>
        </section>

        <!-- Interactive Memory Visualization -->
        <section id="visualization">
            <h2>📊 Memory Layout Visualization</h2>
            
            <div class="memory-container">
                <div class="memory-section stack">
                    <div class="memory-title">Stack Memory</div>
                    <div class="memory-visual" id="stackVisual">
                        <div class="memory-block stack-block" style="bottom: 10px;">main() frame</div>
                        <div class="memory-block stack-block" style="bottom: 50px;">function1() frame</div>
                        <div class="memory-block stack-block" style="bottom: 90px;">function2() frame</div>
                    </div>
                    <div class="controls">
                        <button class="btn green" onclick="pushToStack()">Push Frame</button>
                        <button class="btn red" onclick="popFromStack()">Pop Frame</button>
                    </div>
                </div>

                <div class="memory-section heap">
                    <div class="memory-title">Heap Memory</div>
                    <div class="memory-visual" id="heapVisual">
                        <div class="memory-block heap-block" style="top: 20px; left: 20px; width: 80px; height: 40px;">Object A</div>
                        <div class="memory-block heap-block" style="top: 80px; left: 120px; width: 60px; height: 30px;">Array B</div>
                        <div class="memory-block heap-block" style="top: 140px; left: 30px; width: 100px; height: 50px;">Large Data</div>
                    </div>
                    <div class="controls">
                        <button class="btn orange" onclick="allocateHeap()">Allocate Object</button>
                        <button class="btn red" onclick="deallocateHeap()">Deallocate</button>
                    </div>
                </div>
            </div>
        </section>

        <!-- Stack Memory Section -->
        <section id="stack">
            <h2>📚 Stack Memory</h2>
            
            <div class="card">
                <div class="card-header">
                    <div class="icon">⚡</div>
                    <h3>The Speed Champion</h3>
                </div>
                <p>Stack memory is a region of RAM that stores temporary variables created by each function. It's called a "stack" because it follows the Last In, First Out (LIFO) principle—like a stack of plates where you can only add or remove plates from the top.</p>
                
                <div class="callout">
                    <div class="callout-title">🔄 LIFO Principle</div>
                    <p>When a function is called, its variables are pushed onto the stack. When the function exits, all its variables are automatically popped off, freeing the memory instantly.</p>
                </div>
            </div>

            <div class="card">
                <h3>Key Characteristics</h3>
                <ul class="feature-list">
                    <li><strong>Automatic Management:</strong> Memory is automatically allocated and deallocated</li>
                    <li><strong>Extremely Fast:</strong> Simple pointer arithmetic for allocation/deallocation</li>
                    <li><strong>Limited Size:</strong> Typically 1-8 MB depending on the system</li>
                    <li><strong>Local Scope:</strong> Variables exist only within their function's scope</li>
                    <li><strong>Thread-Safe:</strong> Each thread has its own stack</li>
                </ul>
            </div>

            <div class="card">
                <h3>Stack Memory in Action</h3>
                <div class="code-container">
                    <div class="code-title">
                        C++ Stack Example
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="keyword">void</span> <span class="function">function1</span>() {
    <span class="keyword">int</span> <span class="variable">a</span> = <span class="number">10</span>;      <span class="comment">// Allocated on stack</span>
    <span class="keyword">char</span> <span class="variable">array</span>[<span class="number">100</span>];  <span class="comment">// Also on stack</span>
    
    <span class="function">function2</span>();       <span class="comment">// New stack frame created</span>
}                         <span class="comment">// Stack frame destroyed, memory freed</span>

<span class="keyword">void</span> <span class="function">function2</span>() {
    <span class="keyword">double</span> <span class="variable">b</span> = <span class="number">3.14</span>;   <span class="comment">// On top of stack</span>
    <span class="comment">// When function2 ends, 'b' is automatically freed</span>
}</code></pre>
                </div>

                <!-- Interactive Code Explanation -->
                <div class="code-explanation">
                    <div class="explanation-header" onclick="toggleExplanation(this)">
                        <div class="explanation-title">
                            🔍 <span>Detailed Code Breakdown</span>
                        </div>
                        <button class="explanation-toggle">Show Details</button>
                    </div>
                    <div class="explanation-content">
                        <div class="explanation-section">
                            <h4>📋 Line-by-Line Analysis</h4>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">1</span>
                                    <span class="line-code">void function1() {</span>
                                    <span class="line-explanation">Function declaration creates new scope, preparing stack frame</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">2</span>
                                    <span class="line-code">    int a = 10;</span>
                                    <span class="line-explanation">4 bytes allocated on stack, stored in CPU register or stack slot</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">3</span>
                                    <span class="line-code">    char array[100];</span>
                                    <span class="line-explanation">100 bytes reserved on stack (contiguous memory block)</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">4</span>
                                    <span class="line-code">    function2();</span>
                                    <span class="line-explanation">New stack frame pushed on top, return address saved</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">5</span>
                                    <span class="line-code">}</span>
                                    <span class="line-explanation">Stack frame popped, all local variables automatically destroyed</span>
                                </div>
                            </div>
                        </div>

                        <div class="memory-impact">
                            <h5>🧠 Memory Impact Analysis</h5>
                            <p><strong>Stack Frame Size:</strong> ~104 bytes (4 + 100 bytes for variables + overhead)</p>
                            <p><strong>Allocation Time:</strong> ~1 CPU cycle (just moving stack pointer)</p>
                            <p><strong>Deallocation Time:</strong> ~1 CPU cycle (resetting stack pointer)</p>
                            <p><strong>Memory Layout:</strong> Variables stored contiguously in LIFO order</p>
                        </div>

                        <div class="explanation-section">
                            <h4>🔄 Execution Flow Visualization</h4>
                            <p><strong>Step 1:</strong> Program calls function1() → Stack pointer moves down to create new frame</p>
                            <p><strong>Step 2:</strong> Variable 'a' allocated → 4 bytes reserved at current stack position</p>
                            <p><strong>Step 3:</strong> Array allocated → 100 bytes reserved sequentially after 'a'</p>
                            <p><strong>Step 4:</strong> function2() called → New frame created on top, 'b' allocated</p>
                            <p><strong>Step 5:</strong> function2() returns → Its frame destroyed, 'b' gone</p>
                            <p><strong>Step 6:</strong> function1() returns → Its frame destroyed, 'a' and 'array' gone</p>
                        </div>

                        <div class="best-practices">
                            <h5>✅ Best Practices</h5>
                            <ul>
                                <li>Keep stack allocations small (< 1MB) to avoid stack overflow</li>
                                <li>Prefer stack allocation for small, short-lived objects</li>
                                <li>Use const for read-only stack variables when possible</li>
                                <li>Be careful with large arrays - consider dynamic allocation instead</li>
                                <li>Understand your platform's stack size limits</li>
                            </ul>
                        </div>

                        <div class="performance-note">
                            <h5>⚡ Performance Insights</h5>
                            <p><strong>Why It's Fast:</strong> Stack allocation is just arithmetic - moving a pointer up or down. No searching for free space, no fragmentation concerns.</p>
                            <p><strong>Cache Friendliness:</strong> Stack variables have excellent spatial locality, making them very cache-friendly.</p>
                            <p><strong>Automatic Cleanup:</strong> Zero overhead for deallocation - happens automatically when scope ends.</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="callout warning">
                <div class="callout-title">⚠️ Stack Overflow Warning</div>
                <p>Allocating too much memory on the stack (large arrays, deep recursion) can cause a stack overflow, crashing your program. Be mindful of stack size limitations.</p>
            </div>
        </section>

        <!-- Heap Memory Section -->
        <section id="heap">
            <h2>🏗️ Heap Memory</h2>
            
            <div class="card">
                <div class="card-header">
                    <div class="icon">🌟</div>
                    <h3>The Flexible Giant</h3>
                </div>
                <p>Heap memory is a region of RAM used for dynamic memory allocation. Unlike the stack, heap memory must be explicitly managed by the programmer (in languages like C/C++) or by a garbage collector (in languages like Java, Python).</p>
                
                <div class="callout">
                    <div class="callout-title">🎯 Dynamic Allocation</div>
                    <p>Heap memory allows you to allocate memory at runtime, making it perfect for data structures whose size isn't known at compile time.</p>
                </div>
            </div>

            <div class="card">
                <h3>Key Characteristics</h3>
                <ul class="feature-list">
                    <li><strong>Manual Management:</strong> Must explicitly allocate and free memory</li>
                    <li><strong>Large Size:</strong> Limited only by available system RAM</li>
                    <li><strong>Slower Access:</strong> Requires pointer dereferencing and memory management</li>
                    <li><strong>Global Access:</strong> Can be accessed from anywhere in the program</li>
                    <li><strong>Fragmentation:</strong> Can become fragmented over time</li>
                    <li><strong>Memory Leaks:</strong> Risk of memory leaks if not properly managed</li>
                </ul>
            </div>

            <div class="card">
                <h3>Heap Memory Management</h3>
                <div class="code-container">
                    <div class="code-title">
                        C++ Heap Example
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="keyword">void</span> <span class="function">heapExample</span>() {
    <span class="comment">// Allocate memory on heap</span>
    <span class="keyword">int</span>* <span class="variable">ptr</span> = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>);
    <span class="keyword">int</span>* <span class="variable">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000</span>];
    
    <span class="comment">// Use the allocated memory</span>
    *<span class="variable">ptr</span> = <span class="number">100</span>;
    <span class="variable">array</span>[<span class="number">0</span>] = <span class="number">50</span>;
    
    <span class="comment">// MUST free the memory to avoid leaks</span>
    <span class="keyword">delete</span> <span class="variable">ptr</span>;
    <span class="keyword">delete</span>[] <span class="variable">array</span>;
}</code></pre>
                </div>

                <div class="code-container">
                    <div class="code-title">
                        Modern C++ Smart Pointers
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="keyword">#include</span> <span class="string">&lt;memory&gt;</span>

<span class="keyword">void</span> <span class="function">modernHeapExample</span>() {
    <span class="comment">// Automatic memory management with smart pointers</span>
    <span class="keyword">auto</span> <span class="variable">ptr</span> = <span class="function">std::make_unique</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);
    <span class="keyword">auto</span> <span class="variable">shared</span> = <span class="function">std::make_shared</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">100</span>);
    
    <span class="comment">// Memory automatically freed when ptr goes out of scope</span>
}</code></pre>
                </div>

                <!-- Interactive Heap Code Explanation -->
                <div class="code-explanation">
                    <div class="explanation-header" onclick="toggleExplanation(this)">
                        <div class="explanation-title">
                            🔍 <span>Heap Memory Deep Dive</span>
                        </div>
                        <button class="explanation-toggle">Show Details</button>
                    </div>
                    <div class="explanation-content">
                        <div class="explanation-section">
                            <h4>📋 Raw Pointer Analysis (First Example)</h4>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">2</span>
                                    <span class="line-code">int* ptr = new int(42);</span>
                                    <span class="line-explanation">OS allocates 4 bytes on heap, returns memory address</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">3</span>
                                    <span class="line-code">int* array = new int[1000];</span>
                                    <span class="line-explanation">Allocates 4000 bytes (1000 × 4) contiguous block on heap</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">6</span>
                                    <span class="line-code">*ptr = 100;</span>
                                    <span class="line-explanation">Dereferences pointer to write value to heap memory</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">10</span>
                                    <span class="line-code">delete ptr;</span>
                                    <span class="line-explanation">Returns single object memory to heap manager</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">11</span>
                                    <span class="line-code">delete[] array;</span>
                                    <span class="line-explanation">Returns array memory to heap manager (special array delete)</span>
                                </div>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>🏗️ Heap Allocation Process</h4>
                            <p><strong>Step 1:</strong> Program requests memory from heap manager</p>
                            <p><strong>Step 2:</strong> Heap manager searches free list for suitable block</p>
                            <p><strong>Step 3:</strong> If found, mark block as used and return address</p>
                            <p><strong>Step 4:</strong> If not found, request more memory from OS</p>
                            <p><strong>Step 5:</strong> Return pointer to allocated memory or null if failed</p>
                        </div>

                        <div class="memory-impact">
                            <h5>🧠 Memory Impact Comparison</h5>
                            <p><strong>Raw Allocation:</strong> 4004 bytes + heap metadata (~16-32 bytes overhead)</p>
                            <p><strong>Allocation Time:</strong> 50-200 CPU cycles (searching free blocks)</p>
                            <p><strong>Deallocation Time:</strong> 30-100 CPU cycles (updating free lists)</p>
                            <p><strong>Memory Overhead:</strong> ~8-16 bytes per allocation for bookkeeping</p>
                            <p><strong>Fragmentation Risk:</strong> High with frequent alloc/dealloc patterns</p>
                        </div>

                        <div class="explanation-section">
                            <h4>🤖 Smart Pointer Analysis (Second Example)</h4>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">3</span>
                                    <span class="line-code">auto ptr = std::make_unique&lt;int&gt;(42);</span>
                                    <span class="line-explanation">Creates unique_ptr wrapper, automatic cleanup on scope exit</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">4</span>
                                    <span class="line-code">auto shared = std::make_shared&lt;int&gt;(100);</span>
                                    <span class="line-explanation">Creates shared_ptr with reference counting for shared ownership</span>
                                </div>
                            </div>
                        </div>

                        <div class="best-practices">
                            <h5>✅ Heap Management Best Practices</h5>
                            <ul>
                                <li><strong>Prefer Smart Pointers:</strong> Use unique_ptr/shared_ptr over raw pointers</li>
                                <li><strong>RAII Pattern:</strong> Tie memory lifetime to object lifetime</li>
                                <li><strong>Avoid Fragmentation:</strong> Use memory pools for frequent same-size allocations</li>
                                <li><strong>Early Return:</strong> Use guard clauses to prevent memory leaks in error paths</li>
                                <li><strong>Memory Debugging:</strong> Use tools like Valgrind or AddressSanitizer</li>
                            </ul>
                        </div>

                        <div class="performance-note">
                            <h5>⚡ Performance Considerations</h5>
                            <p><strong>Allocation Cost:</strong> 10-100x slower than stack due to heap manager overhead</p>
                            <p><strong>Cache Performance:</strong> Heap allocations may be scattered, reducing cache efficiency</p>
                            <p><strong>Shared_ptr Overhead:</strong> Reference counting adds atomic operations cost</p>
                            <p><strong>Unique_ptr Advantage:</strong> Zero runtime overhead compared to raw pointers</p>
                        </div>

                        <div class="memory-impact">
                            <h5>🔍 Common Heap Issues</h5>
                            <p><strong>Memory Leaks:</strong> Allocated memory never freed, gradually consuming RAM</p>
                            <p><strong>Double Free:</strong> Freeing same memory twice causes undefined behavior</p>
                            <p><strong>Use After Free:</strong> Accessing freed memory leads to crashes or corruption</p>
                            <p><strong>Heap Fragmentation:</strong> Available memory becomes scattered and unusable</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="callout danger">
                <div class="callout-title">💀 Memory Leaks</div>
                <p>Every allocation on the heap must have a corresponding deallocation. Forgetting to free memory leads to memory leaks, which can eventually exhaust system resources.</p>
            </div>
        </section>

        <!-- Detailed Comparison Section -->
        <section id="comparison">
            <h2>⚖️ Stack vs Heap Comparison</h2>
            
            <div class="card">
                <h3>Performance & Characteristics</h3>
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>Stack</th>
                            <th>Heap</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Speed</strong></td>
                            <td>⚡ Very Fast (pointer arithmetic)</td>
                            <td>🐌 Slower (pointer dereferencing)</td>
                        </tr>
                        <tr>
                            <td><strong>Size</strong></td>
                            <td>📏 Limited (1-8 MB typically)</td>
                            <td>🌊 Large (system RAM limit)</td>
                        </tr>
                        <tr>
                            <td><strong>Memory Management</strong></td>
                            <td>🤖 Automatic</td>
                            <td>👤 Manual (or garbage collected)</td>
                        </tr>
                        <tr>
                            <td><strong>Access Pattern</strong></td>
                            <td>📚 LIFO (Last In, First Out)</td>
                            <td>🎯 Random Access</td>
                        </tr>
                        <tr>
                            <td><strong>Allocation Time</strong></td>
                            <td>⚡ O(1) - Constant</td>
                            <td>🔍 O(n) - Variable</td>
                        </tr>
                        <tr>
                            <td><strong>Fragmentation</strong></td>
                            <td>❌ No fragmentation</td>
                            <td>📦 Can fragment</td>
                        </tr>
                        <tr>
                            <td><strong>Scope</strong></td>
                            <td>🏠 Local to function</td>
                            <td>🌍 Global access</td>
                        </tr>
                        <tr>
                            <td><strong>Thread Safety</strong></td>
                            <td>✅ Each thread has own stack</td>
                            <td>⚠️ Shared, needs synchronization</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="card">
                <h3>When to Use Each</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-top: 1rem;">
                    <div>
                        <h4 style="color: var(--accent-green); margin-bottom: 1rem;">Use Stack When:</h4>
                        <ul class="feature-list">
                            <li>Data size is known at compile time</li>
                            <li>Small, temporary variables</li>
                            <li>Function parameters and local variables</li>
                            <li>Performance is critical</li>
                            <li>Automatic cleanup is desired</li>
                            <li>Working with primitives (int, char, etc.)</li>
                        </ul>
                    </div>
                    <div>
                        <h4 style="color: var(--accent-orange); margin-bottom: 1rem;">Use Heap When:</h4>
                        <ul class="feature-list">
                            <li>Data size is unknown at compile time</li>
                            <li>Large data structures</li>
                            <li>Data needs to persist beyond function scope</li>
                            <li>Dynamic arrays and objects</li>
                            <li>Shared data between functions/threads</li>
                            <li>Building complex data structures</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <!-- Interactive Demo Section -->
        <section id="demo">
            <h2>🚀 Interactive Memory Demo</h2>
            
            <div class="interactive-demo">
                <h3>Memory Allocation Simulator</h3>
                <p>Experiment with different allocation patterns and see their effects in real-time.</p>
                
                <div class="demo-controls">
                    <button class="btn" onclick="runStackDemo()">Stack Demo</button>
                    <button class="btn orange" onclick="runHeapDemo()">Heap Demo</button>
                    <button class="btn green" onclick="runComparisonDemo()">Performance Test</button>
                    <button class="btn red" onclick="clearDemo()">Clear</button>
                </div>
                
                <div class="demo-output" id="demoOutput">
                    <div style="color: var(--text-muted); text-align: center; padding: 2rem;">
                        Click a demo button to start exploring memory allocation patterns...
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>Performance Benchmark Results</h3>
                <div id="benchmarkResults">
                    <div class="benchmark-item">
                        <span>Stack Allocation (1M operations):</span>
                        <span class="benchmark-time">~0.001ms</span>
                    </div>
                    <div class="benchmark-item">
                        <span>Heap Allocation (1M operations):</span>
                        <span class="benchmark-time">~50ms</span>
                    </div>
                    <div class="benchmark-item">
                        <span>Performance Ratio:</span>
                        <span class="benchmark-ratio">Stack is ~50,000x faster</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- Best Practices Section -->
        <section id="best-practices">
            <h2>✨ Best Practices & Common Pitfalls</h2>
            
            <div class="card">
                <h3>Stack Best Practices</h3>
                <ul class="feature-list">
                    <li><strong>Keep it Small:</strong> Avoid large arrays on the stack</li>
                    <li><strong>Watch Recursion:</strong> Deep recursion can cause stack overflow</li>
                    <li><strong>Prefer Stack:</strong> Use stack allocation when possible for performance</li>
                    <li><strong>Local Variables:</strong> Perfect for function-scoped data</li>
                </ul>
            </div>

            <div class="card">
                <h3>Heap Best Practices</h3>
                <ul class="feature-list">
                    <li><strong>RAII in C++:</strong> Use smart pointers for automatic cleanup</li>
                    <li><strong>Match Allocations:</strong> Every malloc/new needs free/delete</li>
                    <li><strong>Avoid Fragmentation:</strong> Use memory pools for frequent allocations</li>
                    <li><strong>Memory Debugging:</strong> Use tools like Valgrind or AddressSanitizer</li>
                </ul>
            </div>

            <div class="callout warning">
                <div class="callout-title">⚠️ Common Pitfalls</div>
                <ul>
                    <li><strong>Memory Leaks:</strong> Forgetting to free heap memory</li>
                    <li><strong>Double Free:</strong> Freeing the same memory twice</li>
                    <li><strong>Use After Free:</strong> Accessing freed memory</li>
                    <li><strong>Stack Overflow:</strong> Allocating too much on stack</li>
                    <li><strong>Buffer Overruns:</strong> Writing beyond allocated boundaries</li>
                </ul>
            </div>

            <div class="card">
                <h3>Language-Specific Tips</h3>
                <div class="code-container">
                    <div class="code-title">
                        Memory Management by Language
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="comment">// C++: Manual management with RAII</span>
<span class="keyword">auto</span> <span class="variable">ptr</span> = <span class="function">std::make_unique</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);

<span class="comment">// Java: Garbage collection handles heap</span>
<span class="keyword">List</span>&lt;<span class="keyword">Integer</span>&gt; <span class="variable">list</span> = <span class="keyword">new</span> <span class="function">ArrayList</span>&lt;&gt;();

<span class="comment">// Rust: Ownership system prevents leaks</span>
<span class="keyword">let</span> <span class="variable">vec</span> = <span class="function">Vec::new</span>();

<span class="comment">// Python: Garbage collection + reference counting</span>
<span class="variable">my_list</span> = []</code></pre>
                </div>

                <!-- Language-Specific Memory Management Explanation -->
                <div class="code-explanation">
                    <div class="explanation-header" onclick="toggleExplanation(this)">
                        <div class="explanation-title">
                            🔍 <span>Cross-Language Memory Management Analysis</span>
                        </div>
                        <button class="explanation-toggle">Show Details</button>
                    </div>
                    <div class="explanation-content">
                        <div class="explanation-section">
                            <h4>🔧 C++ - Manual Control with RAII</h4>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">C++</span>
                                    <span class="line-code">auto ptr = std::make_unique&lt;int&gt;(42);</span>
                                    <span class="line-explanation">Heap allocation with automatic deallocation via destructor</span>
                                </div>
                            </div>
                            <div class="performance-note">
                                <h5>⚡ C++ Memory Characteristics</h5>
                                <p><strong>Control Level:</strong> Complete manual control over allocation/deallocation</p>
                                <p><strong>Performance:</strong> Zero runtime overhead for memory management</p>
                                <p><strong>Safety:</strong> Compile-time memory safety with smart pointers</p>
                                <p><strong>Predictability:</strong> Deterministic destruction (RAII pattern)</p>
                                <p><strong>Memory Model:</strong> Stack (automatic) + Heap (manual/smart pointers)</p>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>☕ Java - Garbage Collection</h4>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">Java</span>
                                    <span class="line-code">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span>
                                    <span class="line-explanation">Heap allocation, GC handles deallocation automatically</span>
                                </div>
                            </div>
                            <div class="memory-impact">
                                <h5>🗑️ Java GC Characteristics</h5>
                                <p><strong>Control Level:</strong> Automatic memory management via garbage collector</p>
                                <p><strong>Performance:</strong> GC pauses can cause latency spikes</p>
                                <p><strong>Safety:</strong> Complete memory safety, no dangling pointers</p>
                                <p><strong>Predictability:</strong> Non-deterministic cleanup timing</p>
                                <p><strong>Memory Model:</strong> Heap-centric (everything except primitives)</p>
                                <p><strong>GC Algorithms:</strong> G1, ZGC, Parallel GC with different trade-offs</p>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>🦀 Rust - Ownership System</h4>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">Rust</span>
                                    <span class="line-code">let vec = Vec::new();</span>
                                    <span class="line-explanation">Heap allocation with compile-time ownership tracking</span>
                                </div>
                            </div>
                            <div class="best-practices">
                                <h5>🔒 Rust Ownership Characteristics</h5>
                                <ul>
                                    <li><strong>Zero-Cost Abstractions:</strong> Memory safety without runtime overhead</li>
                                    <li><strong>Ownership Rules:</strong> Each value has exactly one owner</li>
                                    <li><strong>Borrowing:</strong> References checked at compile time</li>
                                    <li><strong>Lifetimes:</strong> Compiler ensures no use-after-free</li>
                                    <li><strong>No GC:</strong> Deterministic destruction like C++</li>
                                    <li><strong>Memory Safety:</strong> Impossible to have memory leaks or dangling pointers</li>
                                </ul>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>🐍 Python - Hybrid Approach</h4>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">Python</span>
                                    <span class="line-code">my_list = []</span>
                                    <span class="line-explanation">Creates object on heap, managed by reference counting + GC</span>
                                </div>
                            </div>
                            <div class="memory-impact">
                                <h5>🐍 Python Memory Model</h5>
                                <p><strong>Primary Method:</strong> Reference counting for immediate cleanup</p>
                                <p><strong>Backup Method:</strong> Cycle detection for circular references</p>
                                <p><strong>Performance Cost:</strong> Reference count updates on every assignment</p>
                                <p><strong>Memory Overhead:</strong> Extra space for reference counts</p>
                                <p><strong>Predictability:</strong> Mostly deterministic (ref count), occasional GC pauses</p>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>📊 Performance Comparison</h4>
                            <div class="performance-note">
                                <h5>⏱️ Memory Management Overhead</h5>
                                <table style="width: 100%; color: var(--text-secondary); font-family: 'JetBrains Mono', monospace; font-size: 0.9rem;">
                                    <tr style="border-bottom: 1px solid var(--border-color);">
                                        <td><strong>Language</strong></td>
                                        <td><strong>Allocation Speed</strong></td>
                                        <td><strong>Deallocation</strong></td>
                                        <td><strong>Memory Safety</strong></td>
                                    </tr>
                                    <tr style="border-bottom: 1px solid var(--border-color);">
                                        <td>C++</td>
                                        <td>Very Fast</td>
                                        <td>Immediate</td>
                                        <td>Manual (with tools)</td>
                                    </tr>
                                    <tr style="border-bottom: 1px solid var(--border-color);">
                                        <td>Java</td>
                                        <td>Fast</td>
                                        <td>Delayed (GC)</td>
                                        <td>Automatic</td>
                                    </tr>
                                    <tr style="border-bottom: 1px solid var(--border-color);">
                                        <td>Rust</td>
                                        <td>Very Fast</td>
                                        <td>Immediate</td>
                                        <td>Compile-time</td>
                                    </tr>
                                    <tr>
                                        <td>Python</td>
                                        <td>Slower</td>
                                        <td>Mixed</td>
                                        <td>Automatic</td>
                                    </tr>
                                </table>
                            </div>
                        </div>

                        <div class="best-practices">
                            <h5>🎯 When to Choose Each Language</h5>
                            <ul>
                                <li><strong>C++:</strong> System programming, games, high-performance computing</li>
                                <li><strong>Java:</strong> Enterprise applications, where GC pauses are acceptable</li>
                                <li><strong>Rust:</strong> System programming with safety, WebAssembly, crypto</li>
                                <li><strong>Python:</strong> Rapid prototyping, data science, scripting</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Comprehensive Stack Theory Section -->
        <section id="stack-theory">
            <h2>🏰 The Stack Kingdom - Theoretical Deep Dive</h2>
            
            <div class="callout">
                <div class="callout-title">🧠 Theoretical Foundation</div>
                <p>The stack is not just a memory region - it's a fundamental data structure based on the <strong>LIFO (Last In, First Out)</strong> principle. This principle is mathematically elegant and computationally efficient.</p>
            </div>

            <div class="card">
                <h3>Stack Frame Structure - Theoretical Analysis</h3>
                <p>Each function call creates a theoretical "stack frame" with a specific structure:</p>
                
                <div class="code-container">
                    <div class="code-title">
                        Stack Frame Components
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="comment">// Stack Frame Structure (grows downward)</span>
┌─────────────────────────┐ ← <span class="variable">Stack Top (SP)</span>
│ <span class="keyword">Local Variables</span>      │
├─────────────────────────┤
│ <span class="keyword">Saved Registers</span>     │
├─────────────────────────┤
│ <span class="keyword">Return Address</span>      │
├─────────────────────────┤
│ <span class="keyword">Function Parameters</span> │
└─────────────────────────┘ ← <span class="variable">Frame Pointer (FP)</span>

<span class="comment">// Example: Function call sequence</span>
<span class="keyword">void</span> <span class="function">function_c</span>() {
    <span class="keyword">int</span> <span class="variable">z</span> = <span class="number">30</span>;           <span class="comment">// Local variable on stack</span>
    <span class="function">printf</span>(<span class="string">"%d"</span>, <span class="variable">z</span>);      <span class="comment">// Access local variable</span>
}                           <span class="comment">// Pop from stack (z destroyed)</span>

<span class="keyword">void</span> <span class="function">function_b</span>() {
    <span class="keyword">int</span> <span class="variable">y</span> = <span class="number">20</span>;           <span class="comment">// Creates new stack frame</span>
    <span class="function">function_c</span>();         <span class="comment">// Push new frame</span>
}                           <span class="comment">// Pop frame (y destroyed)</span>

<span class="keyword">void</span> <span class="function">function_a</span>() {
    <span class="keyword">int</span> <span class="variable">x</span> = <span class="number">10</span>;           <span class="comment">// First function frame</span>
    <span class="function">function_b</span>();         <span class="comment">// Call next function</span>
}                           <span class="comment">// Pop frame (x destroyed)</span></code></pre>
                </div>

                <!-- Stack Frame Analysis Explanation -->
                <div class="code-explanation">
                    <div class="explanation-header" onclick="toggleExplanation(this)">
                        <div class="explanation-title">
                            🔍 <span>Stack Frame Architecture Deep Dive</span>
                        </div>
                        <button class="explanation-toggle">Show Details</button>
                    </div>
                    <div class="explanation-content">
                        <div class="explanation-section">
                            <h4>🏗️ Stack Frame Anatomy</h4>
                            <div class="memory-impact">
                                <h5>📐 Frame Structure Layout</h5>
                                <p><strong>Stack Pointer (SP):</strong> Points to top of current frame (most recent data)</p>
                                <p><strong>Frame Pointer (FP):</strong> Points to base of current frame (stable reference)</p>
                                <p><strong>Growth Direction:</strong> Stack grows downward (higher to lower addresses)</p>
                                <p><strong>Frame Size:</strong> Dynamic based on local variables and function calls</p>
                            </div>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">Component</span>
                                    <span class="line-code">Purpose</span>
                                    <span class="line-explanation">Memory Management Role</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Local Variables</span>
                                    <span class="line-code">Function's working data</span>
                                    <span class="line-explanation">Allocated in order of declaration</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Saved Registers</span>
                                    <span class="line-code">CPU state preservation</span>
                                    <span class="line-explanation">Caller's register values saved here</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Return Address</span>
                                    <span class="line-code">Where to continue execution</span>
                                    <span class="line-explanation">Address of instruction after function call</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Parameters</span>
                                    <span class="line-code">Function arguments</span>
                                    <span class="line-explanation">Passed from caller to callee</span>
                                </div>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>🔄 Function Call Execution Flow</h4>
                            <div class="performance-note">
                                <h5>⚡ Step-by-Step Call Process</h5>
                                <p><strong>Step 1 - Prepare Call:</strong> Push parameters onto stack (right to left)</p>
                                <p><strong>Step 2 - Save State:</strong> Push return address and caller's frame pointer</p>
                                <p><strong>Step 3 - Jump:</strong> Transfer control to function entry point</p>
                                <p><strong>Step 4 - Setup Frame:</strong> Allocate space for local variables</p>
                                <p><strong>Step 5 - Execute:</strong> Run function body with access to frame data</p>
                                <p><strong>Step 6 - Cleanup:</strong> Restore caller's frame and stack pointer</p>
                                <p><strong>Step 7 - Return:</strong> Jump back to saved return address</p>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>📊 Frame-by-Frame Analysis</h4>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">function_a()</span>
                                    <span class="line-code">Creates base frame</span>
                                    <span class="line-explanation">SP moves down, allocates space for 'x' variable</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">→ function_b()</span>
                                    <span class="line-code">Pushes new frame</span>
                                    <span class="line-explanation">Return address saved, 'y' allocated on top</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">→ → function_c()</span>
                                    <span class="line-code">Third frame layer</span>
                                    <span class="line-explanation">Another return address, 'z' at stack top</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">← ← function_c() ends</span>
                                    <span class="line-code">Frame popped</span>
                                    <span class="line-explanation">'z' destroyed, SP restored to previous level</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">← function_b() ends</span>
                                    <span class="line-code">Frame popped</span>
                                    <span class="line-explanation">'y' destroyed, control returns to function_a</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">function_a() ends</span>
                                    <span class="line-code">Base frame popped</span>
                                    <span class="line-explanation">'x' destroyed, stack returns to original state</span>
                                </div>
                            </div>
                        </div>

                        <div class="memory-impact">
                            <h5>🧠 Memory Access Patterns</h5>
                            <p><strong>Local Variable Access:</strong> Direct offset from frame pointer (very fast)</p>
                            <p><strong>Parameter Access:</strong> Fixed offset from frame base (predictable)</p>
                            <p><strong>Return Address:</strong> Critical for function call integrity</p>
                            <p><strong>Register Spilling:</strong> When CPU runs out of registers, uses stack</p>
                        </div>

                        <div class="explanation-section">
                            <h4>⚙️ Assembly-Level Implementation</h4>
                            <div class="best-practices">
                                <h5>🔧 CPU Instructions Involved</h5>
                                <ul>
                                    <li><strong>CALL:</strong> Pushes return address, jumps to function</li>
                                    <li><strong>PUSH/POP:</strong> Stack manipulation for data transfer</li>
                                    <li><strong>MOV [EBP+offset]:</strong> Access local variables via frame pointer</li>
                                    <li><strong>SUB ESP, size:</strong> Allocate space for local variables</li>
                                    <li><strong>RET:</strong> Pops return address, jumps back to caller</li>
                                </ul>
                            </div>
                        </div>

                        <div class="performance-note">
                            <h5>⚡ Performance Characteristics</h5>
                            <p><strong>Function Call Overhead:</strong> ~5-20 CPU cycles (depending on complexity)</p>
                            <p><strong>Local Variable Access:</strong> ~1-2 cycles (register or L1 cache)</p>
                            <p><strong>Stack Growth Cost:</strong> ~1 cycle (simple pointer arithmetic)</p>
                            <p><strong>Cache Friendliness:</strong> Excellent - sequential memory access pattern</p>
                        </div>

                        <div class="memory-impact">
                            <h5>🚨 Stack Frame Security Implications</h5>
                            <p><strong>Buffer Overflows:</strong> Can overwrite return addresses</p>
                            <p><strong>Stack Canaries:</strong> Compiler-inserted guards to detect corruption</p>
                            <p><strong>ASLR:</strong> Address Space Layout Randomization prevents prediction</p>
                            <p><strong>NX Bit:</strong> Stack marked non-executable to prevent code injection</p>
                        </div>
                    </div>
                </div>

                <div class="callout success">
                    <div class="callout-title">🎯 Theoretical Invariant</div>
                    <p>At any point during execution, the stack pointer points to the top of the current frame, and the frame pointer points to the base of the current frame.</p>
                </div>
            </div>

            <div class="card">
                <h3>Stack Overflow - Theoretical Analysis</h3>
                <p>Stack overflow occurs when the stack exceeds its allocated size limit. This is a critical concept in system design:</p>
                
                <div class="code-container">
                    <div class="code-title">
                        Stack Overflow Example
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="comment">// Infinite recursion causes stack overflow</span>
<span class="keyword">void</span> <span class="function">infiniteRecursion</span>(<span class="keyword">int</span> <span class="variable">depth</span>) {
    <span class="keyword">int</span> <span class="variable">localArray</span>[<span class="number">1000</span>];    <span class="comment">// 4KB per call</span>
    <span class="function">printf</span>(<span class="string">"Depth: %d\n"</span>, <span class="variable">depth</span>);
    <span class="function">infiniteRecursion</span>(<span class="variable">depth</span> + <span class="number">1</span>); <span class="comment">// Stack grows indefinitely</span>
}

<span class="comment">// With typical 8MB stack:</span>
<span class="comment">// - Each call uses ~4KB</span>
<span class="comment">// - Maximum ~2000 recursive calls</span>
<span class="comment">// - Then: SEGMENTATION FAULT</span></code></pre>
                </div>

                <div class="callout warning">
                    <div class="callout-title">⚠️ Stack Size Limits</div>
                    <p>Typical stack sizes: Linux (8MB), Windows (1MB), Embedded systems (4-64KB). Design your recursion depth accordingly!</p>
                </div>
            </div>
        </section>

        <!-- Comprehensive Heap Theory Section -->
        <section id="heap-theory">
            <h2>🏔️ The Heap Kingdom - Theoretical Deep Dive</h2>
            
            <div class="callout">
                <div class="callout-title">🌟 Dynamic Allocation Theory</div>
                <p>The heap provides flexible, on-demand allocation using sophisticated algorithms like malloc/free, garbage collection, and memory pool management.</p>
            </div>

            <div class="card">
                <h3>Heap Allocation Strategies</h3>
                
                <div class="code-container">
                    <div class="code-title">
                        Malloc Implementation Theory
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="comment">// Theoretical malloc() process:</span>
<span class="keyword">void</span>* <span class="function">malloc</span>(<span class="keyword">size_t</span> <span class="variable">size</span>) {
    <span class="comment">// 1. Add metadata size (typically 16-24 bytes)</span>
    <span class="keyword">size_t</span> <span class="variable">total_size</span> = <span class="variable">size</span> + <span class="function">sizeof</span>(<span class="variable">metadata</span>);
    
    <span class="comment">// 2. Search free list for suitable block</span>
    <span class="keyword">block_t</span>* <span class="variable">block</span> = <span class="function">find_free_block</span>(<span class="variable">total_size</span>);
    
    <span class="comment">// 3. If no block found, request from OS</span>
    <span class="keyword">if</span> (!<span class="variable">block</span>) {
        <span class="variable">block</span> = <span class="function">sbrk</span>(<span class="variable">total_size</span>); <span class="comment">// Extend heap</span>
    }
    
    <span class="comment">// 4. Mark block as allocated</span>
    <span class="variable">block</span>-><span class="variable">is_free</span> = <span class="number">0</span>;
    <span class="variable">block</span>-><span class="variable">size</span> = <span class="variable">size</span>;
    
    <span class="comment">// 5. Return pointer to user data area</span>
    <span class="keyword">return</span> (<span class="keyword">void</span>*)(<span class="variable">block</span> + <span class="number">1</span>);
}

<span class="comment">// Allocation strategies:</span>
<span class="comment">// First Fit: Use first block that's large enough</span>
<span class="comment">// Best Fit: Use smallest block that fits (minimizes waste)</span>
<span class="comment">// Worst Fit: Use largest available block</span></code></pre>
                </div>

                <h4>Memory Fragmentation Analysis</h4>
                <div class="callout warning">
                    <div class="callout-title">📦 Fragmentation Problem</div>
                    <p><strong>External Fragmentation:</strong> Free memory exists but is scattered in small, unusable chunks.<br>
                    <strong>Internal Fragmentation:</strong> Allocated blocks are larger than requested, wasting space.</p>
                </div>

                <div class="code-container">
                    <div class="code-title">
                        Fragmentation Example
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="comment">// Memory layout after several alloc/free operations</span>
<span class="comment">// [A=allocated, F=free, numbers show sizes]</span>

<span class="comment">Initial:</span> [<span class="variable">F:1000</span>]
<span class="function">malloc</span>(<span class="number">100</span>): [<span class="keyword">A:100</span>][<span class="variable">F:900</span>]
<span class="function">malloc</span>(<span class="number">200</span>): [<span class="keyword">A:100</span>][<span class="keyword">A:200</span>][<span class="variable">F:700</span>]
<span class="function">malloc</span>(<span class="number">150</span>): [<span class="keyword">A:100</span>][<span class="keyword">A:200</span>][<span class="keyword">A:150</span>][<span class="variable">F:550</span>]
<span class="function">free</span>(<span class="variable">ptr2</span>):   [<span class="keyword">A:100</span>][<span class="variable">F:200</span>][<span class="keyword">A:150</span>][<span class="variable">F:550</span>]

<span class="comment">// Now malloc(300) fails despite 750 bytes free!</span>
<span class="comment">// Largest contiguous block is only 550 bytes</span></code></pre>
                </div>
            </div>

            <div class="card">
                <h3>Modern Memory Management</h3>
                
                <div class="code-container">
                    <div class="code-title">
                        Smart Pointers - RAII Pattern
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="keyword">#include</span> <span class="string">&lt;memory&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;vector&gt;</span>

<span class="comment">// RAII: Resource Acquisition Is Initialization</span>
<span class="keyword">class</span> <span class="function">ModernMemoryExample</span> {
<span class="keyword">public</span>:
    <span class="keyword">void</span> <span class="function">demonstrateSmartPointers</span>() {
        <span class="comment">// unique_ptr: Single ownership</span>
        <span class="keyword">auto</span> <span class="variable">unique</span> = <span class="function">std::make_unique</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);
        
        <span class="comment">// shared_ptr: Shared ownership with reference counting</span>
        <span class="keyword">auto</span> <span class="variable">shared1</span> = <span class="function">std::make_shared</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">100</span>);
        <span class="keyword">auto</span> <span class="variable">shared2</span> = <span class="variable">shared1</span>; <span class="comment">// Reference count = 2</span>
        
        <span class="comment">// weak_ptr: Non-owning reference (breaks cycles)</span>
        <span class="keyword">std::weak_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="variable">weak</span> = <span class="variable">shared1</span>;
        
        <span class="comment">// Container with automatic memory management</span>
        <span class="keyword">std::vector</span>&lt;<span class="keyword">int</span>&gt; <span class="variable">vec</span> = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};
        <span class="variable">vec</span>.<span class="function">push_back</span>(<span class="number">6</span>); <span class="comment">// Automatic reallocation if needed</span>
        
        <span class="comment">// All memory automatically freed when objects go out of scope!</span>
    }
};</code></pre>
                </div>
            </div>
        </section>

        <!-- Memory Layout Architecture -->
        <section id="memory-architecture">
            <h2>🏗️ Complete Memory Layout - System Architecture</h2>
            
            <div class="card">
                <h3>Virtual Memory Space Layout</h3>
                <p>Understanding how the operating system organizes process memory:</p>
                
                <div class="code-container">
                    <div class="code-title">
                        Linux Memory Layout (64-bit)
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="comment">// Virtual Address Space Layout (High to Low)</span>

<span class="comment">// 0xFFFFFFFFFFFFFFFF</span> ┌─────────────────────┐
<span class="comment">//                      │ Kernel Space        │ ← OS kernel lives here</span>
<span class="comment">//                      │ (Privileged)        │</span>
<span class="comment">// 0xFFFF800000000000</span> ├─────────────────────┤
<span class="comment">//                      │ User Space          │</span>
<span class="comment">//                      │                     │</span>
<span class="comment">// 0x7FFFFFFFFFFF</span>    ├─────────────────────┤
<span class="comment">//                      │ Stack               │ ← Grows downward</span>
<span class="comment">//                      │ (8MB default)       │   Function calls,</span>
<span class="comment">//                      │ ↓↓↓                 │   local variables</span>
<span class="comment">//                      ├─────────────────────┤</span>
<span class="comment">//                      │ Memory Mapped Files │ ← mmap(), shared libs</span>
<span class="comment">//                      │ Shared Libraries    │</span>
<span class="comment">//                      ├─────────────────────┤</span>
<span class="comment">//                      │ ↑↑↑                 │</span>
<span class="comment">//                      │ Heap                │ ← Grows upward</span>
<span class="comment">//                      │ (Dynamic allocation)│   malloc(), new</span>
<span class="comment">//                      ├─────────────────────┤</span>
<span class="comment">//                      │ BSS Segment         │ ← Uninitialized data</span>
<span class="comment">//                      │ (Zero-initialized)  │</span>
<span class="comment">//                      ├─────────────────────┤</span>
<span class="comment">//                      │ Data Segment        │ ← Initialized globals</span>
<span class="comment">//                      │ (Global variables)  │   and static variables</span>
<span class="comment">//                      ├─────────────────────┤</span>
<span class="comment">//                      │ Text Segment        │ ← Program code</span>
<span class="comment">//                      │ (Code)              │   (Read-only)</span>
<span class="comment">// 0x400000</span>          └─────────────────────┘</code></pre>
                </div>

                <div class="callout">
                    <div class="callout-title">🎯 Key Memory Regions</div>
                    <ul>
                        <li><strong>Text Segment:</strong> Contains executable code (read-only)</li>
                        <li><strong>Data Segment:</strong> Initialized global and static variables</li>
                        <li><strong>BSS Segment:</strong> Uninitialized global variables (zero-filled)</li>
                        <li><strong>Heap:</strong> Dynamic memory allocation (grows upward)</li>
                        <li><strong>Stack:</strong> Function calls and local variables (grows downward)</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Data Structures in Memory -->
        <section id="data-structures-memory">
            <h2>📊 How Data Structures Live in Memory</h2>
            
            <div class="card">
                <h3>Arrays vs Linked Lists - Memory Analysis</h3>
                
                <div class="code-container">
                    <div class="code-title">
                        Array Memory Layout
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="comment">// Array: Contiguous memory layout</span>
<span class="keyword">int</span> <span class="variable">array</span>[<span class="number">5</span>] = {<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>};

<span class="comment">// Memory layout (assuming 4-byte integers):</span>
<span class="comment">// Address:  0x1000    0x1004    0x1008    0x100C    0x1010</span>
<span class="comment">// Value:    [  10  ]  [  20  ]  [  30  ]  [  40  ]  [  50  ]</span>
<span class="comment">//           array[0]  array[1]  array[2]  array[3]  array[4]</span>

<span class="comment">// Cache-friendly: Sequential access loads entire cache line</span>
<span class="keyword">for</span>(<span class="keyword">int</span> <span class="variable">i</span> = <span class="number">0</span>; <span class="variable">i</span> &lt; <span class="number">5</span>; <span class="variable">i</span>++) {
    <span class="function">printf</span>(<span class="string">"%d "</span>, <span class="variable">array</span>[<span class="variable">i</span>]); <span class="comment">// Fast access!</span>
}</code></pre>
                </div>

                <div class="code-container">
                    <div class="code-title">
                        Linked List Memory Layout
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="comment">// Linked List: Scattered memory layout</span>
<span class="keyword">struct</span> <span class="function">Node</span> {
    <span class="keyword">int</span> <span class="variable">data</span>;
    <span class="keyword">struct</span> <span class="function">Node</span>* <span class="variable">next</span>;
};

<span class="comment">// Memory layout (scattered across heap):</span>
<span class="comment">// Node 1:   0x2000 [data: 10][next: 0x3500]</span>
<span class="comment">// Node 2:   0x3500 [data: 20][next: 0x1800]  ← Non-contiguous!</span>
<span class="comment">// Node 3:   0x1800 [data: 30][next: NULL ]</span>

<span class="comment">// Cache-unfriendly: Each access may cause cache miss</span>
<span class="keyword">struct</span> <span class="function">Node</span>* <span class="variable">current</span> = <span class="variable">head</span>;
<span class="keyword">while</span>(<span class="variable">current</span> != <span class="variable">NULL</span>) {
    <span class="function">printf</span>(<span class="string">"%d "</span>, <span class="variable">current</span>-><span class="variable">data</span>); <span class="comment">// Potentially slow</span>
    <span class="variable">current</span> = <span class="variable">current</span>-><span class="variable">next</span>;   <span class="comment">// Pointer chase</span>
}</code></pre>
                </div>

                <!-- Array vs Linked List Memory Analysis -->
                <div class="code-explanation">
                    <div class="explanation-header" onclick="toggleExplanation(this)">
                        <div class="explanation-title">
                            🔍 <span>Data Structure Memory Patterns Analysis</span>
                        </div>
                        <button class="explanation-toggle">Show Details</button>
                    </div>
                    <div class="explanation-content">
                        <div class="explanation-section">
                            <h4>📊 Array Memory Layout Deep Dive</h4>
                            <div class="memory-impact">
                                <h5>🧠 Contiguous Memory Benefits</h5>
                                <p><strong>Memory Addresses:</strong> Sequential addresses with predictable offsets</p>
                                <p><strong>Cache Line Efficiency:</strong> Single 64-byte cache line holds 16 integers</p>
                                <p><strong>Prefetching:</strong> CPU automatically loads next cache lines</p>
                                <p><strong>Random Access:</strong> O(1) with simple arithmetic: address = base + (index × size)</p>
                            </div>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">Address</span>
                                    <span class="line-code">Memory State</span>
                                    <span class="line-explanation">Cache Impact</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">0x1000</span>
                                    <span class="line-code">array[0] = 10</span>
                                    <span class="line-explanation">First access loads entire cache line (0x1000-0x103F)</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">0x1004</span>
                                    <span class="line-code">array[1] = 20</span>
                                    <span class="line-explanation">Already in cache - immediate access!</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">0x1008</span>
                                    <span class="line-code">array[2] = 30</span>
                                    <span class="line-explanation">Still in same cache line - fast access</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Loop</span>
                                    <span class="line-code">for(i=0; i&lt;5; i++)</span>
                                    <span class="line-explanation">Perfect sequential access pattern</span>
                                </div>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>🔗 Linked List Memory Reality</h4>
                            <div class="performance-note">
                                <h5>💀 Scattered Memory Problems</h5>
                                <p><strong>Memory Fragmentation:</strong> Nodes allocated wherever heap finds space</p>
                                <p><strong>Pointer Chasing:</strong> Each access requires loading new cache line</p>
                                <p><strong>Cache Misses:</strong> ~90% cache miss rate for random traversals</p>
                                <p><strong>Memory Overhead:</strong> 8 bytes pointer per node (50% overhead for int)</p>
                            </div>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">Step 1</span>
                                    <span class="line-code">Load head at 0x2000</span>
                                    <span class="line-explanation">Cache miss - load 64 bytes around 0x2000</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Step 2</span>
                                    <span class="line-code">Follow next to 0x3500</span>
                                    <span class="line-explanation">Likely cache miss - completely different memory region</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Step 3</span>
                                    <span class="line-code">Follow next to 0x1800</span>
                                    <span class="line-explanation">Another cache miss - unpredictable memory pattern</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Result</span>
                                    <span class="line-code">3 cache misses for 3 nodes</span>
                                    <span class="line-explanation">~300 CPU cycles vs ~3 for array</span>
                                </div>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>⚡ Performance Comparison Analysis</h4>
                            <div class="memory-impact">
                                <h5>📊 Real-World Benchmarks (1000 elements)</h5>
                                <p><strong>Array Sequential Access:</strong> ~0.1ms (perfect cache utilization)</p>
                                <p><strong>Array Random Access:</strong> ~0.3ms (some cache misses)</p>
                                <p><strong>Linked List Traversal:</strong> ~5-15ms (constant cache misses)</p>
                                <p><strong>Memory Usage - Array:</strong> 4000 bytes (pure data)</p>
                                <p><strong>Memory Usage - Linked List:</strong> 12000 bytes (8 bytes overhead per node)</p>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>🎯 When to Use Each Structure</h4>
                            <div class="best-practices">
                                <h5>✅ Arrays Are Better When:</h5>
                                <ul>
                                    <li><strong>Sequential Processing:</strong> Iterating through elements</li>
                                    <li><strong>Random Access:</strong> Need to access arbitrary indices</li>
                                    <li><strong>Cache Performance:</strong> Working with large datasets</li>
                                    <li><strong>SIMD Operations:</strong> Vectorized mathematical operations</li>
                                    <li><strong>Memory Efficiency:</strong> Minimizing memory usage</li>
                                </ul>
                            </div>
                            <div class="performance-note">
                                <h5>🔗 Linked Lists Excel When:</h5>
                                <ul>
                                    <li><strong>Dynamic Size:</strong> Unknown number of elements</li>
                                    <li><strong>Frequent Insertions:</strong> Adding/removing from middle</li>
                                    <li><strong>Memory Constraints:</strong> Can't allocate large contiguous blocks</li>
                                    <li><strong>Sparse Data:</strong> Many empty slots would waste space</li>
                                </ul>
                            </div>
                        </div>

                        <div class="memory-impact">
                            <h5>🔬 Advanced Optimization Techniques</h5>
                            <p><strong>Array Prefetching:</strong> __builtin_prefetch() for manual cache control</p>
                            <p><strong>Pool Allocation:</strong> Allocate linked list nodes from contiguous pool</p>
                            <p><strong>Data Structure Hybrids:</strong> std::deque uses chunks for best of both</p>
                            <p><strong>Cache-Oblivious Algorithms:</strong> Algorithms that work well regardless of cache size</p>
                        </div>

                        <div class="explanation-section">
                            <h4>🧮 Mathematical Analysis</h4>
                            <div class="performance-note">
                                <h5>📐 Algorithm Complexity Reality</h5>
                                <p><strong>Textbook Array Access:</strong> O(1) - constant time</p>
                                <p><strong>Reality Array Access:</strong> O(1) but with 1-3 CPU cycles</p>
                                <p><strong>Textbook List Traversal:</strong> O(n) - linear time</p>
                                <p><strong>Reality List Traversal:</strong> O(n) but with 100-300 cycles per node</p>
                                <p><strong>Crossover Point:</strong> Arrays 50-100x faster for sequential access</p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="callout">
                    <div class="callout-title">⚡ Performance Implications</div>
                    <p><strong>Arrays:</strong> O(1) random access, excellent cache locality<br>
                    <strong>Linked Lists:</strong> O(n) sequential access, poor cache locality but flexible insertion/deletion</p>
                </div>
            </div>

            <div class="card">
                <h3>2D Arrays - Row vs Column Major</h3>
                
                <div class="code-container">
                    <div class="code-title">
                        Memory Layout Comparison
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="comment">// 2D Array: int matrix[3][4]</span>
<span class="keyword">int</span> <span class="variable">matrix</span>[<span class="number">3</span>][<span class="number">4</span>] = {
    {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>},
    {<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>},
    {<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>}
};

<span class="comment">// Row-major layout (C/C++ default):</span>
<span class="comment">// [1][2][3][4][5][6][7][8][9][10][11][12]</span>
<span class="comment">//  ←─ Row 0 ─→ ←─ Row 1 ─→ ←─ Row 2 ──→</span>

<span class="comment">// Cache-friendly: Access by rows</span>
<span class="keyword">for</span>(<span class="keyword">int</span> <span class="variable">i</span> = <span class="number">0</span>; <span class="variable">i</span> &lt; <span class="number">3</span>; <span class="variable">i</span>++) {
    <span class="keyword">for</span>(<span class="keyword">int</span> <span class="variable">j</span> = <span class="number">0</span>; <span class="variable">j</span> &lt; <span class="number">4</span>; <span class="variable">j</span>++) {
        <span class="function">printf</span>(<span class="string">"%d "</span>, <span class="variable">matrix</span>[<span class="variable">i</span>][<span class="variable">j</span>]); <span class="comment">// Sequential access ✓</span>
    }
}

<span class="comment">// Cache-unfriendly: Access by columns</span>
<span class="keyword">for</span>(<span class="keyword">int</span> <span class="variable">j</span> = <span class="number">0</span>; <span class="variable">j</span> &lt; <span class="number">4</span>; <span class="variable">j</span>++) {
    <span class="keyword">for</span>(<span class="keyword">int</span> <span class="variable">i</span> = <span class="number">0</span>; <span class="variable">i</span> &lt; <span class="number">3</span>; <span class="variable">i</span>++) {
        <span class="function">printf</span>(<span class="string">"%d "</span>, <span class="variable">matrix</span>[<span class="variable">i</span>][<span class="variable">j</span>]); <span class="comment">// Stride access ✗</span>
    }
}</code></pre>
                </div>

                <!-- 2D Array Memory Layout Explanation -->
                <div class="code-explanation">
                    <div class="explanation-header" onclick="toggleExplanation(this)">
                        <div class="explanation-title">
                            🔍 <span>2D Array Memory Layout & Cache Optimization</span>
                        </div>
                        <button class="explanation-toggle">Show Details</button>
                    </div>
                    <div class="explanation-content">
                        <div class="explanation-section">
                            <h4>🗄️ Row-Major Memory Layout Deep Dive</h4>
                            <div class="memory-impact">
                                <h5>📐 Physical Memory Organization</h5>
                                <p><strong>Storage Pattern:</strong> Elements stored row by row in contiguous memory</p>
                                <p><strong>Address Calculation:</strong> address(i,j) = base + (i × columns + j) × sizeof(type)</p>
                                <p><strong>Memory Addresses:</strong> matrix[0][0] at 0x1000, matrix[0][1] at 0x1004, etc.</p>
                                <p><strong>Cache Line Usage:</strong> Each 64-byte line holds 16 integers (4×4 elements)</p>
                            </div>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">Element</span>
                                    <span class="line-code">Memory Address</span>
                                    <span class="line-explanation">Cache Line Position</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">[0][0]=1</span>
                                    <span class="line-code">0x1000</span>
                                    <span class="line-explanation">Cache Line 1 (0x1000-0x103F)</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">[0][1]=2</span>
                                    <span class="line-code">0x1004</span>
                                    <span class="line-explanation">Same cache line - immediate access</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">[0][2]=3</span>
                                    <span class="line-code">0x1008</span>
                                    <span class="line-explanation">Same cache line - immediate access</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">[0][3]=4</span>
                                    <span class="line-code">0x100C</span>
                                    <span class="line-explanation">Same cache line - entire row in cache!</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">[1][0]=5</span>
                                    <span class="line-code">0x1010</span>
                                    <span class="line-explanation">Same cache line - prefetch efficiency</span>
                                </div>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>✅ Row-Major Access Pattern Analysis</h4>
                            <div class="best-practices">
                                <h5>🚀 Optimal Access Pattern (i then j)</h5>
                                <p><strong>Access Order:</strong> [0][0] → [0][1] → [0][2] → [0][3] → [1][0] → [1][1]...</p>
                                <p><strong>Memory Pattern:</strong> Sequential addresses, perfect spatial locality</p>
                                <p><strong>Cache Efficiency:</strong> ~95% cache hit rate after initial load</p>
                                <p><strong>CPU Cycles:</strong> ~1-2 cycles per element (mostly cache hits)</p>
                            </div>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">Iteration 1</span>
                                    <span class="line-code">matrix[0][0] access</span>
                                    <span class="line-explanation">Cache miss - loads 64 bytes (16 integers)</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Iteration 2-4</span>
                                    <span class="line-code">matrix[0][1-3] access</span>
                                    <span class="line-explanation">Cache hits - data already loaded</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Iteration 5-8</span>
                                    <span class="line-code">matrix[1][0-3] access</span>
                                    <span class="line-explanation">Likely cache hits - prefetcher loaded next line</span>
                                </div>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>❌ Column-Major Access Pattern Problems</h4>
                            <div class="memory-impact">
                                <h5>💥 Suboptimal Access Pattern (j then i)</h5>
                                <p><strong>Access Order:</strong> [0][0] → [1][0] → [2][0] → [0][1] → [1][1] → [2][1]...</p>
                                <p><strong>Memory Pattern:</strong> Strided access, poor spatial locality</p>
                                <p><strong>Cache Efficiency:</strong> ~30% cache hit rate (wasting cache lines)</p>
                                <p><strong>CPU Cycles:</strong> ~50-200 cycles per element (frequent cache misses)</p>
                            </div>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">Access [0][0]</span>
                                    <span class="line-code">Address 0x1000</span>
                                    <span class="line-explanation">Cache miss - loads 0x1000-0x103F</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Access [1][0]</span>
                                    <span class="line-code">Address 0x1010</span>
                                    <span class="line-explanation">Cache hit - lucky, still in same line</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Access [2][0]</span>
                                    <span class="line-code">Address 0x1020</span>
                                    <span class="line-explanation">Cache hit - still in range</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Access [0][1]</span>
                                    <span class="line-code">Address 0x1004</span>
                                    <span class="line-explanation">Cache hit - back to previous location</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Larger matrices</span>
                                    <span class="line-code">Stride > cache line</span>
                                    <span class="line-explanation">Each access becomes cache miss!</span>
                                </div>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>📊 Performance Impact Analysis</h4>
                            <div class="performance-note">
                                <h5>⏱️ Real-World Benchmarks (1000×1000 matrix)</h5>
                                <p><strong>Row-Major Traversal:</strong> ~2-5ms (excellent cache utilization)</p>
                                <p><strong>Column-Major Traversal:</strong> ~50-200ms (poor cache utilization)</p>
                                <p><strong>Performance Ratio:</strong> Row-major can be 10-100× faster!</p>
                                <p><strong>Cache Misses - Row:</strong> ~0.1% of accesses</p>
                                <p><strong>Cache Misses - Column:</strong> ~90% of accesses</p>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>🛠️ Optimization Strategies</h4>
                            <div class="best-practices">
                                <h5>✅ Cache-Friendly Techniques</h5>
                                <ul>
                                    <li><strong>Block/Tile Algorithms:</strong> Process small rectangular regions</li>
                                    <li><strong>Loop Interchange:</strong> Reorder loops to match memory layout</li>
                                    <li><strong>Array Transposition:</strong> Physically rearrange data for different access patterns</li>
                                    <li><strong>Prefetching:</strong> Manually prefetch next cache lines</li>
                                    <li><strong>SIMD Instructions:</strong> Process multiple elements simultaneously</li>
                                </ul>
                            </div>
                        </div>

                        <div class="memory-impact">
                            <h5>🧮 Mathematical Formula</h5>
                            <p><strong>Row-Major Address:</strong> addr(i,j) = base + (i × cols + j) × sizeof(element)</p>
                            <p><strong>Column-Major Address:</strong> addr(i,j) = base + (j × rows + i) × sizeof(element)</p>
                            <p><strong>Cache Line Utilization:</strong> elements_per_line = cache_line_size / sizeof(element)</p>
                            <p><strong>Stride Size:</strong> Number of elements between consecutive accesses</p>
                        </div>

                        <div class="explanation-section">
                            <h4>🌍 Language Differences</h4>
                            <div class="performance-note">
                                <h5>📚 Row vs Column Major by Language</h5>
                                <p><strong>Row-Major Languages:</strong> C, C++, Python (NumPy), Java</p>
                                <p><strong>Column-Major Languages:</strong> Fortran, MATLAB, R, Julia (default)</p>
                                <p><strong>Configurable:</strong> NumPy (order='C' or 'F'), Julia (column default)</p>
                                <p><strong>Performance Tip:</strong> Know your language's default and optimize accordingly</p>
                            </div>
                        </div>

                        <div class="memory-impact">
                            <h5>🎯 Practical Application</h5>
                            <p><strong>Matrix Multiplication:</strong> Reorder loops for cache-friendly access</p>
                            <p><strong>Image Processing:</strong> Process pixels row-by-row for better performance</p>
                            <p><strong>Scientific Computing:</strong> Choose memory layout based on dominant operations</p>
                            <p><strong>Game Development:</strong> Structure vertex data for optimal GPU access patterns</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Cache Optimization & Advanced Memory Concepts -->
        <section id="cache-optimization">
            <h2>⚡ Cache Optimization & Memory-Efficient Programming</h2>
            
            <div class="card">
                <h3>Understanding CPU Cache Hierarchy</h3>
                <p>Modern processors have multiple levels of cache that dramatically affect performance:</p>
                
                <div class="callout">
                    <div class="callout-title">📊 Cache Hierarchy</div>
                    <ul>
                        <li><strong>L1 Cache:</strong> 32-64KB, 1-2 cycles, per-core</li>
                        <li><strong>L2 Cache:</strong> 256KB-1MB, 10-20 cycles, per-core</li>
                        <li><strong>L3 Cache:</strong> 8-32MB, 30-40 cycles, shared</li>
                        <li><strong>Main RAM:</strong> GBs, 200-300 cycles</li>
                        <li><strong>SSD:</strong> ~100,000 cycles</li>
                        <li><strong>HDD:</strong> ~10,000,000 cycles</li>
                    </ul>
                </div>

                <div class="code-container">
                    <div class="code-title">
                        Cache-Aware Programming Techniques
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="comment">// Array of Structures (AoS) - Cache unfriendly</span>
<span class="keyword">struct</span> <span class="function">Particle_AoS</span> {
    <span class="keyword">float</span> <span class="variable">x</span>, <span class="variable">y</span>, <span class="variable">z</span>;        <span class="comment">// Position</span>
    <span class="keyword">float</span> <span class="variable">vx</span>, <span class="variable">vy</span>, <span class="variable">vz</span>;     <span class="comment">// Velocity</span>
    <span class="keyword">float</span> <span class="variable">mass</span>;             <span class="comment">// Mass</span>
    <span class="keyword">int</span>   <span class="variable">id</span>;               <span class="comment">// Identifier</span>
};
<span class="keyword">Particle_AoS</span> <span class="variable">particles_aos</span>[<span class="number">1000</span>];

<span class="comment">// Update only positions - loads unnecessary data</span>
<span class="keyword">for</span>(<span class="keyword">int</span> <span class="variable">i</span> = <span class="number">0</span>; <span class="variable">i</span> &lt; <span class="number">1000</span>; <span class="variable">i</span>++) {
    <span class="variable">particles_aos</span>[<span class="variable">i</span>].<span class="variable">x</span> += <span class="variable">particles_aos</span>[<span class="variable">i</span>].<span class="variable">vx</span>; <span class="comment">// Loads entire struct!</span>
    <span class="variable">particles_aos</span>[<span class="variable">i</span>].<span class="variable">y</span> += <span class="variable">particles_aos</span>[<span class="variable">i</span>].<span class="variable">vy</span>;
    <span class="variable">particles_aos</span>[<span class="variable">i</span>].<span class="variable">z</span> += <span class="variable">particles_aos</span>[<span class="variable">i</span>].<span class="variable">vz</span>;
}

<span class="comment">// Structure of Arrays (SoA) - Cache friendly</span>
<span class="keyword">struct</span> <span class="function">Particles_SoA</span> {
    <span class="keyword">float</span> <span class="variable">x</span>[<span class="number">1000</span>], <span class="variable">y</span>[<span class="number">1000</span>], <span class="variable">z</span>[<span class="number">1000</span>];        <span class="comment">// Positions</span>
    <span class="keyword">float</span> <span class="variable">vx</span>[<span class="number">1000</span>], <span class="variable">vy</span>[<span class="number">1000</span>], <span class="variable">vz</span>[<span class="number">1000</span>];     <span class="comment">// Velocities</span>
    <span class="keyword">float</span> <span class="variable">mass</span>[<span class="number">1000</span>];                        <span class="comment">// Masses</span>
    <span class="keyword">int</span>   <span class="variable">id</span>[<span class="number">1000</span>];                          <span class="comment">// Identifiers</span>
};
<span class="keyword">Particles_SoA</span> <span class="variable">particles_soa</span>;

<span class="comment">// Update only positions - perfect cache utilization</span>
<span class="keyword">for</span>(<span class="keyword">int</span> <span class="variable">i</span> = <span class="number">0</span>; <span class="variable">i</span> &lt; <span class="number">1000</span>; <span class="variable">i</span>++) {
    <span class="variable">particles_soa</span>.<span class="variable">x</span>[<span class="variable">i</span>] += <span class="variable">particles_soa</span>.<span class="variable">vx</span>[<span class="variable">i</span>]; <span class="comment">// Sequential access!</span>
    <span class="variable">particles_soa</span>.<span class="variable">y</span>[<span class="variable">i</span>] += <span class="variable">particles_soa</span>.<span class="variable">vy</span>[<span class="variable">i</span>];
    <span class="variable">particles_soa</span>.<span class="variable">z</span>[<span class="variable">i</span>] += <span class="variable">particles_soa</span>.<span class="variable">vz</span>[<span class="variable">i</span>];
}</code></pre>
                </div>

                <!-- Cache Optimization Code Explanation -->
                <div class="code-explanation">
                    <div class="explanation-header" onclick="toggleExplanation(this)">
                        <div class="explanation-title">
                            🔍 <span>Cache Optimization Deep Analysis</span>
                        </div>
                        <button class="explanation-toggle">Show Details</button>
                    </div>
                    <div class="explanation-content">
                        <div class="explanation-section">
                            <h4>🏗️ Array of Structures (AoS) Memory Layout</h4>
                            <div class="memory-impact">
                                <h5>📊 Memory Organization</h5>
                                <p><strong>Struct Size:</strong> 28 bytes (7 floats × 4 bytes + 1 int × 4 bytes)</p>
                                <p><strong>Array Memory:</strong> 28,000 bytes (1000 × 28 bytes)</p>
                                <p><strong>Memory Pattern:</strong> [x,y,z,vx,vy,vz,mass,id][x,y,z,vx,vy,vz,mass,id]...</p>
                                <p><strong>Cache Line Usage:</strong> Each 64-byte cache line holds ~2.3 particles</p>
                            </div>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">11</span>
                                    <span class="line-code">particles_aos[i].x += particles_aos[i].vx;</span>
                                    <span class="line-explanation">Loads 28 bytes but only uses 8 bytes (x, vx)</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">12</span>
                                    <span class="line-code">particles_aos[i].y += particles_aos[i].vy;</span>
                                    <span class="line-explanation">Another 28-byte load for just 8 bytes needed</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">13</span>
                                    <span class="line-code">particles_aos[i].z += particles_aos[i].vz;</span>
                                    <span class="line-explanation">Third 28-byte load for final 8 bytes</span>
                                </div>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>⚡ Structure of Arrays (SoA) Memory Layout</h4>
                            <div class="best-practices">
                                <h5>📊 Optimized Memory Organization</h5>
                                <ul>
                                    <li><strong>x array:</strong> 4000 bytes (1000 × 4 bytes) contiguous</li>
                                    <li><strong>vx array:</strong> 4000 bytes (1000 × 4 bytes) contiguous</li>
                                    <li><strong>Memory Pattern:</strong> [x₀,x₁,x₂...x₉₉₉][vx₀,vx₁,vx₂...vx₉₉₉]</li>
                                    <li><strong>Cache Efficiency:</strong> 16 floats per 64-byte cache line</li>
                                </ul>
                            </div>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">24</span>
                                    <span class="line-code">particles_soa.x[i] += particles_soa.vx[i];</span>
                                    <span class="line-explanation">Sequential access: loads 64 bytes, uses all efficiently</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">25</span>
                                    <span class="line-code">particles_soa.y[i] += particles_soa.vy[i];</span>
                                    <span class="line-explanation">Next sequential elements likely in same cache line</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">26</span>
                                    <span class="line-code">particles_soa.z[i] += particles_soa.vz[i];</span>
                                    <span class="line-explanation">Continues sequential pattern, maximum cache reuse</span>
                                </div>
                            </div>
                        </div>

                        <div class="memory-impact">
                            <h5>🧠 Cache Performance Analysis</h5>
                            <p><strong>AoS Cache Misses:</strong> ~85% cache miss rate (loading unused data)</p>
                            <p><strong>SoA Cache Hits:</strong> ~95% cache hit rate (sequential access pattern)</p>
                            <p><strong>Memory Bandwidth:</strong> AoS wastes ~71% of loaded data (20/28 bytes unused)</p>
                            <p><strong>SoA Efficiency:</strong> Uses 100% of loaded cache lines effectively</p>
                        </div>

                        <div class="explanation-section">
                            <h4>🔬 Detailed Performance Breakdown</h4>
                            <div class="performance-note">
                                <h5>⏱️ Timing Analysis (1000 particles)</h5>
                                <p><strong>AoS Approach:</strong></p>
                                <ul>
                                    <li>Memory accesses: 6000 (3 loads × 2 fields × 1000 particles)</li>
                                    <li>Cache lines loaded: ~1200 (28 bytes per access / 64 bytes per line)</li>
                                    <li>Wasted bandwidth: ~85% (unused struct fields)</li>
                                    <li>Estimated time: 3000-6000 CPU cycles</li>
                                </ul>
                                <p><strong>SoA Approach:</strong></p>
                                <ul>
                                    <li>Memory accesses: 6000 (same as AoS)</li>
                                    <li>Cache lines loaded: ~375 (4 bytes per access / 64 bytes per line)</li>
                                    <li>Wasted bandwidth: ~0% (all data used)</li>
                                    <li>Estimated time: 500-1000 CPU cycles</li>
                                </ul>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>🎯 When to Use Each Pattern</h4>
                            <div class="best-practices">
                                <h5>✅ Use AoS When:</h5>
                                <ul>
                                    <li>Working with complete objects frequently</li>
                                    <li>Object-oriented design is more important than performance</li>
                                    <li>Random access patterns dominate</li>
                                    <li>Small datasets where cache optimization doesn't matter</li>
                                </ul>
                            </div>
                            <div class="memory-impact">
                                <h5>🚀 Use SoA When:</h5>
                                <ul>
                                    <li>Processing specific fields across many objects</li>
                                    <li>SIMD operations (vectorization) are possible</li>
                                    <li>Large datasets where cache performance matters</li>
                                    <li>Game engines, physics simulations, scientific computing</li>
                                </ul>
                            </div>
                        </div>

                        <div class="performance-note">
                            <h5>🔧 Advanced Optimizations</h5>
                            <p><strong>Hybrid Approach:</strong> Use SoAoS (Structure of Arrays of Structures) for balanced performance</p>
                            <p><strong>SIMD Vectorization:</strong> SoA enables easy SIMD operations (process 4-8 elements simultaneously)</p>
                            <p><strong>GPU Computing:</strong> SoA is essential for GPU kernels due to coalesced memory access</p>
                            <p><strong>Prefetching:</strong> Sequential SoA access triggers hardware prefetchers automatically</p>
                        </div>
                    </div>
                </div>

                <div class="callout success">
                    <div class="callout-title">🚀 Performance Improvement</div>
                    <p>SoA can be 2-10x faster than AoS for operations that only need specific fields, due to better cache utilization and fewer memory transfers.</p>
                </div>
            </div>

            <div class="card">
                <h3>Memory Pool Allocation</h3>
                <p>Reduce allocation overhead and fragmentation with memory pools:</p>
                
                <div class="code-container">
                    <div class="code-title">
                        Memory Pool Implementation
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="variable">T</span>, <span class="keyword">size_t</span> <span class="variable">PoolSize</span>&gt;
<span class="keyword">class</span> <span class="function">MemoryPool</span> {
<span class="keyword">private</span>:
    <span class="keyword">alignas</span>(<span class="variable">T</span>) <span class="keyword">char</span> <span class="variable">pool</span>[<span class="variable">PoolSize</span> * <span class="keyword">sizeof</span>(<span class="variable">T</span>)];
    <span class="keyword">bool</span> <span class="variable">used</span>[<span class="variable">PoolSize</span>];
    <span class="keyword">size_t</span> <span class="variable">next_free</span>;

<span class="keyword">public</span>:
    <span class="function">MemoryPool</span>() : <span class="variable">next_free</span>(<span class="number">0</span>) {
        <span class="function">std::fill</span>(<span class="variable">used</span>, <span class="variable">used</span> + <span class="variable">PoolSize</span>, <span class="keyword">false</span>);
    }

    <span class="variable">T</span>* <span class="function">allocate</span>() {
        <span class="comment">// Find first free slot</span>
        <span class="keyword">for</span>(<span class="keyword">size_t</span> <span class="variable">i</span> = <span class="number">0</span>; <span class="variable">i</span> &lt; <span class="variable">PoolSize</span>; <span class="variable">i</span>++) {
            <span class="keyword">size_t</span> <span class="variable">idx</span> = (<span class="variable">next_free</span> + <span class="variable">i</span>) % <span class="variable">PoolSize</span>;
            <span class="keyword">if</span>(!<span class="variable">used</span>[<span class="variable">idx</span>]) {
                <span class="variable">used</span>[<span class="variable">idx</span>] = <span class="keyword">true</span>;
                <span class="variable">next_free</span> = (<span class="variable">idx</span> + <span class="number">1</span>) % <span class="variable">PoolSize</span>;
                <span class="keyword">return</span> <span class="function">reinterpret_cast</span>&lt;<span class="variable">T</span>*&gt;(&amp;<span class="variable">pool</span>[<span class="variable">idx</span> * <span class="keyword">sizeof</span>(<span class="variable">T</span>)]);
            }
        }
        <span class="keyword">return</span> <span class="keyword">nullptr</span>; <span class="comment">// Pool exhausted</span>
    }

    <span class="keyword">void</span> <span class="function">deallocate</span>(<span class="variable">T</span>* <span class="variable">ptr</span>) {
        <span class="comment">// Calculate index from pointer</span>
        <span class="keyword">size_t</span> <span class="variable">idx</span> = (<span class="function">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="variable">ptr</span>) - <span class="variable">pool</span>) / <span class="keyword">sizeof</span>(<span class="variable">T</span>);
        <span class="keyword">if</span>(<span class="variable">idx</span> &lt; <span class="variable">PoolSize</span>) {
            <span class="variable">used</span>[<span class="variable">idx</span>] = <span class="keyword">false</span>;
        }
    }
};

<span class="comment">// Usage example</span>
<span class="keyword">MemoryPool</span>&lt;<span class="keyword">int</span>, <span class="number">1000</span>&gt; <span class="variable">int_pool</span>;
<span class="keyword">int</span>* <span class="variable">fast_int</span> = <span class="variable">int_pool</span>.<span class="function">allocate</span>();  <span class="comment">// O(1) allocation!</span>
<span class="variable">int_pool</span>.<span class="function">deallocate</span>(<span class="variable">fast_int</span>);          <span class="comment">// O(1) deallocation!</span></code></pre>
                </div>

                <!-- Memory Pool Implementation Explanation -->
                <div class="code-explanation">
                    <div class="explanation-header" onclick="toggleExplanation(this)">
                        <div class="explanation-title">
                            🔍 <span>Memory Pool Architecture & Performance Analysis</span>
                        </div>
                        <button class="explanation-toggle">Show Details</button>
                    </div>
                    <div class="explanation-content">
                        <div class="explanation-section">
                            <h4>🏗️ Memory Pool Design Principles</h4>
                            <div class="memory-impact">
                                <h5>🎯 Core Architecture</h5>
                                <p><strong>Pre-allocation Strategy:</strong> Allocate large contiguous block upfront</p>
                                <p><strong>Fixed-Size Objects:</strong> All allocations same size (template parameter T)</p>
                                <p><strong>O(1) Operations:</strong> Constant time allocation and deallocation</p>
                                <p><strong>Zero Fragmentation:</strong> No memory fragmentation within pool</p>
                                <p><strong>Cache Friendly:</strong> Contiguous memory improves cache performance</p>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>🔬 Implementation Deep Dive</h4>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">Line 4</span>
                                    <span class="line-code">alignas(T) char pool[PoolSize * sizeof(T)];</span>
                                    <span class="line-explanation">Pre-allocates aligned memory for PoolSize objects</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Line 5</span>
                                    <span class="line-code">bool used[PoolSize];</span>
                                    <span class="line-explanation">Bitmap tracking which slots are occupied</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Line 6</span>
                                    <span class="line-code">size_t next_free;</span>
                                    <span class="line-explanation">Optimization hint for finding next available slot</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Line 13</span>
                                    <span class="line-code">size_t idx = (next_free + i) % PoolSize;</span>
                                    <span class="line-explanation">Circular search starting from hint position</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Line 17</span>
                                    <span class="line-code">reinterpret_cast&lt;T*&gt;(&pool[idx * sizeof(T)])</span>
                                    <span class="line-explanation">Calculate pointer to specific slot in pool</span>
                                </div>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>⚡ Performance Analysis</h4>
                            <div class="performance-note">
                                <h5>🚀 Allocation Performance</h5>
                                <p><strong>Best Case:</strong> O(1) - next_free points to available slot</p>
                                <p><strong>Average Case:</strong> O(k) where k is number of used slots to scan</p>
                                <p><strong>Worst Case:</strong> O(n) - scan entire pool when nearly full</p>
                                <p><strong>Memory Overhead:</strong> 1 bit per slot + pool metadata (~1 byte per object)</p>
                                <p><strong>Cache Performance:</strong> Excellent - all allocations from same memory region</p>
                            </div>
                            <div class="memory-impact">
                                <h5>📊 Compared to Standard Allocator</h5>
                                <p><strong>malloc() call:</strong> ~100-500 CPU cycles (system call + heap search)</p>
                                <p><strong>Pool allocation:</strong> ~5-50 CPU cycles (array indexing + bitmap check)</p>
                                <p><strong>malloc() overhead:</strong> 16-32 bytes metadata per allocation</p>
                                <p><strong>Pool overhead:</strong> 1 bit per slot + fixed pool overhead</p>
                                <p><strong>Fragmentation - malloc:</strong> Can be severe with mixed size allocations</p>
                                <p><strong>Fragmentation - Pool:</strong> Zero internal fragmentation</p>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>🧮 Memory Layout Analysis</h4>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">Pool Layout</span>
                                    <span class="line-code">Memory Organization</span>
                                    <span class="line-explanation">Address Calculation</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Slot 0</span>
                                    <span class="line-code">pool[0] → pool[sizeof(T)-1]</span>
                                    <span class="line-explanation">Base address + 0 * sizeof(T)</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Slot 1</span>
                                    <span class="line-code">pool[sizeof(T)] → pool[2*sizeof(T)-1]</span>
                                    <span class="line-explanation">Base address + 1 * sizeof(T)</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Slot N</span>
                                    <span class="line-code">pool[N*sizeof(T)] → pool[(N+1)*sizeof(T)-1]</span>
                                    <span class="line-explanation">Base address + N * sizeof(T)</span>
                                </div>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>🔄 Allocation Algorithm Walkthrough</h4>
                            <div class="best-practices">
                                <h5>📝 Step-by-Step Allocation Process</h5>
                                <ol>
                                    <li><strong>Start Search:</strong> Begin at next_free hint position</li>
                                    <li><strong>Check Availability:</strong> Test if used[idx] is false</li>
                                    <li><strong>Mark Used:</strong> Set used[idx] = true</li>
                                    <li><strong>Update Hint:</strong> Move next_free to next position</li>
                                    <li><strong>Calculate Address:</strong> Return pointer to pool[idx * sizeof(T)]</li>
                                    <li><strong>Handle Failure:</strong> Return nullptr if pool exhausted</li>
                                </ol>
                            </div>
                            <div class="memory-impact">
                                <h5>📝 Deallocation Process</h5>
                                <ol>
                                    <li><strong>Validate Pointer:</strong> Ensure pointer is within pool bounds</li>
                                    <li><strong>Calculate Index:</strong> idx = (ptr - pool_base) / sizeof(T)</li>
                                    <li><strong>Mark Free:</strong> Set used[idx] = false</li>
                                    <li><strong>No Cleanup:</strong> Memory reused without clearing (performance)</li>
                                </ol>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>🎯 Optimization Techniques</h4>
                            <div class="performance-note">
                                <h5>⚡ Advanced Pool Optimizations</h5>
                                <ul>
                                    <li><strong>Free List:</strong> Link freed slots for O(1) allocation</li>
                                    <li><strong>Buddy Allocation:</strong> Support multiple sizes with power-of-2 blocks</li>
                                    <li><strong>Thread-Local Pools:</strong> Eliminate synchronization overhead</li>
                                    <li><strong>NUMA Awareness:</strong> Allocate pools on specific CPU nodes</li>
                                    <li><strong>Prefaulting:</strong> Touch all pages during initialization</li>
                                </ul>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>🚨 Limitations & Considerations</h4>
                            <div class="memory-impact">
                                <h5>⚠️ Design Trade-offs</h5>
                                <p><strong>Fixed Size Only:</strong> Can't handle variable-sized allocations</p>
                                <p><strong>Memory Waste:</strong> Unused pool space if allocation pattern changes</p>
                                <p><strong>Pool Exhaustion:</strong> Hard limit on number of active objects</p>
                                <p><strong>Alignment Requirements:</strong> Must respect object alignment constraints</p>
                                <p><strong>Not Thread-Safe:</strong> Requires external synchronization for multi-threading</p>
                            </div>
                        </div>

                        <div class="best-practices">
                            <h5>🎯 When to Use Memory Pools</h5>
                            <ul>
                                <li><strong>Game Engines:</strong> Frequent object creation/destruction (bullets, particles)</li>
                                <li><strong>Network Servers:</strong> Request/response object allocation</li>
                                <li><strong>Real-time Systems:</strong> Predictable allocation performance</li>
                                <li><strong>Embedded Systems:</strong> Limited memory with known allocation patterns</li>
                                <li><strong>High-frequency Trading:</strong> Microsecond-level latency requirements</li>
                            </ul>
                        </div>

                        <div class="memory-impact">
                            <h5>📊 Example Use Case Analysis</h5>
                            <p><strong>Scenario:</strong> Web server handling 10,000 requests/second</p>
                            <p><strong>Standard malloc:</strong> 500 cycles × 10,000 = 5M cycles/sec allocation overhead</p>
                            <p><strong>Memory pool:</strong> 20 cycles × 10,000 = 200K cycles/sec allocation overhead</p>
                            <p><strong>Performance Gain:</strong> 25× faster allocation = 2.5% total CPU savings</p>
                            <p><strong>Additional Benefits:</strong> Reduced fragmentation, better cache locality</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Memory Profiling and Debugging -->
        <section id="memory-profiling">
            <h2>🔍 Memory Profiling & Problem Analysis</h2>
            
            <div class="card">
                <h3>Common Memory Problems</h3>
                
                <div class="callout danger">
                    <div class="callout-title">💀 Memory Leak Detection</div>
                    <p>Memory leaks occur when allocated memory is never freed, gradually consuming system resources.</p>
                </div>

                <div class="code-container">
                    <div class="code-title">
                        Memory Leak Examples
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="comment">// 1. Classic memory leak</span>
<span class="keyword">void</span> <span class="function">memory_leak_example</span>() {
    <span class="keyword">int</span>* <span class="variable">ptr</span> = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000</span>];
    <span class="comment">// ... do work ...</span>
    <span class="keyword">return</span>; <span class="comment">// BUG: forgot delete[] ptr!</span>
}

<span class="comment">// 2. Exception-based leak</span>
<span class="keyword">void</span> <span class="function">exception_leak</span>() {
    <span class="keyword">int</span>* <span class="variable">ptr</span> = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000</span>];
    <span class="function">risky_function</span>();  <span class="comment">// May throw exception</span>
    <span class="keyword">delete</span>[] <span class="variable">ptr</span>;       <span class="comment">// Never reached if exception thrown!</span>
}

<span class="comment">// 3. Circular reference leak (smart pointers)</span>
<span class="keyword">struct</span> <span class="function">Node</span> {
    <span class="keyword">std::shared_ptr</span>&lt;<span class="keyword">Node</span>&gt; <span class="variable">next</span>;
    <span class="keyword">std::shared_ptr</span>&lt;<span class="keyword">Node</span>&gt; <span class="variable">prev</span>; <span class="comment">// Creates cycle!</span>
};

<span class="comment">// Solutions:</span>
<span class="comment">// 1. Use RAII and smart pointers</span>
<span class="keyword">void</span> <span class="function">safe_version</span>() {
    <span class="keyword">auto</span> <span class="variable">ptr</span> = <span class="function">std::make_unique</span>&lt;<span class="keyword">int</span>[]&gt;(<span class="number">1000</span>);
    <span class="function">risky_function</span>();  <span class="comment">// Safe: automatic cleanup</span>
} <span class="comment">// ptr automatically freed here</span>

<span class="comment">// 2. Break cycles with weak_ptr</span>
<span class="keyword">struct</span> <span class="function">SafeNode</span> {
    <span class="keyword">std::shared_ptr</span>&lt;<span class="keyword">SafeNode</span>&gt; <span class="variable">next</span>;
    <span class="keyword">std::weak_ptr</span>&lt;<span class="keyword">SafeNode</span>&gt; <span class="variable">prev</span>; <span class="comment">// Breaks cycle!</span>
};</code></pre>
                </div>

                <!-- Memory Leak Code Explanation -->
                <div class="code-explanation">
                    <div class="explanation-header" onclick="toggleExplanation(this)">
                        <div class="explanation-title">
                            🔍 <span>Memory Leak & Safety Analysis</span>
                        </div>
                        <button class="explanation-toggle">Show Details</button>
                    </div>
                    <div class="explanation-content">
                        <div class="explanation-section">
                            <h4>💀 Memory Leak Pattern Analysis</h4>
                            <div class="memory-impact">
                                <h5>🔴 Leak #1: Classic Forgotten Deallocation</h5>
                                <p><strong>Problem:</strong> Function allocates 4000 bytes but never frees them</p>
                                <p><strong>Impact:</strong> Each call leaks 4KB, 1000 calls = 4MB permanent loss</p>
                                <p><strong>Detection:</strong> Memory profilers show increasing heap usage</p>
                                <p><strong>Severity:</strong> Critical - leads to out-of-memory errors</p>
                            </div>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">2</span>
                                    <span class="line-code">int* ptr = new int[1000];</span>
                                    <span class="line-explanation">Heap allocator assigns 4000 bytes, adds to allocated list</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">4</span>
                                    <span class="line-code">return;</span>
                                    <span class="line-explanation">Stack frame destroyed, but heap memory stays allocated!</span>
                                </div>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>⚠️ Exception Safety Issues</h4>
                            <div class="performance-note">
                                <h5>🔴 Leak #2: Exception-Based Memory Leak</h5>
                                <p><strong>Problem:</strong> Exception thrown between allocation and deallocation</p>
                                <p><strong>Stack Unwinding:</strong> C++ destroys stack objects but ignores raw pointers</p>
                                <p><strong>Frequency:</strong> Very common in error-prone code paths</p>
                                <p><strong>Solution:</strong> RAII pattern ensures cleanup during stack unwinding</p>
                            </div>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">7</span>
                                    <span class="line-code">int* ptr = new int[1000];</span>
                                    <span class="line-explanation">Memory allocated successfully</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">8</span>
                                    <span class="line-code">risky_function();</span>
                                    <span class="line-explanation">If exception thrown, control jumps to handler</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">9</span>
                                    <span class="line-code">delete[] ptr;</span>
                                    <span class="line-explanation">NEVER EXECUTED if exception thrown above!</span>
                                </div>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>🔄 Circular Reference Problem</h4>
                            <div class="memory-impact">
                                <h5>🔴 Leak #3: Smart Pointer Cycle</h5>
                                <p><strong>Problem:</strong> shared_ptr A points to B, B points back to A</p>
                                <p><strong>Reference Count:</strong> Both objects have refcount = 1 forever</p>
                                <p><strong>Garbage Collection:</strong> C++ has no GC to break cycles automatically</p>
                                <p><strong>Detection:</strong> Objects never destroyed despite going out of scope</p>
                            </div>
                            <p><strong>Memory Layout:</strong></p>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">Node A</span>
                                    <span class="line-code">next → Node B (refcount++)</span>
                                    <span class="line-explanation">A's shared_ptr increases B's reference count</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Node B</span>
                                    <span class="line-code">prev → Node A (refcount++)</span>
                                    <span class="line-explanation">B's shared_ptr increases A's reference count</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Result</span>
                                    <span class="line-code">Both refcounts = 1</span>
                                    <span class="line-explanation">Neither can reach refcount = 0 for destruction</span>
                                </div>
                            </div>
                        </div>

                        <div class="best-practices">
                            <h5>✅ Solution Analysis</h5>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">RAII</span>
                                    <span class="line-code">auto ptr = std::make_unique&lt;int[]&gt;(1000);</span>
                                    <span class="line-explanation">Destructor called automatically during stack unwinding</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Weak Ptr</span>
                                    <span class="line-code">std::weak_ptr&lt;SafeNode&gt; prev;</span>
                                    <span class="line-explanation">Doesn't increase reference count, breaks cycles</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Null Check</span>
                                    <span class="line-code">ptr = nullptr;</span>
                                    <span class="line-explanation">delete nullptr is safe no-op operation</span>
                                </div>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>🔬 Memory Leak Detection Techniques</h4>
                            <div class="performance-note">
                                <h5>🛠️ Detection Methods</h5>
                                <ul>
                                    <li><strong>Static Analysis:</strong> Clang analyzer finds leaks at compile time</li>
                                    <li><strong>Valgrind:</strong> Runtime tracking of all allocations/deallocations</li>
                                    <li><strong>AddressSanitizer:</strong> Compiler instrumentation for leak detection</li>
                                    <li><strong>Smart Pointer Counters:</strong> Debug builds can track reference counts</li>
                                </ul>
                            </div>
                        </div>

                        <div class="memory-impact">
                            <h5>📊 Real-World Impact</h5>
                            <p><strong>Server Applications:</strong> 1KB leak per request × 1M requests = 1GB wasted</p>
                            <p><strong>Game Engines:</strong> Frame-by-frame leaks cause gradual performance degradation</p>
                            <p><strong>Mobile Apps:</strong> Limited RAM makes even small leaks critical</p>
                            <p><strong>Embedded Systems:</strong> Memory leaks can cause device crashes/reboots</p>
                        </div>

                        <div class="best-practices">
                            <h5>🎯 Prevention Strategies</h5>
                            <ul>
                                <li><strong>RAII Everywhere:</strong> Every resource should have an owner object</li>
                                <li><strong>Smart Pointers:</strong> Prefer unique_ptr > shared_ptr > raw pointers</li>
                                <li><strong>Exception Safety:</strong> Use RAII guards for exception-safe code</li>
                                <li><strong>Code Reviews:</strong> Check for matching new/delete, lock/unlock pairs</li>
                                <li><strong>Automated Testing:</strong> Include memory leak checks in CI/CD pipeline</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="callout warning">
                    <div class="callout-title">⚠️ Dangling Pointers</div>
                    <p>Accessing memory after it's been freed leads to undefined behavior and security vulnerabilities.</p>
                </div>

                <div class="code-container">
                    <div class="code-title">
                        Dangling Pointer Examples
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="comment">// 1. Use after free</span>
<span class="keyword">int</span>* <span class="variable">ptr</span> = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>);
<span class="keyword">delete</span> <span class="variable">ptr</span>;
<span class="function">printf</span>(<span class="string">"%d"</span>, *<span class="variable">ptr</span>); <span class="comment">// BUG: Dangling pointer access!</span>

<span class="comment">// 2. Stack reference outlives scope</span>
<span class="keyword">int</span>* <span class="function">get_stack_address</span>() {
    <span class="keyword">int</span> <span class="variable">local_var</span> = <span class="number">100</span>;
    <span class="keyword">return</span> &amp;<span class="variable">local_var</span>; <span class="comment">// BUG: Returns address of destroyed variable</span>
}

<span class="keyword">int</span>* <span class="variable">dangerous_ptr</span> = <span class="function">get_stack_address</span>();
<span class="function">printf</span>(<span class="string">"%d"</span>, *<span class="variable">dangerous_ptr</span>); <span class="comment">// Undefined behavior!</span>

<span class="comment">// 3. Double free</span>
<span class="keyword">int</span>* <span class="variable">ptr</span> = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>);
<span class="keyword">delete</span> <span class="variable">ptr</span>;
<span class="keyword">delete</span> <span class="variable">ptr</span>; <span class="comment">// BUG: Double free!</span>

<span class="comment">// Solutions:</span>
<span class="comment">// 1. Set pointers to nullptr after deletion</span>
<span class="keyword">delete</span> <span class="variable">ptr</span>;
<span class="variable">ptr</span> = <span class="keyword">nullptr</span>; <span class="comment">// Safe: nullptr delete is no-op</span>

<span class="comment">// 2. Use smart pointers (automatic cleanup)</span>
<span class="keyword">auto</span> <span class="variable">smart_ptr</span> = <span class="function">std::make_unique</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);
<span class="comment">// No manual deletion needed!</span></code></pre>
                </div>
            </div>

            <div class="card">
                <h3>Memory Debugging Tools</h3>
                
                <div class="callout">
                    <div class="callout-title">🛠️ Essential Tools</div>
                    <ul>
                        <li><strong>Valgrind:</strong> Memory error detection (Linux)</li>
                        <li><strong>AddressSanitizer:</strong> Fast memory error detector (GCC/Clang)</li>
                        <li><strong>Dr. Memory:</strong> Windows memory debugging</li>
                        <li><strong>Static Analysis:</strong> PVS-Studio, Clang Static Analyzer</li>
                        <li><strong>Runtime Checkers:</strong> Guard malloc, Electric Fence</li>
                    </ul>
                </div>

                <div class="code-container">
                    <div class="code-title">
                        Using AddressSanitizer
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="comment">// Compile with AddressSanitizer</span>
<span class="comment">// g++ -fsanitize=address -g -o program program.cpp</span>

<span class="keyword">#include</span> <span class="string">&lt;iostream&gt;</span>

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="keyword">int</span>* <span class="variable">arr</span> = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];
    
    <span class="comment">// Buffer overflow - AddressSanitizer will catch this</span>
    <span class="variable">arr</span>[<span class="number">10</span>] = <span class="number">42</span>; <span class="comment">// Out of bounds!</span>
    
    <span class="comment">// Memory leak - AddressSanitizer will report this</span>
    <span class="comment">// delete[] arr; // Forgot to delete!</span>
    
    <span class="keyword">return</span> <span class="number">0</span>;
}

<span class="comment">// AddressSanitizer output:</span>
<span class="comment">// ==ERROR: AddressSanitizer: heap-buffer-overflow</span>
<span class="comment">// Write of size 4 at 0x... thread T0:</span>
<span class="comment">// #0 0x... in main program.cpp:8</span>
<span class="comment">// 0x... is located 0 bytes to the right of 40-byte region</span></code></pre>
                </div>
            </div>
        </section>

        <!-- Memory Budget Analysis -->
        <section id="memory-budget">
            <h2>📊 Memory Budget & Performance Analysis</h2>
            
            <div class="card">
                <h3>Memory Cost Analysis by Data Type</h3>
                
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Data Type</th>
                            <th>Size (64-bit)</th>
                            <th>Alignment</th>
                            <th>Cache Lines</th>
                            <th>Use Case</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>bool</code></td>
                            <td>1 byte</td>
                            <td>1 byte</td>
                            <td>64 per line</td>
                            <td>Flags, states</td>
                        </tr>
                        <tr>
                            <td><code>char</code></td>
                            <td>1 byte</td>
                            <td>1 byte</td>
                            <td>64 per line</td>
                            <td>Text, small integers</td>
                        </tr>
                        <tr>
                            <td><code>int</code></td>
                            <td>4 bytes</td>
                            <td>4 bytes</td>
                            <td>16 per line</td>
                            <td>Counters, indices</td>
                        </tr>
                        <tr>
                            <td><code>long long</code></td>
                            <td>8 bytes</td>
                            <td>8 bytes</td>
                            <td>8 per line</td>
                            <td>Large numbers, IDs</td>
                        </tr>
                        <tr>
                            <td><code>float</code></td>
                            <td>4 bytes</td>
                            <td>4 bytes</td>
                            <td>16 per line</td>
                            <td>Graphics, physics</td>
                        </tr>
                        <tr>
                            <td><code>double</code></td>
                            <td>8 bytes</td>
                            <td>8 bytes</td>
                            <td>8 per line</td>
                            <td>Scientific computing</td>
                        </tr>
                        <tr>
                            <td><code>pointer</code></td>
                            <td>8 bytes</td>
                            <td>8 bytes</td>
                            <td>8 per line</td>
                            <td>Object references</td>
                        </tr>
                        <tr>
                            <td><code>std::string</code></td>
                            <td>32+ bytes</td>
                            <td>8 bytes</td>
                            <td>2 per line</td>
                            <td>Text processing</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="card">
                <h3>Struct Padding and Alignment</h3>
                
                <div class="code-container">
                    <div class="code-title">
                        Memory Layout Optimization
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="comment">// Poor layout - lots of padding</span>
<span class="keyword">struct</span> <span class="function">BadLayout</span> {
    <span class="keyword">char</span> <span class="variable">a</span>;      <span class="comment">// 1 byte + 3 bytes padding</span>
    <span class="keyword">int</span> <span class="variable">b</span>;       <span class="comment">// 4 bytes</span>
    <span class="keyword">char</span> <span class="variable">c</span>;      <span class="comment">// 1 byte + 7 bytes padding</span>
    <span class="keyword">double</span> <span class="variable">d</span>;    <span class="comment">// 8 bytes</span>
};              <span class="comment">// Total: 24 bytes (11 bytes wasted!)</span>

<span class="comment">// Good layout - minimal padding</span>
<span class="keyword">struct</span> <span class="function">GoodLayout</span> {
    <span class="keyword">double</span> <span class="variable">d</span>;    <span class="comment">// 8 bytes</span>
    <span class="keyword">int</span> <span class="variable">b</span>;       <span class="comment">// 4 bytes</span>
    <span class="keyword">char</span> <span class="variable">a</span>;      <span class="comment">// 1 byte</span>
    <span class="keyword">char</span> <span class="variable">c</span>;      <span class="comment">// 1 byte + 2 bytes padding</span>
};              <span class="comment">// Total: 16 bytes (only 2 bytes wasted)</span>

<span class="comment">// Check sizes at compile time</span>
<span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(<span class="keyword">BadLayout</span>) == <span class="number">24</span>);
<span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(<span class="keyword">GoodLayout</span>) == <span class="number">16</span>);

<span class="comment">// For 1000 objects:</span>
<span class="comment">// BadLayout:  24,000 bytes (wastes 11,000 bytes)</span>
<span class="comment">// GoodLayout: 16,000 bytes (saves 33% memory!)</span></code></pre>
                </div>

                <!-- Struct Layout Optimization Explanation -->
                <div class="code-explanation">
                    <div class="explanation-header" onclick="toggleExplanation(this)">
                        <div class="explanation-title">
                            🔍 <span>Struct Padding & Alignment Mastery</span>
                        </div>
                        <button class="explanation-toggle">Show Details</button>
                    </div>
                    <div class="explanation-content">
                        <div class="explanation-section">
                            <h4>📐 Memory Alignment Requirements</h4>
                            <div class="memory-impact">
                                <h5>🧠 Why Alignment Matters</h5>
                                <p><strong>CPU Efficiency:</strong> Modern processors read memory in aligned chunks (4, 8, 16 bytes)</p>
                                <p><strong>Performance Cost:</strong> Unaligned access can be 2-10x slower or cause crashes</p>
                                <p><strong>Hardware Requirement:</strong> Some architectures require strict alignment</p>
                                <p><strong>Cache Lines:</strong> Aligned data fits better in 64-byte cache lines</p>
                            </div>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">Type</span>
                                    <span class="line-code">Size → Alignment</span>
                                    <span class="line-explanation">Must be placed at addresses divisible by alignment</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">char</span>
                                    <span class="line-code">1 byte → 1-byte aligned</span>
                                    <span class="line-explanation">Can be placed at any address</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">int</span>
                                    <span class="line-code">4 bytes → 4-byte aligned</span>
                                    <span class="line-explanation">Must start at address % 4 == 0</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">double</span>
                                    <span class="line-code">8 bytes → 8-byte aligned</span>
                                    <span class="line-explanation">Must start at address % 8 == 0</span>
                                </div>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>🔴 BadLayout Memory Waste Analysis</h4>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">Offset 0</span>
                                    <span class="line-code">char a;</span>
                                    <span class="line-explanation">1 byte used</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Offset 1-3</span>
                                    <span class="line-code">[padding]</span>
                                    <span class="line-explanation">3 bytes wasted (int needs 4-byte alignment)</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Offset 4</span>
                                    <span class="line-code">int b;</span>
                                    <span class="line-explanation">4 bytes used (aligned properly)</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Offset 8</span>
                                    <span class="line-code">char c;</span>
                                    <span class="line-explanation">1 byte used</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Offset 9-15</span>
                                    <span class="line-code">[padding]</span>
                                    <span class="line-explanation">7 bytes wasted (double needs 8-byte alignment)</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Offset 16</span>
                                    <span class="line-code">double d;</span>
                                    <span class="line-explanation">8 bytes used (aligned properly)</span>
                                </div>
                            </div>
                            <div class="memory-impact">
                                <h5>📊 BadLayout Waste Summary</h5>
                                <p><strong>Total Size:</strong> 24 bytes</p>
                                <p><strong>Useful Data:</strong> 14 bytes (1+4+1+8)</p>
                                <p><strong>Wasted Padding:</strong> 10 bytes (42% waste!)</p>
                                <p><strong>Memory Efficiency:</strong> Only 58% of allocated space used</p>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>✅ GoodLayout Optimization Strategy</h4>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">Offset 0</span>
                                    <span class="line-code">double d;</span>
                                    <span class="line-explanation">8 bytes used (largest type first)</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Offset 8</span>
                                    <span class="line-code">int b;</span>
                                    <span class="line-explanation">4 bytes used (next largest type)</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Offset 12</span>
                                    <span class="line-code">char a;</span>
                                    <span class="line-explanation">1 byte used</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Offset 13</span>
                                    <span class="line-code">char c;</span>
                                    <span class="line-explanation">1 byte used (grouped with similar types)</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">Offset 14-15</span>
                                    <span class="line-code">[padding]</span>
                                    <span class="line-explanation">2 bytes padding (minimal waste)</span>
                                </div>
                            </div>
                            <div class="best-practices">
                                <h5>✅ GoodLayout Efficiency Summary</h5>
                                <ul>
                                    <li><strong>Total Size:</strong> 16 bytes</li>
                                    <li><strong>Useful Data:</strong> 14 bytes (same as BadLayout)</li>
                                    <li><strong>Wasted Padding:</strong> 2 bytes (only 12.5% waste)</li>
                                    <li><strong>Memory Efficiency:</strong> 87.5% of allocated space used</li>
                                    <li><strong>Size Reduction:</strong> 33% smaller than BadLayout</li>
                                </ul>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>🎯 Optimization Rules & Techniques</h4>
                            <div class="performance-note">
                                <h5>📏 Struct Layout Best Practices</h5>
                                <ol>
                                    <li><strong>Largest First:</strong> Put largest types (double, long) at the beginning</li>
                                    <li><strong>Group Similar Sizes:</strong> Place same-size types together</li>
                                    <li><strong>Smallest Last:</strong> char, bool at the end to minimize padding</li>
                                    <li><strong>Use #pragma pack:</strong> For space-critical applications (with caution)</li>
                                    <li><strong>Static Assert:</strong> Verify expected sizes at compile time</li>
                                </ol>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>🔬 Real-World Impact Analysis</h4>
                            <div class="memory-impact">
                                <h5>📊 Scale Impact (1000 objects)</h5>
                                <p><strong>BadLayout Array:</strong> 24,000 bytes total</p>
                                <p><strong>GoodLayout Array:</strong> 16,000 bytes total</p>
                                <p><strong>Memory Saved:</strong> 8,000 bytes (33% reduction)</p>
                                <p><strong>Cache Lines:</strong> BadLayout: 375 lines, GoodLayout: 250 lines</p>
                                <p><strong>Performance Gain:</strong> Better cache utilization = 10-30% speed boost</p>
                            </div>
                        </div>

                        <div class="best-practices">
                            <h5>🛠️ Advanced Techniques</h5>
                            <ul>
                                <li><strong>Bit Fields:</strong> Pack boolean flags into single bytes</li>
                                <li><strong>Union Optimization:</strong> Overlay mutually exclusive data</li>
                                <li><strong>Hot/Cold Data Separation:</strong> Group frequently accessed fields</li>
                                <li><strong>Cache Line Awareness:</strong> Keep related data within 64-byte boundaries</li>
                                <li><strong>Compiler Attributes:</strong> Use __attribute__((packed)) carefully</li>
                            </ul>
                        </div>

                        <div class="performance-note">
                            <h5>⚠️ Trade-offs to Consider</h5>
                            <p><strong>Space vs Speed:</strong> Packed structs save space but may slow access</p>
                            <p><strong>Portability:</strong> Alignment rules vary between architectures</p>
                            <p><strong>Maintenance:</strong> Optimal layout may reduce code readability</p>
                            <p><strong>Binary Compatibility:</strong> Layout changes break ABI compatibility</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Key Takeaways Section -->
        <section id="key-takeaways">
            <h2>🎯 Key Takeaways for Memory Masters</h2>
            
            <div class="card">
                <h3>Essential Memory Management Principles</h3>
                
                <div class="callout success">
                    <div class="callout-title">💡 Memory Mastery Guidelines</div>
                    <ul>
                        <li><strong>Stack for Speed:</strong> Use stack allocation for small, short-lived data with predictable size</li>
                        <li><strong>Heap for Flexibility:</strong> Use heap for large, long-lived, or dynamically-sized data</li>
                        <li><strong>Cache Awareness:</strong> Structure data for sequential access patterns and good spatial locality</li>
                        <li><strong>Memory Pools:</strong> Use custom allocators for frequent, same-size allocations</li>
                        <li><strong>RAII Pattern:</strong> Let constructors/destructors handle resource management automatically</li>
                        <li><strong>Profile First:</strong> Measure memory usage and performance before optimizing</li>
                        <li><strong>Tool Usage:</strong> Use sanitizers, profilers, and static analysis in development</li>
                        <li><strong>Understand Costs:</strong> Know the performance implications of your memory choices</li>
                    </ul>
                </div>
            </div>

            <div class="card">
                <h3>Performance Decision Matrix</h3>
                
                <div class="code-container">
                    <div class="code-title">
                        Memory Choice Decision Tree
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="comment">// Decision Tree for Memory Allocation</span>

<span class="keyword">if</span> (<span class="variable">size_known_at_compile_time</span> &amp;&amp; <span class="variable">size</span> &lt; <span class="number">1MB</span>) {
    <span class="comment">// Use stack allocation</span>
    <span class="keyword">int</span> <span class="variable">buffer</span>[<span class="number">1000</span>]; <span class="comment">// Fast, automatic cleanup</span>
}
<span class="keyword">else if</span> (<span class="variable">frequent_same_size_allocations</span>) {
    <span class="comment">// Use memory pool</span>
    <span class="keyword">MemoryPool</span>&lt;<span class="keyword">MyStruct</span>, <span class="number">1000</span>&gt; <span class="variable">pool</span>; <span class="comment">// O(1) alloc/dealloc</span>
}
<span class="keyword">else if</span> (<span class="variable">large_or_variable_size</span>) {
    <span class="comment">// Use heap with smart pointers</span>
    <span class="keyword">auto</span> <span class="variable">ptr</span> = <span class="function">std::make_unique</span>&lt;<span class="keyword">LargeObject</span>&gt;(); <span class="comment">// Safe cleanup</span>
}
<span class="keyword">else if</span> (<span class="variable">shared_ownership_needed</span>) {
    <span class="comment">// Use shared_ptr</span>
    <span class="keyword">auto</span> <span class="variable">shared</span> = <span class="function">std::make_shared</span>&lt;<span class="keyword">Resource</span>&gt;(); <span class="comment">// Reference counting</span>
}

<span class="comment">// Data structure layout considerations</span>
<span class="keyword">if</span> (<span class="variable">access_all_fields_together</span>) {
    <span class="comment">// Use Array of Structures (AoS)</span>
    <span class="keyword">struct</span> <span class="function">Entity</span> { <span class="keyword">float</span> <span class="variable">x</span>, <span class="variable">y</span>, <span class="variable">z</span>; };
    <span class="keyword">Entity</span> <span class="variable">entities</span>[<span class="number">1000</span>]; <span class="comment">// Good for object-oriented access</span>
}
<span class="keyword">else if</span> (<span class="variable">access_fields_separately</span>) {
    <span class="comment">// Use Structure of Arrays (SoA)</span>
    <span class="keyword">struct</span> <span class="function">EntitySystem</span> {
        <span class="keyword">float</span> <span class="variable">x</span>[<span class="number">1000</span>], <span class="variable">y</span>[<span class="number">1000</span>], <span class="variable">z</span>[<span class="number">1000</span>]; <span class="comment">// Cache-friendly</span>
    };
}</code></pre>
                </div>
            </div>

            <div class="callout">
                <div class="callout-title">🚀 Final Wisdom</div>
                <p><strong>Remember:</strong> Premature optimization is the root of all evil, but understanding memory fundamentals is essential. Profile your code, understand your data access patterns, and choose the right tool for the job. The best memory management strategy is the one that's correct first, and fast second.</p>
            </div>
        </section>
    </main>

    <script>
        // Copy code functionality
        function copyCode(button) {
            const codeBlock = button.parentElement.nextElementSibling.querySelector('code');
            const text = codeBlock.textContent;
            
            navigator.clipboard.writeText(text).then(function() {
                button.textContent = 'Copied!';
                button.style.background = 'var(--success-color)';
                setTimeout(function() {
                    button.textContent = 'Copy';
                    button.style.background = 'var(--accent-color)';
                }, 2000);
            });
        }

        // Interactive explanation toggle functionality
        function toggleExplanation(header) {
            const content = header.nextElementSibling;
            const button = header.querySelector('.explanation-toggle');
            const isExpanded = content.classList.contains('expanded');
            
            if (isExpanded) {
                content.classList.remove('expanded');
                button.textContent = 'Show Details';
                button.style.background = 'var(--accent-blue)';
            } else {
                content.classList.add('expanded');
                button.textContent = 'Hide Details';
                button.style.background = 'var(--accent-green)';
            }
            
            // Add smooth animation
            if (!isExpanded) {
                setTimeout(() => {
                    content.scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'nearest',
                        inline: 'start'
                    });
                }, 200);
            }
        }

        // Auto-expand explanations on code hover (optional enhancement)
        document.addEventListener('DOMContentLoaded', function() {
            // Add hover effects to code containers that have explanations
            const codeContainers = document.querySelectorAll('.code-container');
            
            codeContainers.forEach(container => {
                const explanation = container.parentElement.querySelector('.code-explanation');
                if (explanation) {
                    container.addEventListener('mouseenter', function() {
                        // Add subtle highlight to indicate interactive explanation available
                        container.style.borderLeft = '3px solid var(--accent-blue)';
                        container.style.paddingLeft = '1.5rem';
                    });
                    
                    container.addEventListener('mouseleave', function() {
                        container.style.borderLeft = '';
                        container.style.paddingLeft = '';
                    });
                }
            });
            
            // Add click-to-expand hint
            const explanationHeaders = document.querySelectorAll('.explanation-header');
            explanationHeaders.forEach(header => {
                header.addEventListener('mouseenter', function() {
                    this.style.background = 'rgba(88, 166, 255, 0.1)';
                });
                
                header.addEventListener('mouseleave', function() {
                    this.style.background = '';
                });
            });
        });

        // Smooth scrolling for navigation links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Add intersection observer for navigation highlighting
        const sections = document.querySelectorAll('section[id]');
        const navLinks = document.querySelectorAll('nav a[href^="#"]');

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const id = entry.target.getAttribute('id');
                    navLinks.forEach(link => {
                        link.style.color = link.getAttribute('href') === `#${id}` 
                            ? 'var(--accent-color)' 
                            : 'var(--text-color)';
                    });
                }
            });
        }, {
            threshold: 0.1,
            rootMargin: '-100px 0px -100px 0px'
        });

        sections.forEach(section => observer.observe(section));

        // Add memory visualization animations
        function animateMemoryVisualization() {
            const memoryBlocks = document.querySelectorAll('.memory-block');
            memoryBlocks.forEach((block, index) => {
                block.style.animationDelay = `${index * 0.1}s`;
                block.classList.add('animate-in');
            });
        }

        // Initialize animations when page loads
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(animateMemoryVisualization, 500);
        });

        // Add hover effects to code blocks
        document.querySelectorAll('.code-container').forEach(container => {
            container.addEventListener('mouseenter', function() {
                this.style.transform = 'translateY(-2px)';
                this.style.boxShadow = '0 8px 25px rgba(0, 123, 255, 0.15)';
            });
            
            container.addEventListener('mouseleave', function() {
                this.style.transform = 'translateY(0)';
                this.style.boxShadow = '0 4px 15px rgba(0, 0, 0, 0.1)';
            });
        });
    </script>
</body>
</html>
    </main>

    <!-- Notification for user feedback -->
    <div class="notification" id="notification"></div>

    <script>
        // Progress bar animation
        function updateProgressBar() {
            const winScroll = document.body.scrollTop || document.documentElement.scrollTop;
            const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
            const scrolled = (winScroll / height) * 100;
            document.getElementById('progressBar').style.width = scrolled + '%';
        }

        window.addEventListener('scroll', updateProgressBar);

        // Navigation highlighting
        function updateActiveNavigation() {
            const sections = document.querySelectorAll('section[id]');
            const navLinks = document.querySelectorAll('.nav-links a');
            let current = '';

            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                if (pageYOffset >= sectionTop - 60) {
                    current = section.getAttribute('id');
                }
            });

            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${current}`) {
                    link.classList.add('active');
                }
            });
        }

        window.addEventListener('scroll', updateActiveNavigation);

        // Memory visualization state
        let stackFrames = ['main()'];
        let heapObjects = ['Object A', 'Array B', 'Large Data'];

        // Stack operations
        function pushToStack() {
            const functions = ['parseData()', 'processItem()', 'validateInput()', 'calculateSum()', 'sortArray()'];
            const randomFunc = functions[Math.floor(Math.random() * functions.length)];
            stackFrames.push(randomFunc);
            updateStackVisual();
            showNotification(`Stack frame pushed: ${randomFunc}`);
        }

        function popFromStack() {
            if (stackFrames.length > 1) {
                const popped = stackFrames.pop();
                updateStackVisual();
                showNotification(`Stack frame popped: ${popped}`);
            } else {
                showNotification('Cannot pop main() frame!', 'error');
            }
        }

        function updateStackVisual() {
            const stackVisual = document.getElementById('stackVisual');
            stackVisual.innerHTML = '';
            
            stackFrames.forEach((frame, index) => {
                const block = document.createElement('div');
                block.className = 'memory-block stack-block';
                block.style.bottom = (10 + index * 40) + 'px';
                block.textContent = frame;
                block.style.animation = 'fadeIn 0.3s ease';
                stackVisual.appendChild(block);
            });
        }

        // Heap operations
        function allocateHeap() {
            const objects = ['User Object', 'Data Buffer', 'Image Cache', 'Network Buffer', 'File Handle'];
            const randomObj = objects[Math.floor(Math.random() * objects.length)];
            heapObjects.push(randomObj);
            updateHeapVisual();
            showNotification(`Heap object allocated: ${randomObj}`);
        }

        function deallocateHeap() {
            if (heapObjects.length > 0) {
                const deallocated = heapObjects.pop();
                updateHeapVisual();
                showNotification(`Heap object deallocated: ${deallocated}`);
            } else {
                showNotification('No heap objects to deallocate!', 'warning');
            }
        }

        function updateHeapVisual() {
            const heapVisual = document.getElementById('heapVisual');
            heapVisual.innerHTML = '';
            
            heapObjects.forEach((obj, index) => {
                const block = document.createElement('div');
                block.className = 'memory-block heap-block';
                block.style.top = (20 + (index % 4) * 45) + 'px';
                block.style.left = (20 + Math.floor(index / 4) * 100) + 'px';
                block.style.width = (60 + Math.random() * 40) + 'px';
                block.style.height = (30 + Math.random() * 20) + 'px';
                block.textContent = obj;
                block.style.animation = 'fadeIn 0.3s ease';
                heapVisual.appendChild(block);
            });
        }

        // Interactive demo functions
        function runStackDemo() {
            const output = document.getElementById('demoOutput');
            output.innerHTML = `
                <div style="color: var(--accent-green); font-weight: 600; margin-bottom: 1rem;">🔧 Stack Allocation Demo</div>
                <div style="margin: 0.5rem 0;">Allocating local variables...</div>
                <div style="margin: 0.5rem 0;">int x = 10; // Stack: 0x7fff1234 (4 bytes)</div>
                <div style="margin: 0.5rem 0;">char buffer[256]; // Stack: 0x7fff1238 (256 bytes)</div>
                <div style="margin: 0.5rem 0;">double pi = 3.14159; // Stack: 0x7fff1338 (8 bytes)</div>
                <div style="color: var(--accent-blue); margin-top: 1.5rem; padding: 1rem; background: rgba(88, 166, 255, 0.1); border-radius: 8px;">
                    ✅ Total stack usage: 268 bytes<br>
                    ⚡ Allocation time: &lt; 1 nanosecond<br>
                    🗑️ Automatic cleanup on function exit
                </div>
            `;
        }

        function runHeapDemo() {
            const output = document.getElementById('demoOutput');
            output.innerHTML = `
                <div style="color: var(--accent-orange); font-weight: 600; margin-bottom: 1rem;">🏗️ Heap Allocation Demo</div>
                <div style="margin: 0.5rem 0;">Allocating dynamic memory...</div>
                <div style="margin: 0.5rem 0;">int* array = new int[1000]; // Heap: 0x1a2b3c4d (4000 bytes)</div>
                <div style="margin: 0.5rem 0;">std::string* str = new std::string("Hello"); // Heap: 0x2b3c4d5e</div>
                <div style="margin: 0.5rem 0;">Vector* vec = new Vector(100); // Heap: 0x3c4d5e6f</div>
                <div style="color: var(--accent-blue); margin-top: 1.5rem; padding: 1rem; background: rgba(247, 129, 102, 0.1); border-radius: 8px;">
                    📊 Total heap usage: ~4100 bytes<br>
                    🐌 Allocation time: ~50 microseconds<br>
                    ⚠️ Manual cleanup required: delete[] array; delete str; delete vec;
                </div>
            `;
        }

        function runComparisonDemo() {
            const output = document.getElementById('demoOutput');
            output.innerHTML = `
                <div style="color: var(--accent-purple); font-weight: 600; margin-bottom: 1rem;">📊 Performance Comparison</div>
                <div style="margin: 1rem 0;">Running 1,000,000 allocations...</div>
                <div style="margin: 1rem 0;">
                    <div style="display: flex; justify-content: space-between; margin: 0.8rem 0; padding: 0.5rem 0; border-bottom: 1px solid var(--border-color);">
                        <span>Stack int allocation:</span>
                        <span style="color: var(--accent-green); font-weight: 600;">0.001ms</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin: 0.8rem 0; padding: 0.5rem 0; border-bottom: 1px solid var(--border-color);">
                        <span>Heap int allocation:</span>
                        <span style="color: var(--accent-red); font-weight: 600;">47.3ms</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin: 0.8rem 0; padding: 0.5rem 0; border-bottom: 1px solid var(--border-color);">
                        <span>Memory access (stack):</span>
                        <span style="color: var(--accent-green); font-weight: 600;">2.1ms</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin: 0.8rem 0; padding: 0.5rem 0;">
                        <span>Memory access (heap):</span>
                        <span style="color: var(--accent-orange); font-weight: 600;">15.7ms</span>
                    </div>
                </div>
                <div style="color: var(--accent-blue); margin-top: 1.5rem; padding: 1rem; background: rgba(88, 166, 255, 0.1); border-radius: 8px; font-weight: 600;">
                    📈 Result: Stack allocation is ~47,300x faster than heap allocation!
                </div>
            `;
        }

        function clearDemo() {
            const output = document.getElementById('demoOutput');
            output.innerHTML = `
                <div style="color: var(--text-muted); text-align: center; padding: 2rem;">
                    Click a demo button to start exploring memory allocation patterns...
                </div>
            `;
        }

        // Code copy functionality
        function copyCode(button) {
            const codeBlock = button.closest('.code-title').nextElementSibling.querySelector('code');
            const text = codeBlock.textContent;
            
            navigator.clipboard.writeText(text).then(() => {
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.style.background = 'var(--accent-green)';
                button.style.color = 'var(--primary-bg)';
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = 'transparent';
                    button.style.color = 'var(--text-muted)';
                }, 2000);
            }).catch(() => {
                showNotification('Failed to copy code', 'error');
            });
        }

        // Notification system
        function showNotification(message, type = 'success') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type} show`;
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        // Smooth scrolling for navigation links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Initialize page
        function initializePage() {
            updateStackVisual();
            updateHeapVisual();
            updateProgressBar();
            updateActiveNavigation();
            
            // Add fade-in animation to cards
            const cards = document.querySelectorAll('.card');
            cards.forEach((card, index) => {
                setTimeout(() => {
                    card.classList.add('fade-in');
                }, index * 100);
            });
        }

        // Initialize when page loads
        window.addEventListener('load', initializePage);
        
        // Handle resize
        window.addEventListener('resize', () => {
            updateHeapVisual();
        });
    </script>
</body>
</html>