<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-2RQWYRT51K"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-2RQWYRT51K');
    </script>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rover | Memory Patterns</title>
    
    <style>
        /* ==================== FONT IMPORT ==================== */
        @import url('https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400;500;600;700&display=swap');

        /* ==================== GLASSMORPHISM THEME ==================== */
        :root {
            /* Pure Black Base */
            --bg-primary: #000000;
            --bg-secondary: #0a0a0a;
            
            /* Glass Effect Colors */
            --glass-white: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-highlight: rgba(255, 255, 255, 0.15);
            
            /* McLaren Orange */
            --mclaren-orange: #FF8000;
            --mclaren-glow: rgba(255, 128, 0, 0.3);
            --mclaren-light: #FFA040;
            --mclaren-dark: #CC6600;
            
            /* RedBull Red */
            --redbull-red: #DC0000;
            --redbull-blue: #1E41FF;
            --redbull-glow: rgba(220, 0, 0, 0.3);
            --redbull-light: #FF3333;
            
            /* Meta Blue */
            --meta-blue: #0081FB;
            --meta-glow: rgba(0, 129, 251, 0.3);
            --meta-light: #33A3FF;
            --meta-dark: #0066CC;
            
            /* Text Colors - Ultra White */
            --text-primary: #FFFFFF;
            --text-secondary: #FFFFFF;
            --text-muted: rgba(255, 255, 255, 0.9);
            --text-dim: rgba(255, 255, 255, 0.7);
            
            /* Code Syntax */
            --code-bg: rgba(20, 20, 20, 0.6);
            --code-keyword: #FF8000;
            --code-function: #0081FB;
            --code-string: #3fb950;
            --code-comment: rgba(255, 255, 255, 0.4);
            --code-number: #DC0000;
            --code-variable: #FFA040;
            
            /* Layout */
            --container-width: 1100px;
            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 2.5rem;
            --spacing-2xl: 3rem;
            
            /* Border Radius */
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-xl: 24px;
            
            /* Animations */
            --transition-fast: 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-normal: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            overflow-x: hidden;
            width: 100%;
        }

        body {
            font-family: 'Quicksand', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #000000;
            color: #FFFFFF;
            line-height: 1.7;
            overflow-x: hidden;
            position: relative;
            font-size: 16px;
            font-weight: 400;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            width: 100%;
            max-width: 100vw;
        }

        h1, h2, h3, h4 {
            font-family: 'Quicksand', sans-serif;
            font-weight: 600;
            letter-spacing: -0.03em;
        }

        code, pre {
            font-family: 'Courier New', monospace;
            font-weight: 400;
        }

        /* Progress Bar */
        #reading-progress {
            position: fixed;
            top: 0;
            left: 0;
            width: 0%;
            height: 3px;
            background: linear-gradient(90deg, var(--mclaren-orange), var(--mclaren-light));
            box-shadow: 0 0 10px var(--mclaren-glow);
            z-index: 9999;
            transition: width 0.1s ease;
        }

        /* Container */
        .container {
            max-width: var(--container-width);
            margin: 0 auto;
            padding: 0 var(--spacing-lg);
            position: relative;
            z-index: 1;
        }

        /* Navigation */
        nav {
            position: sticky;
            top: 0;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(24px) saturate(180%);
            -webkit-backdrop-filter: blur(24px) saturate(180%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.12);
            padding: 0.75rem 0;
            box-shadow: 
                0 1px 3px rgba(0, 0, 0, 0.5),
                0 1px 20px rgba(255, 128, 0, 0.1),
                inset 0 -1px 0 rgba(255, 255, 255, 0.05);
        }

        nav::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, 
                transparent,
                rgba(255, 128, 0, 0.3) 20%,
                rgba(255, 128, 0, 0.5) 50%,
                rgba(255, 128, 0, 0.3) 80%,
                transparent
            );
            opacity: 0.8;
        }

        .nav-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 2rem;
            padding: 0 var(--spacing-lg);
            max-width: var(--container-width);
            margin: 0 auto;
        }

        .nav-logo {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--mclaren-orange);
            text-decoration: none;
            letter-spacing: 0.1em;
        }

        .nav-links {
            display: flex;
            gap: 2rem;
            list-style: none;
        }

        .nav-link {
            color: rgba(255, 255, 255, 0.8);
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            transition: all var(--transition-fast);
            position: relative;
            padding: 0.5rem 0;
        }

        .nav-link:hover {
            color: var(--mclaren-orange);
            text-shadow: 0 0 20px var(--mclaren-glow);
        }

        .nav-link.active::after {
            content: '';
            position: absolute;
            bottom: -3px;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--mclaren-orange);
            box-shadow: 0 0 10px var(--mclaren-glow);
        }

        /* Hero Section */
        .hero {
            padding: var(--spacing-2xl) 0;
            text-align: center;
            position: relative;
            margin-bottom: var(--spacing-xl);
            z-index: 1;
        }

        .hero h1 {
            font-size: 3.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: var(--mclaren-orange);
            background: linear-gradient(135deg, 
                var(--mclaren-orange) 0%, 
                var(--mclaren-light) 50%, 
                var(--mclaren-orange) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: glow 3s ease-in-out infinite;
        }

        @supports not (background-clip: text) {
            .hero h1 {
                color: var(--mclaren-orange) !important;
                -webkit-text-fill-color: var(--mclaren-orange) !important;
            }
        }

        @keyframes glow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }

        .hero p {
            font-size: 1.2rem;
            color: var(--text-muted);
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.8;
        }

        /* Sections */
        .section {
            margin-bottom: var(--spacing-2xl);
            opacity: 0;
            transform: translateY(30px);
            transition: all 0.8s ease;
        }

        .section.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .section-header {
            border-bottom: 1px solid var(--glass-border);
            padding-bottom: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
        }

        .section-title {
            font-size: 2.2rem;
            color: var(--text-primary);
            margin-bottom: 0.75rem;
            font-weight: 700;
        }

        .section-subtitle {
            color: var(--text-muted);
            font-size: 1.1rem;
        }

        /* Content Block */
        .content-block {
            background: var(--glass-white);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            padding: var(--spacing-lg);
            margin: var(--spacing-md) 0;
        }

        .content-block h3 {
            font-size: 1.7rem;
            margin-bottom: var(--spacing-md);
            color: var(--text-primary);
            font-weight: 600;
        }

        .content-block h4 {
            font-size: 1.35rem;
            margin: var(--spacing-md) 0 var(--spacing-sm) 0;
            color: var(--mclaren-light);
            font-weight: 600;
        }

        .content-block p {
            margin: var(--spacing-sm) 0;
            line-height: 1.8;
            font-size: 1.05rem;
        }

        .content-block ul, .content-block ol {
            margin-left: var(--spacing-lg);
            margin-top: var(--spacing-sm);
            margin-bottom: var(--spacing-sm);
        }

        .content-block li {
            margin: 0.5rem 0;
            line-height: 1.8;
        }

        /* Code Blocks */
        .code-block {
            background: linear-gradient(135deg, rgba(20, 20, 20, 0.8), rgba(10, 10, 10, 0.9));
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            padding: var(--spacing-md);
            margin: var(--spacing-md) 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            position: relative;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: all var(--transition-normal);
        }

        .code-block:hover {
            border-color: rgba(255, 128, 0, 0.3);
            box-shadow: 0 6px 20px rgba(255, 128, 0, 0.15);
        }

        .code-block pre {
            margin: 0;
            white-space: pre;
        }

        .code-block code {
            color: var(--text-primary);
        }

        /* Syntax Highlighting */
        .keyword {
            color: var(--code-keyword);
            font-weight: 600;
        }

        .function {
            color: var(--code-function);
        }

        .string {
            color: var(--code-string);
        }

        .comment {
            color: var(--code-comment);
            font-style: italic;
        }

        .number {
            color: var(--code-number);
        }

        .variable {
            color: var(--code-variable);
        }

        /* Interactive Demo */
        .interactive-demo {
            background: var(--glass-white);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            padding: var(--spacing-lg);
            margin: var(--spacing-md) 0;
        }

        .demo-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: var(--spacing-md);
            flex-wrap: wrap;
            align-items: center;
        }

        .control-button {
            background: linear-gradient(135deg, var(--mclaren-orange), var(--mclaren-light));
            color: white;
            border: none;
            padding: 0.5rem 1.25rem;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: 0.95rem;
            font-family: 'Quicksand', sans-serif;
            font-weight: 600;
            transition: all var(--transition-fast);
            box-shadow: 0 4px 12px var(--mclaren-glow);
        }

        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px var(--mclaren-glow);
        }

        .control-button:disabled {
            background: var(--glass-white);
            color: var(--text-dim);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .demo-output {
            background: var(--code-bg);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-sm);
            padding: var(--spacing-md);
            margin-top: var(--spacing-md);
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            max-height: 400px;
            overflow-y: auto;
        }

        input[type="number"], input[type="text"], select {
            padding: 0.5rem;
            background: var(--code-bg);
            border: 1px solid var(--glass-border);
            color: white;
            border-radius: var(--radius-sm);
            font-family: 'Quicksand', sans-serif;
        }

        /* Feynman Deep Dive */
        .feynman-dive {
            background: linear-gradient(135deg, 
                rgba(255, 128, 0, 0.03), 
                rgba(255, 128, 0, 0.01));
            border: 1px solid rgba(255, 128, 0, 0.2);
            border-left: 4px solid var(--mclaren-orange);
            border-radius: var(--radius-md);
            padding: var(--spacing-lg);
            margin: var(--spacing-lg) 0;
            position: relative;
        }

        .feynman-dive h3 {
            color: var(--mclaren-orange);
            font-size: 1.8rem;
            margin-bottom: var(--spacing-md);
            font-weight: 700;
        }

        .feynman-dive h4 {
            color: var(--mclaren-light);
            font-size: 1.3rem;
            margin: var(--spacing-md) 0 var(--spacing-sm) 0;
            font-weight: 600;
        }

        /* Callout Boxes */
        .callout {
            border-left: 4px solid var(--mclaren-orange);
            background: rgba(255, 128, 0, 0.1);
            padding: var(--spacing-md);
            margin: var(--spacing-md) 0;
            border-radius: var(--radius-sm);
        }

        .callout-title {
            font-weight: 700;
            color: var(--mclaren-orange);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }

        .callout.warning {
            border-left-color: var(--redbull-red);
            background: rgba(220, 0, 0, 0.1);
        }

        .callout.warning .callout-title {
            color: var(--redbull-red);
        }

        .callout.success {
            border-left-color: #3fb950;
            background: rgba(63, 185, 80, 0.1);
        }

        .callout.success .callout-title {
            color: #3fb950;
        }

        /* Memory Visualization */
        .memory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 4px;
            padding: var(--spacing-md);
            background: var(--code-bg);
            border-radius: var(--radius-sm);
            margin: var(--spacing-md) 0;
        }

        .memory-cell {
            background: var(--glass-white);
            border: 1px solid var(--glass-border);
            padding: 8px;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            border-radius: 4px;
            transition: all var(--transition-fast);
            cursor: pointer;
        }

        .memory-cell:hover {
            background: rgba(255, 128, 0, 0.2);
            border-color: var(--mclaren-orange);
            transform: scale(1.1);
        }

        .memory-cell.active {
            background: var(--mclaren-orange);
            color: #000;
            font-weight: bold;
        }

        .memory-cell.cached {
            background: var(--meta-blue);
            color: white;
        }

        .memory-cell.miss {
            background: var(--redbull-red);
            color: white;
        }

        /* Footer */
        footer {
            background: var(--glass-white);
            padding: var(--spacing-xl) 0;
            margin-top: var(--spacing-2xl);
            text-align: center;
            color: var(--text-muted);
            border-top: 1px solid var(--glass-border);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .hero h1 {
                font-size: 2.5rem;
            }
            
            .section-title {
                font-size: 1.8rem;
            }
            
            .nav-links {
                display: none;
            }
            
            .content-block {
                padding: var(--spacing-md);
            }
            
            .demo-controls {
                flex-direction: column;
                align-items: stretch;
            }
        }
    </style>
</head>
<body>
    <!-- Progress Bar -->
    <div id="reading-progress"></div>
    
    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="#" class="nav-logo">ROVER</a>
            <ul class="nav-links" id="navLinks">
                <li><a href="#intro" class="nav-link active">Introduction</a></li>
                <li><a href="#stack-heap" class="nav-link">Stack vs Heap</a></li>
                <li><a href="#cache" class="nav-link">Cache Patterns</a></li>
                <li><a href="#allocation" class="nav-link">Allocation</a></li>
                <li><a href="#optimization" class="nav-link">Optimization</a></li>
            </ul>
                    <button class="hamburger-menu" id="hamburgerMenu" aria-label="Toggle navigation menu">
                <span class="hamburger-line"></span>
                <span class="hamburger-line"></span>
                <span class="hamburger-line"></span>
            </button>
        </div>
    </nav>
    
    <!-- Hero Section -->
    <section class="hero">
        <div class="container">
            <h1>Memory Patterns & Optimization</h1>
            <p>Master advanced memory management techniques, understand cache-friendly patterns, and optimize your programs for peak performance.</p>
        </div>
    </section>

    <main class="container">
        <!-- Introduction Section -->
        <article id="intro" class="section">
            <div class="section-header">
                <h2 class="section-title">Understanding Memory Patterns</h2>
                <p class="section-subtitle">From fundamentals to advanced optimization</p>
            </div>
            
            <div class="content-block">
                <h3>The Memory Hierarchy Revisited</h3>
                <p>Every memory access pattern you write directly impacts your program's performance. Understanding how memory works at the hardware level is crucial for writing efficient code.</p>
                
                <div style="margin-top: 1rem; padding: 1rem; background: rgba(0, 129, 251, 0.05); border-left: 3px solid var(--meta-blue);">
                    <p><strong>Key Performance Principles:</strong></p>
                    <ul style="margin: 0.5rem 0 0 1.5rem;">
                        <li><strong>Spatial Locality:</strong> Access data that is physically close together</li>
                        <li><strong>Temporal Locality:</strong> Reuse recently accessed data</li>
                        <li><strong>Cache Line Efficiency:</strong> Utilize full 64-byte cache lines</li>
                        <li><strong>Memory Alignment:</strong> Align data to natural boundaries</li>
                    </ul>
                </div>
            </div>
            
            <!-- Feynman-Style Deep Dive -->
            <div class="feynman-dive">
                <h3>Feynman's Approach: Why Memory Patterns Matter</h3>
                <div class="feynman-content">
                    <p class="feynman-intro">
                        If you can't explain why row-major traversal is faster than column-major traversal, you don't understand memory. Let's build this understanding from first principles.
                    </p>
                    
                    <h4>The Physical Reality of Memory</h4>
                    <p>
                        Modern RAM is organized in a hierarchy of rows and columns. When you access one byte, the memory controller actually fetches an entire row into the row buffer. This is why sequential access is fast - subsequent accesses hit the already-activated row.
                    </p>
                    
                    <div style="margin-top: 1rem; padding: 1rem; background: rgba(255, 128, 0, 0.05); border-left: 3px solid var(--mclaren-orange);">
                        <p><strong>DRAM Access Breakdown:</strong></p>
                        <ol style="margin: 0.5rem 0 0 1.5rem;">
                            <li>Row activation (RAS): ~15ns - Open the row</li>
                            <li>Column selection (CAS): ~15ns - Select column</li>
                            <li>Data transfer: ~5ns - Send data to CPU</li>
                            <li>Precharge: ~15ns - Close row for next access</li>
                        </ol>
                        <p style="margin-top: 0.5rem;">Total: ~50ns for random access, but only ~5ns if row is already open!</p>
                    </div>
                </div>
            </div>
        </article>

        <!-- Stack vs Heap Section -->
        <article id="stack-heap" class="section">
            <div class="section-header">
                <h2 class="section-title">Stack vs Heap Memory</h2>
                <p class="section-subtitle">Understanding allocation strategies</p>
            </div>
            
            <div class="content-block">
                <h3>Stack Memory: Fast and Automatic</h3>
                <p>Stack memory is a LIFO (Last In, First Out) structure that stores local variables and function call information. It's extremely fast because allocation is just moving a pointer.</p>
                
                <div class="code-block">
                    <pre><code><span class="keyword">void</span> <span class="function">example</span>() {
    <span class="keyword">int</span> <span class="variable">x</span> = <span class="number">42</span>;        <span class="comment">// Stack allocation - automatic</span>
    <span class="keyword">char</span> <span class="variable">buffer</span>[<span class="number">256</span>];   <span class="comment">// Stack allocation - fixed size</span>
    
    <span class="comment">// When function ends, all stack memory is automatically freed</span>
    <span class="comment">// Just move stack pointer back - O(1) deallocation!</span>
}</code></pre>
                </div>
                
                <h4>Stack Characteristics</h4>
                <ul>
                    <li><strong>Speed:</strong> Allocation/deallocation is O(1) - just move pointer</li>
                    <li><strong>Size:</strong> Limited (typically 1-8MB on modern systems)</li>
                    <li><strong>Lifetime:</strong> Automatic - tied to scope</li>
                    <li><strong>Access:</strong> Excellent cache locality - contiguous memory</li>
                    <li><strong>Thread Safety:</strong> Each thread has its own stack</li>
                </ul>
            </div>
            
            <div class="content-block">
                <h3>Heap Memory: Flexible but Slower</h3>
                <p>Heap memory allows dynamic allocation of arbitrary sizes at runtime, but requires explicit management and has overhead.</p>
                
                <div class="code-block">
                    <pre><code><span class="keyword">void</span> <span class="function">heapExample</span>() {
    <span class="comment">// Heap allocation - manual management required</span>
    <span class="keyword">int</span>* <span class="variable">array</span> = <span class="function">malloc</span>(<span class="number">1000</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));
    
    <span class="comment">// Must manually free when done</span>
    <span class="function">free</span>(<span class="variable">array</span>);
    
    <span class="comment">// Allocation involves:</span>
    <span class="comment">// 1. Finding suitable free block (O(n) worst case)</span>
    <span class="comment">// 2. Possibly splitting blocks</span>
    <span class="comment">// 3. Updating free list metadata</span>
}</code></pre>
                </div>
                
                <div style="margin-top: 1rem; padding: 1rem; background: rgba(220, 0, 0, 0.05); border-left: 3px solid var(--redbull-red);">
                    <p><strong>Heap Allocation Overhead:</strong></p>
                    <ul style="margin: 0.5rem 0 0 1.5rem;">
                        <li>Metadata: 8-16 bytes per allocation for size/status</li>
                        <li>Alignment: Rounded up to 8/16 byte boundaries</li>
                        <li>Fragmentation: Wasted space between allocations</li>
                        <li>Thread synchronization: Locks for thread-safe allocation</li>
                    </ul>
                </div>
            </div>

            <!-- Interactive Stack/Heap Visualizer -->
            <div class="interactive-demo">
                <h3>Interactive Stack/Heap Visualizer</h3>
                <p>Watch how stack and heap memory are allocated and freed in real-time.</p>
                
                <div class="demo-controls">
                    <button class="control-button" onclick="stackHeapDemo.pushStack()">Push to Stack</button>
                    <button class="control-button" onclick="stackHeapDemo.popStack()">Pop from Stack</button>
                    <button class="control-button" onclick="stackHeapDemo.allocateHeap()">Allocate Heap</button>
                    <button class="control-button" onclick="stackHeapDemo.freeHeap()">Free Heap</button>
                    <button class="control-button" onclick="stackHeapDemo.reset()">Reset</button>
                </div>
                
                <div class="memory-visualization" style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-top: 1rem;">
                    <div>
                        <h4 style="color: var(--meta-blue);">Stack Memory</h4>
                        <div id="stack-visual" class="memory-grid">
                            <!-- Stack visualization will be populated by JavaScript -->
                        </div>
                        <div id="stack-pointer" style="margin-top: 0.5rem; font-family: monospace;">
                            Stack Pointer: 0x7FFF0000
                        </div>
                    </div>
                    <div>
                        <h4 style="color: var(--mclaren-orange);">Heap Memory</h4>
                        <div id="heap-visual" class="memory-grid">
                            <!-- Heap visualization will be populated by JavaScript -->
                        </div>
                        <div id="heap-stats" style="margin-top: 0.5rem; font-family: monospace;">
                            Allocated: 0 bytes | Free: 1024 bytes
                        </div>
                    </div>
                </div>
                
                <div id="stack-heap-trace" class="demo-output" style="margin-top: 1rem;">
                    <div style="font-weight: 600; color: var(--mclaren-orange);">OPERATION TRACE:</div>
                    <!-- Trace log will appear here -->
                </div>
            </div>
        </article>

        <!-- Cache Optimization Section -->
        <article id="cache" class="section">
            <div class="section-header">
                <h2 class="section-title">Cache-Friendly Programming</h2>
                <p class="section-subtitle">Optimizing for the memory hierarchy</p>
            </div>
            
            <div class="content-block">
                <h3>Understanding Cache Lines</h3>
                <p>Modern CPUs fetch data in 64-byte chunks called cache lines. Accessing data sequentially within a cache line is essentially free after the initial fetch.</p>
                
                <div class="callout">
                    <div class="callout-title">Key Insight</div>
                    <p>When you access array[0], the CPU loads array[0] through array[15] (assuming 4-byte integers). Use this to your advantage!</p>
                </div>
                
                <h4>Row-Major vs Column-Major Traversal</h4>
                <div class="code-block">
                    <pre><code><span class="comment">// Row-major traversal (cache-friendly)</span>
<span class="keyword">for</span> (<span class="keyword">int</span> <span class="variable">i</span> = <span class="number">0</span>; i < rows; i++) {
    <span class="keyword">for</span> (<span class="keyword">int</span> <span class="variable">j</span> = <span class="number">0</span>; j < cols; j++) {
        <span class="variable">sum</span> += <span class="variable">matrix</span>[i][j];  <span class="comment">// Sequential access</span>
    }
}

<span class="comment">// Column-major traversal (cache-unfriendly)</span>
<span class="keyword">for</span> (<span class="keyword">int</span> <span class="variable">j</span> = <span class="number">0</span>; j < cols; j++) {
    <span class="keyword">for</span> (<span class="keyword">int</span> <span class="variable">i</span> = <span class="number">0</span>; i < rows; i++) {
        <span class="variable">sum</span> += <span class="variable">matrix</span>[i][j];  <span class="comment">// Jumps rows - cache misses!</span>
    }
}</code></pre>
                </div>
                
                <div style="margin-top: 1rem; padding: 1rem; background: rgba(63, 185, 80, 0.05); border-left: 3px solid #3fb950;">
                    <p><strong>Performance Impact:</strong></p>
                    <p>Row-major: ~95% cache hit rate → 5ns average access</p>
                    <p>Column-major: ~5% cache hit rate → 95ns average access</p>
                    <p style="margin-top: 0.5rem; font-weight: 600;">Result: 19x performance difference for the same algorithm!</p>
                </div>
            </div>

            <!-- Cache Simulator -->
            <div class="interactive-demo">
                <h3>Cache Access Pattern Simulator</h3>
                <p>Visualize how different access patterns affect cache performance.</p>
                
                <div class="demo-controls">
                    <select id="access-pattern" style="padding: 0.5rem; margin-right: 1rem;">
                        <option value="sequential">Sequential Access</option>
                        <option value="stride">Strided Access</option>
                        <option value="random">Random Access</option>
                        <option value="row-major">Row-Major Matrix</option>
                        <option value="column-major">Column-Major Matrix</option>
                    </select>
                    <button class="control-button" onclick="cacheDemo.simulate()">Simulate Access</button>
                    <button class="control-button" onclick="cacheDemo.reset()">Reset</button>
                </div>
                
                <div style="margin-top: 1rem;">
                    <div class="memory-grid" id="cache-memory">
                        <!-- Memory cells will be populated by JavaScript -->
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-top: 1rem;">
                    <div style="text-align: center; padding: 1rem; background: var(--glass-white); border-radius: var(--radius-sm);">
                        <div style="font-size: 2rem; font-weight: bold; color: #3fb950;">
                            <span id="cache-hits">0</span>
                        </div>
                        <div style="color: var(--text-muted);">Cache Hits</div>
                    </div>
                    <div style="text-align: center; padding: 1rem; background: var(--glass-white); border-radius: var(--radius-sm);">
                        <div style="font-size: 2rem; font-weight: bold; color: var(--redbull-red);">
                            <span id="cache-misses">0</span>
                        </div>
                        <div style="color: var(--text-muted);">Cache Misses</div>
                    </div>
                    <div style="text-align: center; padding: 1rem; background: var(--glass-white); border-radius: var(--radius-sm);">
                        <div style="font-size: 2rem; font-weight: bold; color: var(--mclaren-orange);">
                            <span id="hit-rate">0</span>%
                        </div>
                        <div style="color: var(--text-muted);">Hit Rate</div>
                    </div>
                </div>
                
                <div id="cache-trace" class="demo-output" style="margin-top: 1rem;">
                    <div style="font-weight: 600; color: var(--mclaren-orange);">ACCESS TRACE:</div>
                    <!-- Access pattern trace will appear here -->
                </div>
            </div>
        </article>

        <!-- Memory Allocation Strategies -->
        <article id="allocation" class="section">
            <div class="section-header">
                <h2 class="section-title">Memory Allocation Strategies</h2>
                <p class="section-subtitle">Efficient memory management techniques</p>
            </div>
            
            <div class="content-block">
                <h3>Common Allocation Patterns</h3>
                
                <h4>1. Object Pooling</h4>
                <p>Pre-allocate a pool of objects to avoid repeated allocation/deallocation overhead.</p>
                
                <div class="code-block">
                    <pre><code><span class="keyword">typedef struct</span> {
    <span class="keyword">void</span>* <span class="variable">pool</span>;
    <span class="keyword">size_t</span> <span class="variable">object_size</span>;
    <span class="keyword">size_t</span> <span class="variable">pool_size</span>;
    <span class="keyword">void</span>** <span class="variable">free_list</span>;
    <span class="keyword">int</span> <span class="variable">free_count</span>;
} <span class="variable">ObjectPool</span>;

<span class="comment">// Allocate from pool - O(1)</span>
<span class="keyword">void</span>* <span class="function">pool_alloc</span>(<span class="variable">ObjectPool</span>* <span class="variable">pool</span>) {
    <span class="keyword">if</span> (<span class="variable">pool</span>-><span class="variable">free_count</span> > <span class="number">0</span>) {
        <span class="keyword">return</span> <span class="variable">pool</span>-><span class="variable">free_list</span>[--<span class="variable">pool</span>-><span class="variable">free_count</span>];
    }
    <span class="keyword">return</span> <span class="keyword">NULL</span>; <span class="comment">// Pool exhausted</span>
}</code></pre>
                </div>
                
                <h4>2. Arena/Region Allocation</h4>
                <p>Allocate from a large chunk and free everything at once.</p>
                
                <div class="code-block">
                    <pre><code><span class="keyword">typedef struct</span> {
    <span class="keyword">char</span>* <span class="variable">memory</span>;
    <span class="keyword">size_t</span> <span class="variable">size</span>;
    <span class="keyword">size_t</span> <span class="variable">used</span>;
} <span class="variable">Arena</span>;

<span class="comment">// Super fast allocation - just bump pointer</span>
<span class="keyword">void</span>* <span class="function">arena_alloc</span>(<span class="variable">Arena</span>* <span class="variable">arena</span>, <span class="keyword">size_t</span> <span class="variable">size</span>) {
    <span class="keyword">if</span> (<span class="variable">arena</span>-><span class="variable">used</span> + <span class="variable">size</span> <= <span class="variable">arena</span>-><span class="variable">size</span>) {
        <span class="keyword">void</span>* <span class="variable">ptr</span> = <span class="variable">arena</span>-><span class="variable">memory</span> + <span class="variable">arena</span>-><span class="variable">used</span>;
        <span class="variable">arena</span>-><span class="variable">used</span> += <span class="variable">size</span>;
        <span class="keyword">return</span> <span class="variable">ptr</span>;
    }
    <span class="keyword">return</span> <span class="keyword">NULL</span>;
}

<span class="comment">// Free everything at once - O(1)</span>
<span class="keyword">void</span> <span class="function">arena_reset</span>(<span class="variable">Arena</span>* <span class="variable">arena</span>) {
    <span class="variable">arena</span>-><span class="variable">used</span> = <span class="number">0</span>;
}</code></pre>
                </div>
            </div>
        </article>

        <!-- Optimization Techniques -->
        <article id="optimization" class="section">
            <div class="section-header">
                <h2 class="section-title">Memory Optimization Techniques</h2>
                <p class="section-subtitle">Advanced patterns for peak performance</p>
            </div>
            
            <div class="content-block">
                <h3>Data Structure Optimization</h3>
                
                <h4>Structure Packing and Padding</h4>
                <div class="code-block">
                    <pre><code><span class="comment">// Poorly aligned struct - 24 bytes due to padding</span>
<span class="keyword">struct</span> <span class="variable">BadLayout</span> {
    <span class="keyword">char</span> <span class="variable">a</span>;     <span class="comment">// 1 byte + 7 padding</span>
    <span class="keyword">double</span> <span class="variable">b</span>;  <span class="comment">// 8 bytes</span>
    <span class="keyword">char</span> <span class="variable">c</span>;     <span class="comment">// 1 byte + 7 padding</span>
};

<span class="comment">// Well aligned struct - 16 bytes</span>
<span class="keyword">struct</span> <span class="variable">GoodLayout</span> {
    <span class="keyword">double</span> <span class="variable">b</span>;  <span class="comment">// 8 bytes</span>
    <span class="keyword">char</span> <span class="variable">a</span>;     <span class="comment">// 1 byte</span>
    <span class="keyword">char</span> <span class="variable">c</span>;     <span class="comment">// 1 byte + 6 padding</span>
};</code></pre>
                </div>
                
                <h4>Hot/Cold Data Separation</h4>
                <p>Group frequently accessed data together to improve cache utilization.</p>
                
                <div class="code-block">
                    <pre><code><span class="comment">// Separate hot (frequently accessed) and cold (rarely accessed) data</span>
<span class="keyword">struct</span> <span class="variable">GameObject</span> {
    <span class="comment">// Hot data - accessed every frame</span>
    <span class="variable">Vector3</span> <span class="variable">position</span>;
    <span class="variable">Vector3</span> <span class="variable">velocity</span>;
    <span class="keyword">float</span> <span class="variable">health</span>;
    
    <span class="comment">// Cold data - rarely accessed</span>
    <span class="keyword">char</span> <span class="variable">name</span>[<span class="number">64</span>];
    <span class="keyword">char</span> <span class="variable">description</span>[<span class="number">256</span>];
    <span class="variable">Texture</span>* <span class="variable">icon</span>;
};</code></pre>
                </div>
                
                <div class="callout success">
                    <div class="callout-title">Performance Tip</div>
                    <p>Consider using Structure of Arrays (SoA) instead of Array of Structures (AoS) for better vectorization and cache utilization in performance-critical code.</p>
                </div>
            </div>
            
            <!-- Memory Optimization Checklist -->
            <div class="content-block">
                <h3>Memory Optimization Checklist</h3>
                <ul style="line-height: 2;">
                    <li>✓ Minimize cache misses through sequential access patterns</li>
                    <li>✓ Align data structures to cache line boundaries (64 bytes)</li>
                    <li>✓ Use stack allocation when possible (faster than heap)</li>
                    <li>✓ Pool frequently allocated/deallocated objects</li>
                    <li>✓ Pack structures to minimize padding waste</li>
                    <li>✓ Separate hot and cold data</li>
                    <li>✓ Consider arena allocation for temporary data</li>
                    <li>✓ Profile memory access patterns with tools like perf/VTune</li>
                    <li>✓ Prefetch data when access patterns are predictable</li>
                    <li>✓ Use memory-mapped files for large datasets</li>
                </ul>
            </div>
        </article>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2025 ROVER. Master Data Structures & Algorithms from the ground up.</p>
        </div>
    </footer>

    <!-- JavaScript for Interactive Features -->
    <script>
        // Reading Progress Bar
        window.addEventListener('scroll', () => {
            const windowHeight = window.innerHeight;
            const documentHeight = document.documentElement.scrollHeight - windowHeight;
            const scrolled = window.scrollY;
            const progress = (scrolled / documentHeight) * 100;
            document.getElementById('reading-progress').style.width = progress + '%';
        });

        // Intersection Observer for Fade-in Sections
        const sections = document.querySelectorAll('.section');
        const observerOptions = {
            threshold: 0.1,
            rootMargin: '0px 0px -100px 0px'
        };

        const sectionObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('visible');
                }
            });
        }, observerOptions);

        sections.forEach(section => {
            sectionObserver.observe(section);
        });

        // Active Navigation Link
        window.addEventListener('scroll', () => {
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.clientHeight;
                if (window.scrollY >= sectionTop - 200) {
                    current = section.getAttribute('id');
                }
            });

            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        });

        // Stack/Heap Demo with Enhanced Step Trace
        const stackHeapDemo = {
            stack: [],
            heap: {},
            heapCounter: 0,
            traceLog: [],
            
            addTrace(operation, detail) {
                const timestamp = new Date().toLocaleTimeString();
                this.traceLog.unshift({operation, detail, timestamp});
                if (this.traceLog.length > 10) this.traceLog.pop();
                this.updateTraceDisplay();
            },
            
            updateTraceDisplay() {
                const traceElement = document.getElementById('stack-heap-trace');
                if (traceElement) {
                    const existingTitle = traceElement.querySelector('div:first-child');
                    const titleHtml = existingTitle ? existingTitle.outerHTML : '<div style="font-weight: 600; color: var(--mclaren-orange);">OPERATION TRACE:</div>';
                    
                    traceElement.innerHTML = titleHtml + 
                        this.traceLog.map(entry => `
                            <div style="padding: 0.25rem; margin: 0.25rem 0; background: rgba(255, 255, 255, 0.02); border-left: 2px solid var(--meta-blue); font-size: 0.85rem;">
                                <span style="color: var(--text-dim);">[${entry.timestamp}]</span> 
                                <strong>${entry.operation}:</strong> ${entry.detail}
                            </div>
                        `).join('');
                }
            },
            
            pushStack() {
                const value = Math.floor(Math.random() * 100);
                this.stack.push(value);
                this.addTrace('Stack Push', `Pushed value ${value} to stack. Stack size: ${this.stack.length}. Stack grows downward in memory.`);
                this.render();
            },
            
            popStack() {
                if (this.stack.length > 0) {
                    const value = this.stack.pop();
                    this.addTrace('Stack Pop', `Popped value ${value} from stack. Stack size: ${this.stack.length}. Memory automatically reclaimed.`);
                } else {
                    this.addTrace('Stack Pop Failed', 'Stack is empty - nothing to pop');
                }
                this.render();
            },
            
            allocateHeap() {
                const size = 8 + Math.floor(Math.random() * 24);
                const id = this.heapCounter++;
                this.heap[id] = {size, data: `Block ${id}`};
                this.addTrace('Heap Allocation', `Allocated ${size} bytes on heap (ID: ${id}). Heap fragmentation may occur.`);
                this.render();
            },
            
            freeHeap() {
                const keys = Object.keys(this.heap);
                if (keys.length > 0) {
                    const id = keys[Math.floor(Math.random() * keys.length)];
                    const block = this.heap[id];
                    delete this.heap[id];
                    this.addTrace('Heap Free', `Freed block ${id} (${block.size} bytes). Memory returned to free list.`);
                } else {
                    this.addTrace('Heap Free Failed', 'No allocated blocks to free');
                }
                this.render();
            },
            
            reset() {
                this.stack = [];
                this.heap = {};
                this.heapCounter = 0;
                this.traceLog = [];
                this.addTrace('Reset', 'Cleared all stack and heap memory');
                this.render();
            },
            
            render() {
                // Render stack
                const stackVisual = document.getElementById('stack-visual');
                if (stackVisual) {
                    stackVisual.innerHTML = '';
                    for (let i = this.stack.length - 1; i >= 0; i--) {
                        const cell = document.createElement('div');
                        cell.className = 'memory-cell active';
                        cell.textContent = this.stack[i];
                        stackVisual.appendChild(cell);
                    }
                }
                
                // Render heap
                const heapVisual = document.getElementById('heap-visual');
                if (heapVisual) {
                    heapVisual.innerHTML = '';
                    Object.entries(this.heap).forEach(([id, block]) => {
                        const cell = document.createElement('div');
                        cell.className = 'memory-cell cached';
                        cell.textContent = `${block.size}B`;
                        cell.title = block.data;
                        heapVisual.appendChild(cell);
                    });
                }
                
                // Update stats
                const stackPointer = document.getElementById('stack-pointer');
                if (stackPointer) {
                    const addr = (0x7FFF0000 - this.stack.length * 4).toString(16).toUpperCase();
                    stackPointer.textContent = `Stack Pointer: 0x${addr}`;
                }
                
                const heapStats = document.getElementById('heap-stats');
                if (heapStats) {
                    const allocated = Object.values(this.heap).reduce((sum, block) => sum + block.size, 0);
                    heapStats.textContent = `Allocated: ${allocated} bytes | Free: ${1024 - allocated} bytes`;
                }
            },
            
            init() {
                this.addTrace('Initialization', 'Stack/Heap demo initialized. Stack grows down, heap grows up.');
                this.render();
            }
        };

        // Cache Demo with Enhanced Step Trace
        const cacheDemo = {
            memory: [],
            cacheLines: [],
            hits: 0,
            misses: 0,
            traceLog: [],
            
            init() {
                // Initialize 256 bytes of memory (4 cache lines of 64 bytes each)
                this.memory = Array(64).fill(0).map((_, i) => i);
                this.addTrace('Cache Demo Initialized', '64 memory cells, 64-byte cache lines');
                this.render();
            },
            
            addTrace(operation, detail) {
                const timestamp = new Date().toLocaleTimeString();
                this.traceLog.unshift({operation, detail, timestamp});
                if (this.traceLog.length > 10) this.traceLog.pop();
                this.updateTraceDisplay();
            },
            
            updateTraceDisplay() {
                const traceElement = document.getElementById('cache-trace');
                if (traceElement) {
                    const existingTitle = traceElement.querySelector('div:first-child');
                    const titleHtml = existingTitle ? existingTitle.outerHTML : '<div style="font-weight: 600; color: var(--mclaren-orange);">ACCESS TRACE:</div>';
                    
                    traceElement.innerHTML = titleHtml +
                        this.traceLog.map(entry => `
                            <div style="padding: 0.25rem; margin: 0.25rem 0; background: rgba(255, 255, 255, 0.02); border-left: 2px solid ${entry.operation.includes('HIT') ? '#3fb950' : 'var(--redbull-red)'}; font-size: 0.85rem;">
                                <span style="color: var(--text-dim);">[${entry.timestamp}]</span> 
                                <strong>${entry.operation}:</strong> ${entry.detail}
                            </div>
                        `).join('');
                }
            },
            
            async simulate() {
                const pattern = document.getElementById('access-pattern').value;
                this.hits = 0;
                this.misses = 0;
                this.cacheLines = [];
                this.traceLog = [];
                
                this.addTrace('Simulation Started', `Pattern: ${pattern}`);
                
                let accessOrder = [];
                
                switch(pattern) {
                    case 'sequential':
                        accessOrder = Array(32).fill(0).map((_, i) => i);
                        break;
                    case 'stride':
                        accessOrder = Array(16).fill(0).map((_, i) => i * 4);
                        break;
                    case 'random':
                        accessOrder = Array(32).fill(0).map(() => Math.floor(Math.random() * 64));
                        break;
                    case 'row-major':
                        for (let i = 0; i < 8; i++) {
                            for (let j = 0; j < 8; j++) {
                                accessOrder.push(i * 8 + j);
                            }
                        }
                        break;
                    case 'column-major':
                        for (let j = 0; j < 8; j++) {
                            for (let i = 0; i < 8; i++) {
                                accessOrder.push(i * 8 + j);
                            }
                        }
                        break;
                }
                
                for (let i = 0; i < accessOrder.length; i++) {
                    await this.access(accessOrder[i]);
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                const hitRate = this.hits > 0 ? Math.round((this.hits / (this.hits + this.misses)) * 100) : 0;
                this.addTrace('Simulation Complete', `Final hit rate: ${hitRate}%, Hits: ${this.hits}, Misses: ${this.misses}`);
            },
            
            async access(index) {
                const cacheLine = Math.floor(index / 16); // 16 items per cache line
                
                // Clear previous highlights
                document.querySelectorAll('.memory-cell').forEach(cell => {
                    cell.classList.remove('active', 'miss');
                });
                
                // Highlight accessed cell
                const cell = document.querySelector(`#cache-cell-${index}`);
                if (cell) {
                    if (this.cacheLines.includes(cacheLine)) {
                        cell.classList.add('cached');
                        this.hits++;
                        this.addTrace('CACHE HIT', `Address ${index} (Line ${cacheLine}) - Data already in cache`);
                    } else {
                        cell.classList.add('miss');
                        this.misses++;
                        this.cacheLines.push(cacheLine);
                        if (this.cacheLines.length > 4) this.cacheLines.shift(); // LRU eviction
                        this.addTrace('CACHE MISS', `Address ${index} (Line ${cacheLine}) - Loading from memory`);
                        
                        // Load entire cache line
                        for (let i = cacheLine * 16; i < (cacheLine + 1) * 16 && i < 64; i++) {
                            const lineCell = document.querySelector(`#cache-cell-${i}`);
                            if (lineCell) lineCell.classList.add('cached');
                        }
                    }
                }
                
                this.updateStats();
            },
            
            updateStats() {
                document.getElementById('cache-hits').textContent = this.hits;
                document.getElementById('cache-misses').textContent = this.misses;
                const hitRate = this.hits > 0 ? Math.round((this.hits / (this.hits + this.misses)) * 100) : 0;
                document.getElementById('hit-rate').textContent = hitRate;
            },
            
            reset() {
                this.hits = 0;
                this.misses = 0;
                this.cacheLines = [];
                this.traceLog = [];
                this.addTrace('Cache Reset', 'Cleared all cache lines and statistics');
                this.render();
                this.updateStats();
            },
            
            render() {
                const container = document.getElementById('cache-memory');
                if (container) {
                    container.innerHTML = this.memory.map((val, i) => 
                        `<div class="memory-cell" id="cache-cell-${i}">${val}</div>`
                    ).join('');
                }
            }
        };

        // Initialize demos

        // Hamburger Menu Toggle
        const hamburgerMenu = document.getElementById('hamburgerMenu');
        const navElement = document.getElementById('navLinks') || document.getElementById('navActions');
        
        if (hamburgerMenu && navElement) {
            hamburgerMenu.addEventListener('click', function() {
                hamburgerMenu.classList.toggle('active');
                navElement.classList.toggle('active');
            });
            
            // Close menu when clicking on a nav link (mobile)
            if (document.getElementById('navLinks')) {
                document.querySelectorAll('.nav-link').forEach(link => {
                    link.addEventListener('click', function() {
                        if (window.innerWidth <= 768) {
                            hamburgerMenu.classList.remove('active');
                            navElement.classList.remove('active');
                        }
                    });
                });
            }
            
            // Close menu when clicking outside
            document.addEventListener('click', function(event) {
                if (window.innerWidth <= 768) {
                    if (!hamburgerMenu.contains(event.target) && !navElement.contains(event.target)) {
                        hamburgerMenu.classList.remove('active');
                        navElement.classList.remove('active');
                    }
                }
            });
        }


                document.addEventListener('DOMContentLoaded', () => {
            stackHeapDemo.init();
            cacheDemo.init();
        });
    </script>
</body>
</html>
