<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rover | Memory-Patterns</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Netflix+Sans:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            /* Modern Color Palette */
            --primary-bg: #0d1117;
            --secondary-bg: #161b22;
            --card-bg: #21262d;
            --border-color: #30363d;
            --text-primary: #f0f6fc;
            --text-muted: #8b949e;
            --text-secondary: #c9d1d9;
            
            /* Accent Colors */
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-orange: #f78166;
            --accent-red: #ff6b6b;
            --accent-purple: #a855f7;
            --accent-cyan: #00d9ff;
            --accent-yellow: #fbbf24;
            
            /* Code Colors */
            --code-bg: #0d1117;
            --code-keyword: #ff7b72;
            --code-function: #d2a8ff;
            --code-string: #a5d6ff;
            --code-comment: #8b949e;
            --code-number: #79c0ff;
            --code-variable: #ffa657;
            
            /* Layout */
            --max-width: 1200px;
            --border-radius: 12px;
            --animation-speed: 0.3s;
            --shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            --shadow-lg: 0 16px 64px rgba(0, 0, 0, 0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Netflix Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--primary-bg);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
        }

        .container {
            max-width: var(--max-width);
            margin: 0 auto;
            padding: 0 2rem;
        }

        /* Navigation */
        nav {
            position: sticky;
            top: 0;
            background: rgba(13, 17, 23, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-color);
            z-index: 100;
            padding: 1rem 0;
        }

        .nav-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .nav-logo {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-blue);
        }

        .nav-links {
            display: flex;
            list-style: none;
            gap: 2rem;
        }

        .nav-links a {
            color: var(--text-muted);
            text-decoration: none;
            font-weight: 500;
            transition: color var(--animation-speed);
            position: relative;
        }

        .nav-links a:hover,
        .nav-links a.active {
            color: var(--accent-blue);
        }

        .nav-links a.active::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--accent-blue);
        }

        /* Progress Bar */
        .progress-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: var(--secondary-bg);
            z-index: 1000;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-cyan), var(--accent-purple));
            width: 0%;
            transition: width 0.1s ease;
        }

        /* Hero Section */
        .hero {
            text-align: center;
            padding: 4rem 0;
            background: linear-gradient(135deg, rgba(0, 217, 255, 0.1), rgba(168, 85, 247, 0.1));
            border-radius: var(--border-radius);
            margin: 2rem 0;
            position: relative;
            overflow: hidden;
        }

        .hero::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 50% 50%, rgba(88, 166, 255, 0.1) 0%, transparent 50%);
            animation: pulse 4s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        .hero h1 {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            position: relative;
            z-index: 1;
        }

        .hero p {
            font-size: 1.2rem;
            color: var(--text-muted);
            max-width: 800px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        /* Cards */
        .card {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 2rem;
            margin: 2rem 0;
            box-shadow: var(--shadow);
            transition: all var(--animation-speed);
        }

        .card:hover {
            transform: translateY(-4px);
            box-shadow: var(--shadow-lg);
            border-color: var(--accent-blue);
        }

        .card-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .card-header .icon {
            font-size: 2rem;
        }

        .card-header h3 {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Interactive Pattern Cards */
        .pattern-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .pattern-card {
            background: linear-gradient(135deg, var(--card-bg), rgba(88, 166, 255, 0.05));
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            cursor: pointer;
            transition: all var(--animation-speed);
            position: relative;
            overflow: hidden;
        }

        .pattern-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(88, 166, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .pattern-card:hover::before {
            left: 100%;
        }

        .pattern-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: var(--shadow-lg);
            border-color: var(--accent-cyan);
        }

        .pattern-card.green { border-left: 4px solid var(--accent-green); }
        .pattern-card.blue { border-left: 4px solid var(--accent-blue); }
        .pattern-card.orange { border-left: 4px solid var(--accent-orange); }
        .pattern-card.purple { border-left: 4px solid var(--accent-purple); }
        .pattern-card.cyan { border-left: 4px solid var(--accent-cyan); }

        .pattern-icon {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            display: block;
        }

        .pattern-title {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .pattern-desc {
            color: var(--text-muted);
            font-size: 0.95rem;
        }

        .pattern-complexity {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-color);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--accent-green);
        }

        /* Code Blocks */
        .code-container {
            margin: 2rem 0;
        }

        .code-title {
            background: var(--secondary-bg);
            color: var(--text-muted);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            padding: 0.8rem 1.5rem;
            border-top-left-radius: var(--border-radius);
            border-top-right-radius: var(--border-radius);
            border: 1px solid var(--border-color);
            border-bottom: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .copy-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-muted);
            padding: 0.3rem 0.8rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all var(--animation-speed);
        }

        .copy-btn:hover {
            background: var(--accent-blue);
            color: var(--primary-bg);
            border-color: var(--accent-blue);
        }

        pre {
            background: var(--code-bg);
            border: 1px solid var(--border-color);
            border-top: none;
            border-bottom-left-radius: var(--border-radius);
            border-bottom-right-radius: var(--border-radius);
            padding: 1.5rem;
            overflow-x: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        /* Syntax Highlighting */
        .keyword { color: var(--code-keyword); font-weight: 500; }
        .function { color: var(--code-function); }
        .string { color: var(--code-string); }
        .comment { color: var(--code-comment); font-style: italic; }
        .number { color: var(--code-number); }
        .variable { color: var(--code-variable); }

        /* Callouts */
        .callout {
            border-left: 4px solid var(--accent-blue);
            background: rgba(88, 166, 255, 0.1);
            padding: 1.5rem;
            margin: 2rem 0;
            border-radius: 0 var(--border-radius) var(--border-radius) 0;
        }

        .callout-title {
            font-weight: 600;
            color: var(--accent-blue);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.8rem;
            font-size: 1.1rem;
        }

        .callout.warning {
            border-left-color: var(--accent-orange);
            background: rgba(247, 129, 102, 0.1);
        }

        .callout.warning .callout-title {
            color: var(--accent-orange);
        }

        .callout.danger {
            border-left-color: var(--accent-red);
            background: rgba(255, 107, 107, 0.1);
        }

        .callout.danger .callout-title {
            color: var(--accent-red);
        }

        .callout.success {
            border-left-color: var(--accent-green);
            background: rgba(63, 185, 80, 0.1);
        }

        .callout.success .callout-title {
            color: var(--accent-green);
        }

        /* Code Explanation Styles */
        .code-explanation {
            background: linear-gradient(135deg, var(--card-bg), rgba(88, 166, 255, 0.05));
            border: 1px solid rgba(88, 166, 255, 0.2);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            margin-top: 1rem;
            transition: all var(--animation-speed);
        }

        .code-explanation:hover {
            border-color: rgba(88, 166, 255, 0.4);
            box-shadow: 0 4px 20px rgba(88, 166, 255, 0.1);
        }

        .explanation-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
            cursor: pointer;
        }

        .explanation-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            color: var(--accent-blue);
            font-size: 1.1rem;
        }

        .explanation-toggle {
            background: var(--accent-blue);
            color: var(--primary-bg);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--animation-speed);
        }

        .explanation-toggle:hover {
            background: #4a9fff;
            transform: scale(1.05);
        }

        .explanation-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out;
        }

        .explanation-content.expanded {
            max-height: 10000px;
        }

        .explanation-section {
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 8px;
            border-left: 3px solid var(--accent-green);
        }

        .explanation-section h4 {
            color: var(--accent-green);
            margin-bottom: 0.8rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1.1rem;
        }

        .line-by-line {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .code-line {
            display: flex;
            margin-bottom: 0.8rem;
            padding: 0.5rem;
            border-radius: 4px;
            transition: background-color 0.2s;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .code-line:hover {
            background: rgba(88, 166, 255, 0.1);
        }

        .line-number {
            color: var(--text-muted);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            min-width: 3rem;
            flex-shrink: 0;
        }

        .line-code {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            color: var(--text-secondary);
            flex: 1;
            min-width: 0;
        }

        .line-explanation {
            color: var(--text-muted);
            font-size: 0.85rem;
            font-style: italic;
            border-left: 2px solid var(--accent-orange);
            padding-left: 0.8rem;
            flex-basis: 100%;
            margin-top: 0.3rem;
        }

        .memory-impact {
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.1), rgba(255, 107, 107, 0.05));
            border: 1px solid rgba(255, 107, 107, 0.3);
            border-radius: 6px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .memory-impact h5 {
            color: var(--accent-red);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .best-practices {
            background: linear-gradient(135deg, rgba(63, 185, 80, 0.1), rgba(63, 185, 80, 0.05));
            border: 1px solid rgba(63, 185, 80, 0.3);
            border-radius: 6px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .best-practices h5 {
            color: var(--accent-green);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .performance-note {
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.1), rgba(168, 85, 247, 0.05));
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 6px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .performance-note h5 {
            color: var(--accent-purple);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Visual Diagrams */
        .visual-diagram {
            background: var(--code-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            margin: 1.5rem 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            line-height: 1.8;
            overflow-x: auto;
        }

        .diagram-title {
            color: var(--accent-cyan);
            font-weight: 600;
            margin-bottom: 1rem;
            font-size: 1rem;
        }

        /* Comparison Table */
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 2rem 0;
            background: var(--card-bg);
            border-radius: var(--border-radius);
            overflow: hidden;
            border: 1px solid var(--border-color);
        }

        .comparison-table th,
        .comparison-table td {
            padding: 1rem 1.5rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        .comparison-table th {
            background: var(--secondary-bg);
            font-weight: 600;
            color: var(--text-primary);
        }

        .comparison-table tr:last-child td {
            border-bottom: none;
        }

        .comparison-table tr:hover {
            background: rgba(88, 166, 255, 0.05);
        }

        .comparison-table .good {
            color: var(--accent-green);
            font-weight: 600;
        }

        .comparison-table .bad {
            color: var(--accent-red);
            font-weight: 600;
        }

        .comparison-table .medium {
            color: var(--accent-orange);
            font-weight: 600;
        }

        /* Interactive Demo */
        .interactive-demo {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 2rem;
            margin: 2rem 0;
            box-shadow: var(--shadow);
        }

        .demo-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .btn {
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            color: var(--primary-bg);
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 8px;
            font-family: inherit;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--animation-speed);
            text-decoration: none;
            display: inline-block;
            text-align: center;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(88, 166, 255, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.green {
            background: linear-gradient(135deg, var(--accent-green), #22c55e);
        }

        .btn.orange {
            background: linear-gradient(135deg, var(--accent-orange), #f97316);
        }

        .btn.red {
            background: linear-gradient(135deg, var(--accent-red), #ef4444);
        }

        .btn.cyan {
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
        }

        .demo-output {
            background: var(--code-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            min-height: 200px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            overflow-y: auto;
        }

        /* Notification */
        .notification {
            position: fixed;
            top: 100px;
            right: 20px;
            background: var(--accent-green);
            color: var(--primary-bg);
            padding: 1rem 1.5rem;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
            z-index: 1000;
            opacity: 0;
            transform: translateX(100%);
            transition: all var(--animation-speed);
            font-weight: 600;
        }

        .notification.show {
            opacity: 1;
            transform: translateX(0);
        }

        /* Animations */
        .fade-in {
            animation: fadeIn 0.6s ease-in-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Section Spacing */
        section {
            margin: 3rem 0;
        }

        section h2 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 2rem;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Feature Lists */
        .feature-list {
            list-style: none;
            padding-left: 0;
        }

        .feature-list li {
            padding: 0.8rem 0;
            position: relative;
            padding-left: 2rem;
            border-bottom: 1px solid var(--border-color);
            transition: all var(--animation-speed);
        }

        .feature-list li:last-child {
            border-bottom: none;
        }

        .feature-list li:hover {
            padding-left: 2.5rem;
            background: rgba(88, 166, 255, 0.05);
            border-radius: 4px;
        }

        .feature-list li::before {
            content: '✓';
            position: absolute;
            left: 0;
            color: var(--accent-green);
            font-weight: bold;
            font-size: 1.2rem;
            transition: all var(--animation-speed);
        }

        .feature-list li:hover::before {
            transform: scale(1.2);
            left: 0.3rem;
        }

        /* Beautiful Bullet Points for Explanations */
        .explanation-content ul {
            list-style: none;
            padding-left: 0;
        }

        .explanation-content ul li {
            position: relative;
            padding-left: 2rem;
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;
            transition: all var(--animation-speed);
        }

        .explanation-content ul li::before {
            content: '▸';
            position: absolute;
            left: 0.5rem;
            color: var(--accent-cyan);
            font-weight: bold;
            font-size: 1.1rem;
        }

        .explanation-content ul li:hover {
            padding-left: 2.3rem;
            color: var(--text-primary);
        }

        /* Enhanced Code Block Styling */
        .code-container {
            position: relative;
            transition: all var(--animation-speed);
        }

        .code-container:hover {
            transform: translateY(-2px);
        }

        /* Responsive Design - Mobile First */
        @media (max-width: 1024px) {
            .container {
                padding: 0 1.5rem;
            }

            .pattern-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .comparison-table {
                font-size: 0.9rem;
            }

            .comparison-table th,
            .comparison-table td {
                padding: 0.8rem 1rem;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 0 1rem;
            }

            .nav-links {
                display: none;
            }

            .nav-logo {
                font-size: 1.2rem;
            }

            .hero {
                padding: 3rem 1rem;
            }

            .hero h1 {
                font-size: 2rem;
            }

            .hero p {
                font-size: 1rem;
                padding: 0 1rem;
            }

            .card {
                padding: 1.5rem;
                margin: 1.5rem 0;
            }

            .card-header {
                flex-direction: column;
                text-align: center;
                gap: 0.5rem;
            }

            .card-header .icon {
                font-size: 2.5rem;
            }

            .pattern-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .pattern-card {
                padding: 1.2rem;
            }

            .pattern-icon {
                font-size: 2rem;
            }

            .pattern-title {
                font-size: 1.1rem;
            }

            .demo-controls {
                flex-direction: column;
            }

            .btn {
                width: 100%;
                padding: 1rem;
                font-size: 1rem;
            }

            .explanation-header {
                flex-direction: column;
                gap: 0.5rem;
                align-items: stretch;
            }

            .explanation-toggle {
                width: 100%;
                padding: 0.8rem;
            }

            .explanation-title {
                justify-content: center;
                text-align: center;
            }

            section h2 {
                font-size: 1.5rem;
                flex-direction: column;
                text-align: center;
            }

            .code-title {
                flex-direction: column;
                gap: 0.5rem;
                text-align: center;
            }

            .copy-btn {
                width: 100%;
            }

            pre {
                font-size: 0.8rem;
                padding: 1rem;
            }

            .visual-diagram {
                font-size: 0.75rem;
                padding: 1rem;
                overflow-x: auto;
            }

            .line-by-line {
                padding: 0.8rem;
            }

            .code-line {
                flex-direction: column;
                padding: 0.8rem 0.5rem;
            }

            .line-number {
                min-width: auto;
                margin-bottom: 0.3rem;
                font-weight: 600;
            }

            .line-code {
                margin-bottom: 0.3rem;
            }

            .line-explanation {
                border-left: none;
                border-top: 2px solid var(--accent-orange);
                padding-left: 0;
                padding-top: 0.5rem;
                margin-top: 0.3rem;
            }

            .callout {
                padding: 1rem;
            }

            .callout-title {
                font-size: 1rem;
            }

            .memory-impact,
            .best-practices,
            .performance-note {
                padding: 1rem;
            }

            .memory-impact h5,
            .best-practices h5,
            .performance-note h5 {
                font-size: 1rem;
            }

            .comparison-table {
                display: block;
                overflow-x: auto;
                white-space: nowrap;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 0 0.8rem;
            }

            .hero {
                padding: 2rem 0.5rem;
                margin: 1rem 0;
            }

            .hero h1 {
                font-size: 1.6rem;
            }

            .hero p {
                font-size: 0.9rem;
            }

            .card {
                padding: 1rem;
                margin: 1rem 0;
            }

            .card h3 {
                font-size: 1.2rem;
            }

            .pattern-card {
                padding: 1rem;
            }

            .pattern-title {
                font-size: 1rem;
            }

            .pattern-desc {
                font-size: 0.85rem;
            }

            section {
                margin: 2rem 0;
            }

            section h2 {
                font-size: 1.3rem;
                margin-bottom: 1.5rem;
            }

            .code-title {
                font-size: 0.8rem;
                padding: 0.6rem 1rem;
            }

            pre {
                font-size: 0.75rem;
                padding: 0.8rem;
                line-height: 1.4;
            }

            .visual-diagram {
                font-size: 0.7rem;
                padding: 0.8rem;
            }

            .code-explanation {
                padding: 1rem;
            }

            .explanation-section {
                padding: 0.8rem;
                margin-bottom: 1rem;
            }

            .explanation-section h4 {
                font-size: 1rem;
            }

            .line-by-line {
                padding: 0.5rem;
            }

            .code-line {
                padding: 0.5rem;
            }

            .feature-list li {
                padding: 0.6rem 0;
                padding-left: 1.8rem;
                font-size: 0.9rem;
            }

            .explanation-content ul li {
                font-size: 0.85rem;
                padding-left: 1.5rem;
            }

            .callout {
                padding: 0.8rem;
                margin: 1rem 0;
            }

            .memory-impact,
            .best-practices,
            .performance-note {
                padding: 0.8rem;
                margin: 0.8rem 0;
            }

            .btn {
                padding: 0.8rem 1rem;
                font-size: 0.9rem;
            }
        }

        @media (max-width: 360px) {
            .container {
                padding: 0 0.5rem;
            }

            .hero h1 {
                font-size: 1.4rem;
            }

            .hero p {
                font-size: 0.85rem;
            }

            .nav-logo {
                font-size: 1rem;
            }

            pre {
                font-size: 0.7rem;
            }

            section h2 {
                font-size: 1.2rem;
            }
        }

        /* Print Styles */
        @media print {
            .nav,
            .progress-container,
            .btn,
            .copy-btn,
            .explanation-toggle {
                display: none;
            }

            .explanation-content {
                max-height: none !important;
                display: block !important;
            }

            .card,
            .callout {
                break-inside: avoid;
            }

            body {
                background: white;
                color: black;
            }
        }

        /* Accessibility Enhancements */
        .btn:focus,
        .copy-btn:focus,
        .explanation-toggle:focus {
            outline: 3px solid var(--accent-cyan);
            outline-offset: 2px;
        }

        /* Smooth Scrolling */
        html {
            scroll-behavior: smooth;
        }

        /* Loading Animation */
        @keyframes shimmer {
            0% {
                background-position: -1000px 0;
            }
            100% {
                background-position: 1000px 0;
            }
        }

        .loading {
            animation: shimmer 2s infinite;
            background: linear-gradient(
                to right,
                var(--card-bg) 4%,
                rgba(88, 166, 255, 0.1) 25%,
                var(--card-bg) 36%
            );
            background-size: 1000px 100%;
        }

        /* Notification Toast */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--accent-green);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            z-index: 10000;
            opacity: 0;
            transform: translateX(400px);
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .notification.show {
            opacity: 1;
            transform: translateX(0);
        }

        .notification::before {
            content: '✓';
            font-size: 1.2rem;
            font-weight: bold;
        }

        /* Enhanced code line hover */
        .code-line {
            transition: all 0.2s ease;
            cursor: pointer;
            border-radius: 4px;
            padding: 0.3rem 0.5rem;
            margin: 0.2rem 0;
        }

        .code-line:hover {
            transform: translateX(4px);
            box-shadow: -3px 0 0 var(--accent-blue);
        }

        /* Tooltip for buttons */
        [data-tooltip] {
            position: relative;
        }

        [data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-8px);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            font-size: 0.85rem;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s, transform 0.3s;
            z-index: 1000;
        }

        [data-tooltip]:hover::after {
            opacity: 1;
            transform: translateX(-50%) translateY(-12px);
        }

        /* Enhanced focus states */
        button:focus-visible,
        a:focus-visible {
            outline: 3px solid var(--accent-cyan);
            outline-offset: 2px;
            border-radius: 4px;
        }

        /* Selection styling */
        ::selection {
            background: var(--accent-blue);
            color: white;
        }

        ::-moz-selection {
            background: var(--accent-blue);
            color: white;
        }

        /* Spin animation for loading */
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Progress Bar -->
    <div class="progress-container">
        <div class="progress-bar" id="progressBar"></div>
    </div>
    
    <!-- Navigation -->
    <nav>
        <div class="container nav-container">
            <div class="nav-logo">
                <span>🚀 Rover</span> | Memory Patterns
            </div>
            <ul class="nav-links">
                <li><a href="#overview" class="active">Overview</a></li>
                <li><a href="#decision-framework">Decision Framework</a></li>
                <li><a href="#examples">Real Examples</a></li>
                <li><a href="#patterns">Design Patterns</a></li>
                <li><a href="#pattern-guide">Pattern Guide</a></li>
                <li><a href="#advanced-patterns">Advanced</a></li>
                <li><a href="#cache">Cache</a></li>
                <li><a href="#lru-cache">LRU Cache</a></li>
                <li><a href="#checklist">Checklist</a></li>
            </ul>
        </div>
    </nav>

    <main class="container">
        <!-- Hero Section -->
        <section class="hero">
            <h1>🧠 Memory Patterns & Data Structure Selection</h1>
            <p>Master the art of choosing the right data structure and optimizing memory patterns. Learn through 10+ real-world examples with interactive visualizations, detailed code explanations, and performance benchmarks.</p>
        </section>

        <!-- Overview Section -->
        <section id="overview">
            <h2>📚 Understanding Memory-Driven Design</h2>
            
            <div class="card">
                <div class="card-header">
                    <div class="icon">🎯</div>
                    <h3>Why Memory Patterns Matter</h3>
                </div>
                <p>Choosing the right data structure isn't just about Big-O notation—it's about understanding how your code interacts with memory. A theoretically faster O(log n) algorithm can be slower than O(n) if it causes cache misses. Real-world performance depends on:</p>
                
                <ul class="feature-list">
                    <li><strong>Cache Locality:</strong> Sequential access is 100x faster than random access</li>
                    <li><strong>Memory Layout:</strong> Contiguous structures outperform scattered allocations</li>
                    <li><strong>Access Patterns:</strong> FIFO, LIFO, and random access each favor different structures</li>
                    <li><strong>Data Lifetime:</strong> Short-lived vs. long-lived data require different strategies</li>
                    <li><strong>Size Constraints:</strong> Known vs. unknown sizes at compile time</li>
                </ul>
            </div>

            <div class="callout">
                <div class="callout-title">💡 The Golden Rule</div>
                <p><strong>"The best data structure is the one that matches your access pattern."</strong> Don't memorize structures—understand the problem first, then let the problem guide your choice.</p>
            </div>

            <div class="callout warning">
                <div class="callout-title">⚠️ Common Mistake</div>
                <p>Developers often choose familiar structures (like hash maps for everything) without considering the specific access pattern. This leads to poor cache utilization, excessive allocations, and degraded performance.</p>
            </div>
        </section>

        <!-- Decision Framework -->
        <section id="decision-framework">
            <h2>🧭 The Decision Framework</h2>
            
            <div class="card">
                <div class="card-header">
                    <div class="icon">🤔</div>
                    <h3>Ask These Questions in Order</h3>
                </div>
                <p>Before writing any code, systematically evaluate your requirements using this framework:</p>
            </div>

            <div class="pattern-grid">
                <div class="pattern-card green">
                    <span class="pattern-icon">🔍</span>
                    <div class="pattern-title">Q1: What operations are most frequent?</div>
                    <div class="pattern-desc">
                        <strong>Lookup by key?</strong> → Hash Table/Map<br>
                        <strong>FIFO/Queue?</strong> → Queue/Deque<br>
                        <strong>LIFO/Stack?</strong> → Stack/Vector<br>
                        <strong>Sorted access?</strong> → Tree/Heap<br>
                        <strong>Range queries?</strong> → Tree/Segment Tree
                    </div>
                </div>

                <div class="pattern-card blue">
                    <span class="pattern-icon">📊</span>
                    <div class="pattern-title">Q2: How much data?</div>
                    <div class="pattern-desc">
                        <strong>Small (< 100 items)?</strong> → Simple array/list<br>
                        <strong>Medium (< 10K)?</strong> → Any structure works<br>
                        <strong>Large (> 100K)?</strong> → Cache-conscious design<br>
                        <strong>Huge (> 1M)?</strong> → Memory efficiency critical
                    </div>
                </div>

                <div class="pattern-card orange">
                    <span class="pattern-icon">⏱️</span>
                    <div class="pattern-title">Q3: What are the time requirements?</div>
                    <div class="pattern-desc">
                        <strong>Real-time?</strong> → Worst-case guarantees<br>
                        <strong>Interactive?</strong> → Average-case focus<br>
                        <strong>Batch processing?</strong> → Throughput priority<br>
                        <strong>One-time?</strong> → Simplicity over speed
                    </div>
                </div>

                <div class="pattern-card purple">
                    <span class="pattern-icon">💾</span>
                    <div class="pattern-title">Q4: What are memory constraints?</div>
                    <div class="pattern-desc">
                        <strong>Embedded system?</strong> → Minimal allocations<br>
                        <strong>Mobile?</strong> → Memory-conscious<br>
                        <strong>Server?</strong> → Balanced approach<br>
                        <strong>Cloud?</strong> → Speed over memory
                    </div>
                </div>
            </div>

            <div class="callout success">
                <div class="callout-title">✅ Pro Tip</div>
                <p>Don't skip this framework! Spending 5 minutes thinking through these questions saves hours of debugging performance issues later. The right structure makes problems trivial; the wrong one makes them impossible.</p>
            </div>
        </section>

        <!-- Real-World Examples Section -->
        <section id="examples">
            <h2>🌍 Real-World Examples</h2>
            
            <div class="card">
                <div class="card-header">
                    <div class="icon">💼</div>
                    <h3>Learn Through Production Scenarios</h3>
                </div>
                <p>Let's examine real problems and see how to choose the right data structure based on the access pattern. Each example includes detailed code, memory analysis, and performance insights.</p>
            </div>

            <!-- Example 1: User Sessions -->
            <div class="card">
                <h3>Example 1: User Session Tracker</h3>
                
                <div class="callout">
                    <div class="callout-title">📝 Problem</div>
                    <p><strong>Scenario:</strong> Track active user sessions in a web application</p>
                    <p><strong>Operations:</strong></p>
                    <ul style="margin-left: 1.5rem; margin-top: 0.5rem;">
                        <li>Check if user is logged in (most frequent)</li>
                        <li>Add new session on login</li>
                        <li>Remove session on logout</li>
                        <li>Update session timestamp</li>
                    </ul>
                    <p style="margin-top: 0.5rem;"><strong>Data size:</strong> 10,000-100,000 active sessions</p>
                </div>

                <div class="code-container">
                    <div class="code-title">
                        ❌ Bad Approach: Using Array/List
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="keyword">class</span> <span class="function">SessionTrackerBad</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.sessions = []  <span class="comment"># List of (user_id, timestamp) tuples</span>
    
    <span class="keyword">def</span> <span class="function">is_logged_in</span>(self, user_id):
        <span class="comment"># ❌ O(n) - Must scan entire list</span>
        <span class="keyword">for</span> uid, _ <span class="keyword">in</span> self.sessions:
            <span class="keyword">if</span> uid == user_id:
                <span class="keyword">return</span> <span class="keyword">True</span>
        <span class="keyword">return</span> <span class="keyword">False</span>
    
    <span class="keyword">def</span> <span class="function">add_session</span>(self, user_id):
        <span class="comment"># ❌ O(n) check + O(1) append = O(n)</span>
        <span class="keyword">if</span> <span class="keyword">not</span> self.<span class="function">is_logged_in</span>(user_id):
            self.sessions.<span class="function">append</span>((user_id, <span class="function">time</span>.<span class="function">time</span>()))</code></pre>
                </div>

                <div class="code-explanation">
                    <div class="explanation-header" onclick="toggleExplanation(this)">
                        <div class="explanation-title">
                            🔍 <span>Why This Is Terrible</span>
                        </div>
                        <button class="explanation-toggle">Show Analysis</button>
                    </div>
                    <div class="explanation-content">
                        <div class="explanation-section">
                            <h4>📋 Performance Analysis</h4>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">Line 6-10</span>
                                    <span class="line-code">for uid, _ in self.sessions:</span>
                                    <span class="line-explanation">Scans ENTIRE list for every lookup. With 50K sessions, this is 50K comparisons per login check!</span>
                                </div>
                            </div>
                        </div>

                        <div class="memory-impact">
                            <h5>🐌 Performance Impact</h5>
                            <p><strong>Time Complexity:</strong> O(n) for every operation</p>
                            <p><strong>Real-world impact:</strong> 50,000 sessions × 1000 logins/second = 50 MILLION comparisons per second</p>
                            <p><strong>CPU usage:</strong> Massive—probably 100% CPU just checking logins</p>
                            <p><strong>Response time:</strong> Increases linearly with active users (unacceptable)</p>
                        </div>

                        <div class="best-practices">
                            <h5>💡 What We Learn</h5>
                            <ul>
                                <li>Sequential search is ONLY acceptable for tiny datasets (< 100 items)</li>
                                <li>Lookup by key is a fundamental pattern—needs O(1) solution</li>
                                <li>The most frequent operation determines your choice</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="code-container" style="margin-top: 2rem;">
                    <div class="code-title">
                        ✅ Good Approach: Using Hash Map
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="keyword">class</span> <span class="function">SessionTrackerGood</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.sessions = {}  <span class="comment"># {user_id: timestamp} hash map</span>
    
    <span class="keyword">def</span> <span class="function">is_logged_in</span>(self, user_id):
        <span class="comment"># ✅ O(1) - Direct hash table lookup</span>
        <span class="keyword">return</span> user_id <span class="keyword">in</span> self.sessions
    
    <span class="keyword">def</span> <span class="function">add_session</span>(self, user_id):
        <span class="comment"># ✅ O(1) - Direct insert</span>
        self.sessions[user_id] = <span class="function">time</span>.<span class="function">time</span>()
    
    <span class="keyword">def</span> <span class="function">remove_session</span>(self, user_id):
        <span class="comment"># ✅ O(1) - Direct delete</span>
        <span class="keyword">if</span> user_id <span class="keyword">in</span> self.sessions:
            <span class="keyword">del</span> self.sessions[user_id]
    
    <span class="keyword">def</span> <span class="function">update_session</span>(self, user_id):
        <span class="comment"># ✅ O(1) - Direct update</span>
        <span class="keyword">if</span> user_id <span class="keyword">in</span> self.sessions:
            self.sessions[user_id] = <span class="function">time</span>.<span class="function">time</span>()</code></pre>
                </div>

                <div class="code-explanation">
                    <div class="explanation-header" onclick="toggleExplanation(this)">
                        <div class="explanation-title">
                            🔍 <span>Complete Breakdown</span>
                        </div>
                        <button class="explanation-toggle">Show Details</button>
                    </div>
                    <div class="explanation-content">
                        <div class="explanation-section">
                            <h4>📋 Line-by-Line Deep Dive</h4>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">3</span>
                                    <span class="line-code">self.sessions = {}</span>
                                    <span class="line-explanation">Hash map initialized. Python dict uses open addressing with 8 initial slots.</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">7</span>
                                    <span class="line-code">return user_id in self.sessions</span>
                                    <span class="line-explanation">Computes hash of user_id (one integer operation), looks up in hash table bucket (O(1) average). No loop required!</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">11</span>
                                    <span class="line-code">self.sessions[user_id] = time.time()</span>
                                    <span class="line-explanation">Hash lookup + insert. If bucket full, may trigger resize (amortized O(1)).</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">16</span>
                                    <span class="line-code">del self.sessions[user_id]</span>
                                    <span class="line-explanation">Marks slot as deleted (tombstone). Memory reclaimed during next resize.</span>
                                </div>
                            </div>
                        </div>

                        <div class="memory-impact">
                            <h5>🧠 Memory Layout & Performance</h5>
                            <p><strong>Space Complexity:</strong> O(n) where n = number of sessions</p>
                            <p><strong>Memory per entry:</strong> ~48 bytes (24B key + 16B value + 8B overhead)</p>
                            <p><strong>50K sessions:</strong> 50,000 × 48 = 2.4 MB (easily fits in L3 cache!)</p>
                            <p><strong>Hash collisions:</strong> < 1% with good hash function</p>
                            <p><strong>Resize cost:</strong> O(n) but happens rarely (when load factor > 0.66)</p>
                        </div>

                        <div class="performance-note">
                            <h5>⚡ Performance Benchmarks</h5>
                            <p><strong>List approach:</strong> 50K operations/sec (CPU-bound)</p>
                            <p><strong>Hash map approach:</strong> 5 MILLION operations/sec (100x faster!)</p>
                            <p><strong>Memory overhead:</strong> 2.4 MB vs 1.6 MB (50% more, but worth it)</p>
                            <p><strong>Latency:</strong> 0.2μs per operation (imperceptible to users)</p>
                        </div>

                        <div class="explanation-section">
                            <h4>🔄 How Hash Tables Work</h4>
                            <div class="visual-diagram">
                                <div class="diagram-title">Internal Structure</div>
<pre>Hash Table Internals:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Array of buckets (size = next power of 2):

Index  Key Hash    Value         Status
  0    -           -             EMPTY
  1    user_789    1609459200    OCCUPIED
  2    -           -             EMPTY  
  3    user_123    1609459180    OCCUPIED
  4    -           -             DELETED (tombstone)
  5    user_456    1609459190    OCCUPIED
  ...

Lookup Process:
1. hash(user_123) = 0xAB3F → % 8 = 3
2. Check bucket 3 → Found!
3. Return value: 1609459180

Collision handling (Open Addressing):
If bucket 3 occupied, try 4, then 5... (linear probing)</pre>
                            </div>
                        </div>

                        <div class="best-practices">
                            <h5>✅ Why This Works</h5>
                            <ul>
                                <li><strong>Pattern Match:</strong> "Lookup by key" → Hash map is THE answer</li>
                                <li><strong>Constant Time:</strong> All operations O(1) average case</li>
                                <li><strong>Cache Friendly:</strong> 2.4 MB fits in CPU cache for instant access</li>
                                <li><strong>Scalable:</strong> Performance stays constant as users grow</li>
                                <li><strong>Simple Code:</strong> 3 lines vs 10+ for manual iteration</li>
                            </ul>
                        </div>

                        <div class="callout success">
                            <div class="callout-title">🎯 Key Takeaway</div>
                            <p><strong>When you see "lookup by key" or "check if exists" → Think hash map first.</strong> It's not the only answer, but it's right 90% of the time. The 10% exceptions are when you also need ordering (use TreeMap) or memory is extremely limited (use sorted array with binary search).</p>
                        </div>
                    </div>
                </div>

                <div class="visual-diagram" style="margin-top: 2rem;">
                    <div class="diagram-title">Performance Comparison Visualization</div>
<pre>Operations per second capability:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Array/List:  ▓░░░░░░░░░░░░░░░░░░░  50K ops/sec
Hash Map:    ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  5M ops/sec
                                    ↑ 100x faster!

Response time at 50K active sessions:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Array:       ████████████████████  1ms (unacceptable)
Hash Map:    ▏                     0.2μs (instant)
</pre>
                </div>
            </div>

            <!-- Example 2: Real-Time Leaderboard -->
            <div class="card" style="margin-top: 4rem;">
                <h3>Example 2: Real-Time Gaming Leaderboard</h3>
                
                <div class="callout">
                    <div class="callout-title">📝 Problem</div>
                    <p><strong>Scenario:</strong> Display top 10 players in a competitive game</p>
                    <p><strong>Operations:</strong></p>
                    <ul style="margin-left: 1.5rem; margin-top: 0.5rem;">
                        <li>Get top K players (most frequent - every frame)</li>
                        <li>Update player score (frequent)</li>
                        <li>Add new player (occasional)</li>
                    </ul>
                    <p style="margin-top: 0.5rem;"><strong>Requirements:</strong> Must handle 1 million players, sub-millisecond updates</p>
                </div>

                <div class="code-container">
                    <div class="code-title">
                        ❌ Bad: Full Sort Every Time
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="keyword">class</span> <span class="function">LeaderboardBad</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.players = {}  <span class="comment"># {player_id: score}</span>
    
    <span class="keyword">def</span> <span class="function">get_top_10</span>(self):
        <span class="comment"># ❌ O(n log n) - Sorts ALL 1M players every time!</span>
        sorted_players = <span class="function">sorted</span>(
            self.players.<span class="function">items</span>(), 
            key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], 
            reverse=<span class="keyword">True</span>
        )
        <span class="keyword">return</span> sorted_players[:<span class="number">10</span>]
    
    <span class="keyword">def</span> <span class="function">update_score</span>(self, player_id, new_score):
        self.players[player_id] = new_score</code></pre>
                </div>

                <div class="code-explanation">
                    <div class="explanation-header" onclick="toggleExplanation(this)">
                        <div class="explanation-title">
                            🔍 <span>Performance Disaster Analysis</span>
                        </div>
                        <button class="explanation-toggle">Show Analysis</button>
                    </div>
                    <div class="explanation-content">
                        <div class="memory-impact">
                            <h5>⚠️ Critical Performance Issues</h5>
                            <ul style="margin-left: 1.5rem; margin-top: 0.5rem; line-height: 1.8;">
                                <li><strong>Sorting 1M players:</strong> ~20 million comparisons per call</li>
                                <li><strong>Time per sort:</strong> 50-100ms (completely unacceptable for real-time)</li>
                                <li><strong>60 FPS requirement:</strong> Need < 16ms per frame, but we're taking 100ms!</li>
                                <li><strong>CPU waste:</strong> Sorting 999,990 players we don't even need</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="code-container" style="margin-top: 2rem;">
                    <div class="code-title">
                        ✅ Optimal: Min Heap for Top-K
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="keyword">import</span> heapq

<span class="keyword">class</span> <span class="function">LeaderboardOptimal</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, k=<span class="number">10</span>):
        self.k = k
        self.scores = {}           <span class="comment"># {player_id: score} - O(1) lookup</span>
        self.top_k_heap = []       <span class="comment"># Min heap of (score, player_id)</span>
    
    <span class="keyword">def</span> <span class="function">update_score</span>(self, player_id, new_score):
        <span class="comment"># Update score map</span>
        old_score = self.scores.<span class="function">get</span>(player_id, <span class="number">0</span>)
        self.scores[player_id] = new_score
        
        <span class="comment"># If player already in top K, update heap</span>
        <span class="keyword">if</span> (old_score, player_id) <span class="keyword">in</span> self.top_k_heap:
            self.top_k_heap.<span class="function">remove</span>((old_score, player_id))
            heapq.<span class="function">heappush</span>(self.top_k_heap, (new_score, player_id))
        
        <span class="comment"># If heap not full, add player</span>
        <span class="keyword">elif</span> <span class="function">len</span>(self.top_k_heap) < self.k:
            heapq.<span class="function">heappush</span>(self.top_k_heap, (new_score, player_id))
        
        <span class="comment"># If new score better than worst in top K, replace</span>
        <span class="keyword">elif</span> new_score > self.top_k_heap[<span class="number">0</span>][<span class="number">0</span>]:
            heapq.<span class="function">heapreplace</span>(self.top_k_heap, (new_score, player_id))
    
    <span class="keyword">def</span> <span class="function">get_top_k</span>(self):
        <span class="comment"># ✅ O(k log k) - Only sorts top 10!</span>
        <span class="keyword">return</span> <span class="function">sorted</span>(self.top_k_heap, reverse=<span class="keyword">True</span>)</code></pre>
                </div>

                <div class="code-explanation">
                    <div class="explanation-header" onclick="toggleExplanation(this)">
                        <div class="explanation-title">
                            🔍 <span>Complete Heap-Based Solution Breakdown</span>
                        </div>
                        <button class="explanation-toggle">Show Details</button>
                    </div>
                    <div class="explanation-content">
                        <div class="explanation-section">
                            <h4>📋 Strategy: Top-K Pattern with Min Heap</h4>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">6</span>
                                    <span class="line-code">self.top_k_heap = []</span>
                                    <span class="line-explanation">Min heap maintains ONLY top 10 players. Root = lowest score in top 10.</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">13-14</span>
                                    <span class="line-code">if (old_score, player_id) in heap:</span>
                                    <span class="line-explanation">Player in top 10 - must update their position in heap</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">18-19</span>
                                    <span class="line-code">elif len(heap) < k:</span>
                                    <span class="line-explanation">Heap not full yet - unconditionally add new player</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">22-23</span>
                                    <span class="line-code">elif new_score > heap[0][0]:</span>
                                    <span class="line-explanation">New score beats worst in top 10 - kick out minimum, add new player</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">27</span>
                                    <span class="line-code">return sorted(heap, reverse=True)</span>
                                    <span class="line-explanation">Sort only 10 items (not 1 million!) for display</span>
                                </div>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>🏗️ How Min Heap Works</h4>
                            <div class="visual-diagram">
<pre>Min Heap Structure (always smallest at root):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

         [8500]  ← Root (worst score in top 10)
        /      \
    [8700]    [8600]
    /    \    /    \
[9000] [8900] [8800] [8750]

When player scores 9500:
1. 9500 > 8500 (root) → Replace root
2. Heap becomes invalid → Bubble down
3. Final: [8600, 8700, 8750, 9000, 8900, 8800, 9500]

Operations:
• Insert: O(log k) where k=10 → ~3 comparisons
• Get min: O(1) → Just return root
• Replace min: O(log k) → ~3 comparisons
• Get top K: O(k log k) → Sort 10 items</pre>
                            </div>
                        </div>

                        <div class="memory-impact">
                            <h5>🧠 Memory & Performance Analysis</h5>
                            <ul style="margin-left: 1.5rem; margin-top: 0.5rem; line-height: 1.8;">
                                <li><strong>Space:</strong> O(n) hash map + O(k) heap = O(n) but k is tiny (10 items)</li>
                                <li><strong>Update time:</strong> O(log k) = O(log 10) ≈ O(3) → essentially constant!</li>
                                <li><strong>Get top K:</strong> O(k log k) = O(10 log 10) ≈ O(30) → microseconds</li>
                                <li><strong>Memory overhead:</strong> 1M × 16B (hash) + 10 × 16B (heap) = 16 MB total</li>
                                <li><strong>Cache friendly:</strong> Top 10 always in L1 cache (160 bytes)</li>
                            </ul>
                        </div>

                        <div class="performance-note">
                            <h5>⚡ Real-World Benchmark</h5>
                            <ul style="margin-left: 1.5rem; margin-top: 0.5rem; line-height: 1.8;">
                                <li><strong>Full sort approach:</strong> 100ms per get_top_10 call</li>
                                <li><strong>Min heap approach:</strong> 0.003ms per get_top_10 call</li>
                                <li><strong>Speedup:</strong> 33,000x faster! (100ms → 3μs)</li>
                                <li><strong>FPS impact:</strong> Full sort = 10 FPS, Heap = 60 FPS maintained</li>
                                <li><strong>Scalability:</strong> Works with 10M players (just bigger hash map)</li>
                            </ul>
                        </div>

                        <div class="best-practices">
                            <h5>✅ Top-K Pattern Recognition</h5>
                            <ul style="margin-left: 1.5rem; margin-top: 0.5rem; line-height: 1.8;">
                                <li><strong>Problem signature:</strong> "Find top/bottom K items" → Min/Max heap</li>
                                <li><strong>Why heap:</strong> Maintains partial order (we don't need full sort!)</li>
                                <li><strong>Min vs Max heap:</strong> Use min heap for top K (paradoxically!)</li>
                                <li><strong>Trade-off:</strong> Extra memory (k items) for huge time savings</li>
                                <li><strong>Real usage:</strong> Recommendation systems, trending topics, leaderboards</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Example 3: Undo/Redo System -->
            <div class="card" style="margin-top: 4rem;">
                <h3>Example 3: Text Editor Undo/Redo</h3>
                
                <div class="callout">
                    <div class="callout-title">📝 Problem</div>
                    <p><strong>Scenario:</strong> Implement undo/redo for a text editor</p>
                    <p><strong>Operations:</strong></p>
                    <ul style="margin-left: 1.5rem; margin-top: 0.5rem;">
                        <li>Execute action (type, delete, format)</li>
                        <li>Undo last action (Ctrl+Z)</li>
                        <li>Redo undone action (Ctrl+Y)</li>
                    </ul>
                    <p style="margin-top: 0.5rem;"><strong>Pattern:</strong> Last In, First Out (LIFO) - classic stack territory</p>
                </div>

                <div class="code-container">
                    <div class="code-title">
                        ✅ Perfect Fit: Two Stacks
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="keyword">class</span> <span class="function">TextEditor</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.undo_stack = []  <span class="comment"># Stack of past actions</span>
        self.redo_stack = []  <span class="comment"># Stack of undone actions</span>
        self.text = <span class="string">""</span>
    
    <span class="keyword">def</span> <span class="function">execute_action</span>(self, action):
        <span class="comment"># Save current state to undo stack</span>
        self.undo_stack.<span class="function">append</span>((action, self.text))
        
        <span class="comment"># Execute action</span>
        <span class="keyword">if</span> action[<span class="string">'type'</span>] == <span class="string">'insert'</span>:
            self.text += action[<span class="string">'char'</span>]
        <span class="keyword">elif</span> action[<span class="string">'type'</span>] == <span class="string">'delete'</span>:
            self.text = self.text[:-<span class="number">1</span>]
        
        <span class="comment"># Clear redo stack (new action invalidates redo)</span>
        self.redo_stack.<span class="function">clear</span>()
    
    <span class="keyword">def</span> <span class="function">undo</span>(self):
        <span class="keyword">if</span> <span class="keyword">not</span> self.undo_stack:
            <span class="keyword">return</span>
        
        <span class="comment"># Pop last action</span>
        action, old_text = self.undo_stack.<span class="function">pop</span>()
        
        <span class="comment"># Save current state to redo stack</span>
        self.redo_stack.<span class="function">append</span>((action, self.text))
        
        <span class="comment"># Restore old state</span>
        self.text = old_text
    
    <span class="keyword">def</span> <span class="function">redo</span>(self):
        <span class="keyword">if</span> <span class="keyword">not</span> self.redo_stack:
            <span class="keyword">return</span>
        
        <span class="comment"># Pop from redo stack</span>
        action, old_text = self.redo_stack.<span class="function">pop</span>()
        
        <span class="comment"># Save to undo stack</span>
        self.undo_stack.<span class="function">append</span>((action, self.text))
        
        <span class="comment"># Restore redone state</span>
        self.text = old_text</code></pre>
                </div>

                <div class="code-explanation">
                    <div class="explanation-header" onclick="toggleExplanation(this)">
                        <div class="explanation-title">
                            🔍 <span>Two-Stack Architecture Deep Dive</span>
                        </div>
                        <button class="explanation-toggle">Show Details</button>
                    </div>
                    <div class="explanation-content">
                        <div class="explanation-section">
                            <h4>🏗️ State Management Flow</h4>
                            <div class="visual-diagram">
<pre>Two-Stack Undo/Redo Visualization:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Initial: Type "HELLO"

After typing:
Undo Stack: [H, E, L, L, O]  ← Most recent on top
Redo Stack: []

After 2 undos (Ctrl+Z twice):
Undo Stack: [H, E, L]
Redo Stack: [O, L]  ← Can redo these
Current: "HEL"

After redo (Ctrl+Y):
Undo Stack: [H, E, L, L]
Redo Stack: [O]
Current: "HELL"

After new action (type "P"):
Undo Stack: [H, E, L, L, P]
Redo Stack: []  ← Cleared! Can't redo "O" anymore
Current: "HELLP"</pre>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>📋 Operation Analysis</h4>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">8</span>
                                    <span class="line-code">self.undo_stack.append((action, text))</span>
                                    <span class="line-explanation">O(1) - Push to stack. Saves action + state for potential undo.</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">17</span>
                                    <span class="line-code">self.redo_stack.clear()</span>
                                    <span class="line-explanation">Critical! New action makes redo invalid (can't redo after changing history).</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">24</span>
                                    <span class="line-code">action, old_text = stack.pop()</span>
                                    <span class="line-explanation">O(1) - Pop from stack. LIFO ensures we undo most recent first.</span>
                                </div>
                            </div>
                        </div>

                        <div class="memory-impact">
                            <h5>🧠 Memory Considerations</h5>
                            <ul style="margin-left: 1.5rem; margin-top: 0.5rem; line-height: 1.8;">
                                <li><strong>Space:</strong> O(n) where n = number of actions performed</li>
                                <li><strong>Per action:</strong> ~100 bytes (action object + text snapshot)</li>
                                <li><strong>10K actions:</strong> ~1 MB (acceptable for desktop app)</li>
                                <li><strong>Optimization:</strong> Store deltas instead of full snapshots (advanced)</li>
                                <li><strong>Limit:</strong> Can cap at last 1000 actions to prevent unbounded growth</li>
                            </ul>
                        </div>

                        <div class="best-practices">
                            <h5>✅ LIFO Pattern Recognition</h5>
                            <ul style="margin-left: 1.5rem; margin-top: 0.5rem; line-height: 1.8;">
                                <li><strong>Problem signature:</strong> "Most recent first" or "reverse order" → Stack</li>
                                <li><strong>Key insight:</strong> Two stacks give you bidirectional traversal</li>
                                <li><strong>Why not list?</strong> Could work, but stack operations are more explicit</li>
                                <li><strong>Production usage:</strong> Browsers (back/forward), IDEs, image editors</li>
                                <li><strong>Alternative:</strong> Command pattern with history list (OOP approach)</li>
                            </ul>
                        </div>

                        <div class="performance-note">
                            <h5>⚡ Performance Characteristics</h5>
                            <ul style="margin-left: 1.5rem; margin-top: 0.5rem; line-height: 1.8;">
                                <li><strong>All operations:</strong> O(1) time - perfect!</li>
                                <li><strong>Memory trade-off:</strong> Use memory to enable instant undo/redo</li>
                                <li><strong>User experience:</strong> Sub-millisecond response (imperceptible)</li>
                                <li><strong>Scalability:</strong> Handles thousands of undo levels easily</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Example 4: URL Shortener Hit Counter -->
            <div class="card" style="margin-top: 4rem;">
                <h3>Example 4: URL Shortener Hit Counter</h3>
                
                <div class="callout">
                    <div class="callout-title">📝 Problem</div>
                    <p><strong>Scenario:</strong> Count URL hits in last 5 minutes (sliding window)</p>
                    <p><strong>Operations:</strong></p>
                    <ul style="margin-left: 1.5rem; margin-top: 0.5rem;">
                        <li>Record hit with timestamp</li>
                        <li>Get hit count in last 5 minutes</li>
                        <li>Remove old hits (cleanup)</li>
                    </ul>
                    <p style="margin-top: 0.5rem;"><strong>Pattern:</strong> FIFO with efficient removal from both ends → Deque</p>
                </div>

                <div class="code-container">
                    <div class="code-title">
                        ✅ Optimal: Deque (Double-Ended Queue)
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="keyword">from</span> collections <span class="keyword">import</span> deque
<span class="keyword">import</span> time

<span class="keyword">class</span> <span class="function">URLHitCounter</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, window_seconds=<span class="number">300</span>):
        self.window = window_seconds
        self.hits = deque()  <span class="comment"># Stores (timestamp, url) tuples</span>
    
    <span class="keyword">def</span> <span class="function">record_hit</span>(self, url):
        <span class="comment"># ✅ O(1) - Add to right end</span>
        current_time = <span class="function">time</span>.<span class="function">time</span>()
        self.hits.<span class="function">append</span>((current_time, url))
        
        <span class="comment"># Cleanup old hits from left end</span>
        self.<span class="function">_remove_old_hits</span>()
    
    <span class="keyword">def</span> <span class="function">get_hit_count</span>(self):
        <span class="comment"># ✅ O(1) - Just return length</span>
        self.<span class="function">_remove_old_hits</span>()
        <span class="keyword">return</span> <span class="function">len</span>(self.hits)
    
    <span class="keyword">def</span> <span class="function">_remove_old_hits</span>(self):
        <span class="comment"># ✅ O(k) where k = hits to remove (amortized O(1))</span>
        current_time = <span class="function">time</span>.<span class="function">time</span>()
        cutoff_time = current_time - self.window
        
        <span class="comment"># Remove from left while timestamps are old</span>
        <span class="keyword">while</span> self.hits <span class="keyword">and</span> self.hits[<span class="number">0</span>][<span class="number">0</span>] < cutoff_time:
            self.hits.<span class="function">popleft</span>()  <span class="comment"># O(1) removal from left!</span></code></pre>
                </div>

                <div class="code-explanation">
                    <div class="explanation-header" onclick="toggleExplanation(this)">
                        <div class="explanation-title">
                            🔍 <span>Sliding Window with Deque</span>
                        </div>
                        <button class="explanation-toggle">Show Details</button>
                    </div>
                    <div class="explanation-content">
                        <div class="explanation-section">
                            <h4>🏗️ Deque vs Array/List</h4>
                            <div class="visual-diagram">
<pre>Why Deque is Perfect for Sliding Window:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Array/List:
[old, old, new, new, new] → Need to remove from front
Remove first element → Must shift ALL remaining elements
Time: O(n) per removal ❌

Deque (doubly-linked list):
[old] ⇄ [old] ⇄ [new] ⇄ [new] ⇄ [new]
  ↑                            ↑
 left                        right

Remove from left: Just update pointers
Time: O(1) per removal ✅

Operations:
• append(x)     → O(1) add to right
• appendleft(x) → O(1) add to left  
• pop()         → O(1) remove from right
• popleft()     → O(1) remove from left
• Access [i]    → O(n) (trade-off)</pre>
                            </div>
                        </div>

                        <div class="explanation-section">
                            <h4>📋 Sliding Window Algorithm</h4>
                            <div class="line-by-line">
                                <div class="code-line">
                                    <span class="line-number">12</span>
                                    <span class="line-code">self.hits.append((time, url))</span>
                                    <span class="line-explanation">Add new hit to right end. Maintains chronological order.</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">29-30</span>
                                    <span class="line-code">while hits and hits[0][0] < cutoff:</span>
                                    <span class="line-explanation">Remove expired hits from left. Loop runs once per expired hit (amortized O(1)).</span>
                                </div>
                                <div class="code-line">
                                    <span class="line-number">31</span>
                                    <span class="line-code">self.hits.popleft()</span>
                                    <span class="line-explanation">O(1) removal from left - deque's superpower! Array would be O(n).</span>
                                </div>
                            </div>
                        </div>

                        <div class="memory-impact">
                            <h5>🧠 Memory & Performance</h5>
                            <ul style="margin-left: 1.5rem; margin-top: 0.5rem; line-height: 1.8;">
                                <li><strong>Space:</strong> O(k) where k = hits in window (not all time!)</li>
                                <li><strong>High traffic:</strong> 1000 hits/sec × 300 sec = 300K hits = 4.8 MB</li>
                                <li><strong>Per hit:</strong> 16 bytes (8B timestamp + 8B pointer)</li>
                                <li><strong>Deque overhead:</strong> 24 bytes per node (prev/next/data pointers)</li>
                                <li><strong>Total:</strong> 300K × 40B = 12 MB (acceptable for analytics)</li>
                            </ul>
                        </div>

                        <div class="performance-note">
                            <h5>⚡ Benchmark: Deque vs List</h5>
                            <ul style="margin-left: 1.5rem; margin-top: 0.5rem; line-height: 1.8;">
                                <li><strong>List removal from front:</strong> O(n) → 5ms for 100K items</li>
                                <li><strong>Deque removal from front:</strong> O(1) → 0.001ms (5000x faster!)</li>
                                <li><strong>get_hit_count:</strong> Instant even with millions of historical hits</li>
                                <li><strong>Cleanup overhead:</strong> Amortized O(1) - each hit removed once</li>
                            </ul>
                        </div>

                        <div class="best-practices">
                            <h5>✅ Deque Pattern Recognition</h5>
                            <ul style="margin-left: 1.5rem; margin-top: 0.5rem; line-height: 1.8;">
                                <li><strong>Problem signature:</strong> "Sliding window" or "remove from both ends" → Deque</li>
                                <li><strong>Key advantage:</strong> O(1) removal from front (vs O(n) for arrays)</li>
                                <li><strong>Use cases:</strong> Rate limiting, recent items, sliding window algorithms</li>
                                <li><strong>Trade-off:</strong> No random access, but we don't need it here!</li>
                                <li><strong>Python tip:</strong> collections.deque is highly optimized C implementation</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

        </section>

        <!-- Algorithm Design Patterns Section -->
        <section id="patterns">
            <h2>🎨 Memory-Efficient Algorithm Patterns</h2>
            
            <div class="card">
                <div class="card-header">
                    <div class="icon">🧩</div>
                    <h3>Five Essential Patterns</h3>
                </div>
                <p>Beyond data structures, certain algorithmic patterns dramatically reduce memory usage while maintaining or improving performance. Master these patterns to write production-grade code.</p>
            </div>

            <!-- Pattern 1: In-Place Algorithms -->
            <div class="card">
                <h3>Pattern 1: In-Place Modifications</h3>
                
                <div class="callout">
                    <div class="callout-title">🎯 Concept</div>
                    <p>Modify data structures in-place rather than creating copies. Reduces space complexity from O(n) to O(1).</p>
                </div>

                <div class="code-container">
                    <div class="code-title">
                        Example: Remove Duplicates from Sorted Array
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="keyword">def</span> <span class="function">remove_duplicates</span>(nums):
    <span class="string">"""Remove duplicates in-place, return new length"""</span>
    <span class="keyword">if</span> <span class="keyword">not</span> nums:
        <span class="keyword">return</span> <span class="number">0</span>
    
    <span class="comment"># Two pointers: slow (write position), fast (read position)</span>
    slow = <span class="number">0</span>
    
    <span class="keyword">for</span> fast <span class="keyword">in</span> <span class="function">range</span>(<span class="number">1</span>, <span class="function">len</span>(nums)):
        <span class="keyword">if</span> nums[fast] != nums[slow]:
            slow += <span class="number">1</span>
            nums[slow] = nums[fast]  <span class="comment"># Overwrite in-place!</span>
    
    <span class="keyword">return</span> slow + <span class="number">1</span>

<span class="comment"># Example: [1,1,2,2,3] → [1,2,3,2,3], return 3</span>
<span class="comment"># First 3 elements are unique, rest is garbage (ignored)</span></code></pre>
                </div>

                <div class="code-explanation">
                    <div class="explanation-header" onclick="toggleExplanation(this)">
                        <div class="explanation-title">
                            🔍 <span>In-Place Two-Pointer Technique</span>
                        </div>
                        <button class="explanation-toggle">Show Details</button>
                    </div>
                    <div class="explanation-content">
                        <div class="explanation-section">
                            <h4>🏗️ Visual Step-by-Step</h4>
                            <div class="visual-diagram">
<pre>Two-Pointer In-Place Modification:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Initial: [1, 1, 2, 2, 3]
          ↑  ↑
        slow fast

Step 1: nums[fast]=1 == nums[slow]=1 → Skip
        [1, 1, 2, 2, 3]
         ↑     ↑
       slow  fast

Step 2: nums[fast]=2 != nums[slow]=1 → Write!
        slow++, nums[slow] = nums[fast]
        [1, 2, 2, 2, 3]
            ↑     ↑
          slow  fast

Step 3: nums[fast]=2 == nums[slow]=2 → Skip
        [1, 2, 2, 2, 3]
            ↑        ↑
          slow     fast

Step 4: nums[fast]=3 != nums[slow]=2 → Write!
        [1, 2, 3, 2, 3]
               ↑     ↑
             slow  fast

Result: First 3 elements are unique
        Return slow+1 = 3</pre>
                            </div>
                        </div>

                        <div class="memory-impact">
                            <h5>🧠 Space Complexity Analysis</h5>
                            <ul style="margin-left: 1.5rem; margin-top: 0.5rem; line-height: 1.8;">
                                <li><strong>Naive approach:</strong> Create new array → O(n) space</li>
                                <li><strong>In-place approach:</strong> Modify original → O(1) space</li>
                                <li><strong>For 1M elements:</strong> Save 4 MB (for integers)</li>
                                <li><strong>Trade-off:</strong> Destroys original array (acceptable in many cases)</li>
                            </ul>
                        </div>

                        <div class="best-practices">
                            <h5>✅ When to Use In-Place</h5>
                            <ul style="margin-left: 1.5rem; margin-top: 0.5rem; line-height: 1.8;">
                                <li><strong>Array manipulation:</strong> Remove, deduplicate, partition</li>
                                <li><strong>Sorting:</strong> Quicksort in-place vs merge sort (needs O(n) space)</li>
                                <li><strong>String operations:</strong> Reverse, rotate (if mutable)</li>
                                <li><strong>When NOT to use:</strong> Need to preserve original data</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Pattern 2: Sliding Window -->
            <div class="card">
                <h3>Pattern 2: Sliding Window Optimization</h3>
                
                <div class="callout">
                    <div class="callout-title">🎯 Concept</div>
                    <p>Reuse computation from previous window instead of recalculating from scratch. Reduces time from O(n×k) to O(n).</p>
                </div>

                <div class="code-container">
                    <div class="code-title">
                        Example: Maximum Sum Subarray of Size K
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="keyword">def</span> <span class="function">max_sum_subarray</span>(arr, k):
    <span class="string">"""Find max sum of any subarray of size k"""</span>
    <span class="keyword">if</span> <span class="function">len</span>(arr) < k:
        <span class="keyword">return</span> <span class="keyword">None</span>
    
    <span class="comment"># Calculate first window</span>
    window_sum = <span class="function">sum</span>(arr[:k])
    max_sum = window_sum
    
    <span class="comment"># Slide window: subtract left, add right</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(k, <span class="function">len</span>(arr)):
        window_sum = window_sum - arr[i-k] + arr[i]  <span class="comment"># ✅ Only 2 operations!</span>
        max_sum = <span class="function">max</span>(max_sum, window_sum)
    
    <span class="keyword">return</span> max_sum

<span class="comment"># Example: arr=[1,2,3,4,5], k=3</span>
<span class="comment"># Windows: [1,2,3]=6, [2,3,4]=9, [3,4,5]=12 → max=12</span>
<span class="comment"># Naive: 3+3+3=9 operations, Sliding: 3+2+2=7 operations</span></code></pre>
                </div>

                <div class="code-explanation">
                    <div class="explanation-header" onclick="toggleExplanation(this)">
                        <div class="explanation-title">
                            🔍 <span>Sliding Window Mechanics</span>
                        </div>
                        <button class="explanation-toggle">Show Details</button>
                    </div>
                    <div class="explanation-content">
                        <div class="performance-note">
                            <h5>⚡ Performance Breakthrough</h5>
                            <ul style="margin-left: 1.5rem; margin-top: 0.5rem; line-height: 1.8;">
                                <li><strong>Naive approach:</strong> O(n×k) - recalculate each window from scratch</li>
                                <li><strong>Sliding window:</strong> O(n) - reuse previous computation</li>
                                <li><strong>Example:</strong> n=1M, k=10K → 10 billion vs 1 million ops (10,000x faster!)</li>
                                <li><strong>Real time:</strong> 30 seconds → 3 milliseconds</li>
                            </ul>
                        </div>

                        <div class="best-practices">
                            <h5>✅ Sliding Window Recognition</h5>
                            <ul style="margin-left: 1.5rem; margin-top: 0.5rem; line-height: 1.8;">
                                <li><strong>Fixed window:</strong> "Subarray/substring of size k"</li>
                                <li><strong>Variable window:</strong> "Longest/shortest subarray with property X"</li>
                                <li><strong>Key insight:</strong> Adjacent windows share most elements</li>
                                <li><strong>Applications:</strong> Moving average, rate limiting, streaming analytics</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Pattern Recognition Guide -->
        <section id="pattern-guide">
            <h2>🧭 Pattern Recognition Guide</h2>
            
            <div class="card">
                <div class="card-header">
                    <h3>🎯 Instant Decision Tree</h3>
                    <p>After seeing these examples, use this quick reference to choose the right data structure</p>
                </div>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-top: 30px;">
                    <div class="pattern-card" style="background: linear-gradient(135deg, rgba(0, 217, 255, 0.1), rgba(124, 58, 237, 0.1));">
                        <h4 style="color: var(--accent-cyan); margin-bottom: 1rem;">FIFO Pattern</h4>
                        <p style="font-size: 1.1rem; margin-bottom: 1rem;">Need First In First Out?</p>
                        <div style="padding: 15px; background: rgba(0, 0, 0, 0.3); border-radius: 8px; border-left: 3px solid var(--accent-cyan);">
                            <p style="color: var(--accent-cyan); font-weight: 600; margin-bottom: 10px;">→ Queue (array-based)</p>
                            <p style="color: var(--text-secondary); font-size: 0.9rem;">Perfect for: task scheduling, breadth-first search, message processing</p>
                        </div>
                    </div>

                    <div class="pattern-card" style="background: linear-gradient(135deg, rgba(124, 58, 237, 0.1), rgba(0, 217, 255, 0.1));">
                        <h4 style="color: var(--accent-purple); margin-bottom: 1rem;">LIFO Pattern</h4>
                        <p style="font-size: 1.1rem; margin-bottom: 1rem;">Need Last In First Out?</p>
                        <div style="padding: 15px; background: rgba(0, 0, 0, 0.3); border-radius: 8px; border-left: 3px solid var(--accent-purple);">
                            <p style="color: var(--accent-purple); font-weight: 600; margin-bottom: 10px;">→ Stack (array-based)</p>
                            <p style="color: var(--text-secondary); font-size: 0.9rem;">Perfect for: undo/redo, DFS, expression evaluation, call stack simulation</p>
                        </div>
                    </div>

                    <div class="pattern-card" style="background: linear-gradient(135deg, rgba(63, 185, 80, 0.1), rgba(0, 217, 255, 0.1));">
                        <h4 style="color: var(--accent-green); margin-bottom: 1rem;">Lookup Pattern</h4>
                        <p style="font-size: 1.1rem; margin-bottom: 1rem;">Need fast lookup by key?</p>
                        <div style="padding: 15px; background: rgba(0, 0, 0, 0.3); border-radius: 8px; border-left: 3px solid var(--accent-green);">
                            <p style="color: var(--accent-green); font-weight: 600; margin-bottom: 10px;">→ Hash Table</p>
                            <p style="color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 8px;">• <strong>Ordered:</strong> TreeMap</p>
                            <p style="color: var(--text-secondary); font-size: 0.9rem;">• <strong>With eviction:</strong> LRU Cache</p>
                        </div>
                    </div>

                    <div class="pattern-card" style="background: linear-gradient(135deg, rgba(247, 129, 102, 0.1), rgba(255, 193, 7, 0.1));">
                        <h4 style="color: var(--accent-orange); margin-bottom: 1rem;">Sorted Pattern</h4>
                        <p style="font-size: 1.1rem; margin-bottom: 1rem;">Need to maintain sorted order?</p>
                        <div style="padding: 15px; background: rgba(0, 0, 0, 0.3); border-radius: 8px; border-left: 3px solid var(--accent-orange);">
                            <p style="color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 8px;">• <strong>Small data:</strong> Sorted Array (binary search)</p>
                            <p style="color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 8px;">• <strong>Large data:</strong> Balanced Tree (Red-Black, AVL)</p>
                            <p style="color: var(--accent-orange); font-weight: 600;">• <strong>Just min/max:</strong> Heap</p>
                        </div>
                    </div>

                    <div class="pattern-card" style="background: linear-gradient(135deg, rgba(88, 166, 255, 0.1), rgba(63, 185, 80, 0.1));">
                        <h4 style="color: var(--accent-blue); margin-bottom: 1rem;">Index Pattern</h4>
                        <p style="font-size: 1.1rem; margin-bottom: 1rem;">Need fast access by index?</p>
                        <div style="padding: 15px; background: rgba(0, 0, 0, 0.3); border-radius: 8px; border-left: 3px solid var(--accent-blue);">
                            <p style="color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 8px;">• <strong>Fixed size:</strong> Array</p>
                            <p style="color: var(--text-secondary); font-size: 0.9rem;">• <strong>Variable size:</strong> Dynamic Array (vector, ArrayList)</p>
                        </div>
                    </div>

                    <div class="pattern-card" style="background: linear-gradient(135deg, rgba(0, 217, 255, 0.1), rgba(63, 185, 80, 0.1));">
                        <h4 style="color: var(--accent-cyan); margin-bottom: 1rem;">Both Ends Pattern</h4>
                        <p style="font-size: 1.1rem; margin-bottom: 1rem;">Fast insert/delete at both ends?</p>
                        <div style="padding: 15px; background: rgba(0, 0, 0, 0.3); border-radius: 8px; border-left: 3px solid var(--accent-cyan);">
                            <p style="color: var(--accent-cyan); font-weight: 600; margin-bottom: 10px;">→ Deque (double-ended queue)</p>
                            <p style="color: var(--text-secondary); font-size: 0.9rem;">Perfect for: sliding window, palindrome check, work stealing</p>
                        </div>
                    </div>

                    <div class="pattern-card" style="background: linear-gradient(135deg, rgba(168, 85, 247, 0.1), rgba(255, 107, 107, 0.1));">
                        <h4 style="color: var(--accent-purple); margin-bottom: 1rem;">Middle Insert Pattern</h4>
                        <p style="font-size: 1.1rem; margin-bottom: 1rem;">Fast insert/delete in middle?</p>
                        <div style="padding: 15px; background: rgba(0, 0, 0, 0.3); border-radius: 8px; border-left: 3px solid var(--accent-purple);">
                            <p style="color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 8px;">• <strong>Sequential access:</strong> Linked List</p>
                            <p style="color: var(--text-secondary); font-size: 0.9rem;">• <strong>Some random access:</strong> Skip List</p>
                        </div>
                    </div>

                    <div class="pattern-card" style="background: linear-gradient(135deg, rgba(247, 129, 102, 0.1), rgba(255, 193, 7, 0.1));">
                        <h4 style="color: var(--accent-orange); margin-bottom: 1rem;">Top-K Pattern</h4>
                        <p style="font-size: 1.1rem; margin-bottom: 1rem;">Need to track top K elements?</p>
                        <div style="padding: 15px; background: rgba(0, 0, 0, 0.3); border-radius: 8px; border-left: 3px solid var(--accent-orange);">
                            <p style="color: var(--accent-orange); font-weight: 600; margin-bottom: 10px;">→ Min/Max Heap of size K</p>
                            <p style="color: var(--text-secondary); font-size: 0.9rem;">Perfect for: leaderboards, streaming top-K, priority queues</p>
                        </div>
                    </div>

                    <div class="pattern-card" style="background: linear-gradient(135deg, rgba(63, 185, 80, 0.1), rgba(168, 85, 247, 0.1));">
                        <h4 style="color: var(--accent-green); margin-bottom: 1rem;">Range Pattern</h4>
                        <p style="font-size: 1.1rem; margin-bottom: 1rem;">Need range queries?</p>
                        <div style="padding: 15px; background: rgba(0, 0, 0, 0.3); border-radius: 8px; border-left: 3px solid var(--accent-green);">
                            <p style="color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 8px;">• <strong>Sum queries:</strong> Fenwick Tree</p>
                            <p style="color: var(--text-secondary); font-size: 0.9rem;">• <strong>Min/Max queries:</strong> Segment Tree</p>
                        </div>
                    </div>

                    <div class="pattern-card" style="background: linear-gradient(135deg, rgba(0, 217, 255, 0.1), rgba(247, 129, 102, 0.1));">
                        <h4 style="color: var(--accent-cyan); margin-bottom: 1rem;">Set Operations Pattern</h4>
                        <p style="font-size: 1.1rem; margin-bottom: 1rem;">Fast union/intersection?</p>
                        <div style="padding: 15px; background: rgba(0, 0, 0, 0.3); border-radius: 8px; border-left: 3px solid var(--accent-cyan);">
                            <p style="color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 8px;">• <strong>Small integers:</strong> Bit Set</p>
                            <p style="color: var(--text-secondary); font-size: 0.9rem;">• <strong>Large domain:</strong> Hash Set</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Additional Algorithm Patterns -->
        <section id="advanced-patterns">
            <h2>⚡ Advanced Memory Patterns</h2>
            
            <div class="card">
                <div class="card-header">
                    <h3>🎓 Advanced Techniques for Memory Optimization</h3>
                    <p>Beyond data structure selection: algorithm patterns that minimize memory while maintaining performance</p>
                </div>

                <!-- Pattern 2: Streaming Algorithms -->
                <div style="margin-top: 40px;">
                    <h3 style="color: var(--accent-purple); font-size: 1.8rem; margin-bottom: 1rem;">Pattern: Streaming Algorithms</h3>
                    <p style="font-size: 1.1rem; color: var(--text-secondary); margin-bottom: 2rem;">
                        <strong>Process data as it arrives, don't store everything.</strong> Handle infinite streams efficiently by maintaining only what's necessary.
                    </p>

                    <h4 style="margin-bottom: 1rem;">Example: Find Median of Infinite Stream</h4>

                    <div class="code-explanation">
                        <div class="explanation-header" onclick="toggleExplanation(this)">
                            <span style="font-size: 1.1rem;">❌ Naive Approach (Store Everything)</span>
                            <button class="explanation-toggle">Show Details</button>
                        </div>
                        <div class="explanation-content">
                            <div class="explanation-section">
                                <h5>Bad Solution:</h5>
                                <div class="code-container">
                                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                                    <pre><code class="language-python">class MedianNaive:
    def __init__(self):
        self.numbers = []  # Store ALL numbers
    
    def add_num(self, num):
        self.numbers.append(num)
    
    def find_median(self):
        sorted_nums = sorted(self.numbers)  # O(n log n) every time!
        n = len(sorted_nums)
        if n % 2 == 0:
            return (sorted_nums[n//2-1] + sorted_nums[n//2]) / 2
        else:
            return sorted_nums[n//2]

# After 1 million numbers: 4 MB, O(n log n) queries (SLOW!)
# After 1 BILLION numbers: 4 GB! Won't fit in RAM!</code></pre>
                                </div>

                                <div class="memory-impact">
                                    <h5>⚠️ Fatal Flaws:</h5>
                                    <ul>
                                        <li>❌ <strong>Unbounded memory growth</strong> - Stores every number forever</li>
                                        <li>❌ <strong>O(n log n) queries</strong> - Re-sorts entire array each time</li>
                                        <li>❌ <strong>Not suitable for streams</strong> - Can't handle infinite data</li>
                                    </ul>
                                </div>
                            </div>

                            <div class="explanation-section">
                                <h5>✅ Optimal: Two Heaps Architecture</h5>
                                
                                <div class="visual-diagram">
<pre>Stream: [5, 15, 1, 3, 10, 8, 2, ...]
                    ↓
        ┌───────────────────────────────┐
        │   Two Heaps Maintain Balance  │
        └───────────────────────────────┘
                    ↓
    Max Heap (small)        Min Heap (large)
    [Smaller half]          [Larger half]
         ↓                       ↓
    ┌─────────┐             ┌─────────┐
    │    3    │             │    5    │
    │   / \   │             │   / \   │
    │  1   2  │             │  8  10  │
    └─────────┘             └─────────┘

Invariants:
• All(small) ≤ All(large)
• |size(small) - size(large)| ≤ 1
• Median = top(s) or avg(top(small), top(large))

Median is always at the heap tops! O(1) access!</pre>
                                </div>

                                <div class="code-container">
                                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                                    <pre><code class="language-python">import heapq

class MedianFinder:
    def __init__(self):
        self.small = []  # Max heap (negate for Python's min heap)
        self.large = []  # Min heap
    
    def add_num(self, num):
        """Add number: O(log n)"""
        # Step 1: Add to appropriate heap
        if not self.small or num <= -self.small[0]:
            heapq.heappush(self.small, -num)
        else:
            heapq.heappush(self.large, num)
        
        # Step 2: Rebalance if needed
        if len(self.small) > len(self.large) + 1:
            val = -heapq.heappop(self.small)
            heapq.heappush(self.large, val)
        elif len(self.large) > len(self.small):
            val = heapq.heappop(self.large)
            heapq.heappush(self.small, -val)
    
    def find_median(self):
        """Get median: O(1)"""
        if len(self.small) > len(self.large):
            return -self.small[0]
        else:
            return (-self.small[0] + self.large[0]) / 2</code></pre>
                                </div>

                                <div class="performance-note">
                                    <h5>🚀 Performance Benefits:</h5>
                                    <table style="width: 100%; margin-top: 1rem;">
                                        <tr>
                                            <th>Operation</th>
                                            <th>Naive</th>
                                            <th>Two Heaps</th>
                                        </tr>
                                        <tr>
                                            <td>Add number</td>
                                            <td style="color: var(--accent-green);">O(1)</td>
                                            <td style="color: var(--accent-orange);">O(log n)</td>
                                        </tr>
                                        <tr>
                                            <td>Find median</td>
                                            <td style="color: var(--accent-red);">O(n log n)</td>
                                            <td style="color: var(--accent-green);">O(1)</td>
                                        </tr>
                                    </table>
                                    <p style="margin-top: 1rem; color: var(--accent-green); font-weight: 600;">
                                        💡 For 1M queries on 1M numbers: Naive ~20 minutes | Two Heaps ~1 second (1200x faster!)
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Pattern 3: Space-Time Tradeoff (Memoization) -->
                <div style="margin-top: 60px;">
                    <h3 style="color: var(--accent-orange); font-size: 1.8rem; margin-bottom: 1rem;">Pattern: Space-Time Tradeoff (Memoization)</h3>
                    <p style="font-size: 1.1rem; color: var(--text-secondary); margin-bottom: 2rem;">
                        <strong>Trade memory for speed by caching results.</strong> Spend memory to store computed values and dramatically reduce time complexity.
                    </p>

                    <h4 style="margin-bottom: 1rem;">Example: Fibonacci Sequence</h4>

                    <div class="code-explanation">
                        <div class="explanation-header" onclick="toggleExplanation(this)">
                            <span style="font-size: 1.1rem;">🔍 Comparison: Naive vs Memoization vs Iterative</span>
                            <button class="explanation-toggle">Show Details</button>
                        </div>
                        <div class="explanation-content">
                            <div class="explanation-section">
                                <h5>❌ Naive Recursion (Exponential Time!):</h5>
                                <div class="code-container">
                                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                                    <pre><code class="language-python">def fib_naive(n):
    if n <= 1:
        return n
    return fib_naive(n-1) + fib_naive(n-2)

# fib(30): ~1 second
# fib(40): ~30 seconds
# fib(50): ~20 MINUTES!
# fib(100): MILLIONS of years!</code></pre>
                                </div>

                                <div class="visual-diagram">
<pre>Call Tree for fib(5) - Massive Redundancy!
                    fib(5)
                   /      \
              fib(4)      fib(3)
             /     \      /    \
        fib(3)   fib(2) fib(2) fib(1)

Problem: Redundant Calculations!
fib(3) calculated: 2 times
fib(2) calculated: 3 times
Total calls for fib(50): 40 BILLION!
Time: O(2^n) - Exponential!</pre>
                                </div>
                            </div>

                            <div class="explanation-section">
                                <h5>⚡ Memoization (Trade Space for Speed):</h5>
                                <div class="code-container">
                                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                                    <pre><code class="language-python">def fib_memo(n, cache=None):
    if cache is None:
        cache = {}
    
    if n in cache:
        return cache[n]  # O(1) lookup!
    
    if n <= 1:
        return n
    
    result = fib_memo(n-1, cache) + fib_memo(n-2, cache)
    cache[n] = result
    return result

# fib(50):  Instant!
# fib(100): Instant!
# fib(1000): Still instant!
# Memory: ~7 KB for fib(100)</code></pre>
                                </div>

                                <div class="performance-note">
                                    <h5>🎯 Each fib(n) computed EXACTLY ONCE!</h5>
                                    <p>Time: O(n) - Linear! | Space: O(n) - Cache + stack</p>
                                    <p style="color: var(--accent-green); font-weight: 600;">
                                        fib(50): 40 billion calls → 50 calls (800 million x faster!)
                                    </p>
                                </div>
                            </div>

                            <div class="explanation-section">
                                <h5>✅ Iterative (Best: O(n) time, O(1) space):</h5>
                                <div class="code-container">
                                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                                    <pre><code class="language-python">def fib_optimal(n):
    if n <= 1:
        return n
    
    prev, curr = 0, 1
    for _ in range(2, n + 1):
        prev, curr = curr, prev + curr
    
    return curr

# Time: O(n) - single loop
# Space: O(1) - only two variables!
# Memory: 16 bytes (two integers)</code></pre>
                                </div>

                                <div class="best-practices">
                                    <h5>💡 Decision Guidelines:</h5>
                                    <ul>
                                        <li>❌ <strong>Naive:</strong> Never use (unless n &lt; 20)</li>
                                        <li>⚡ <strong>Memoization:</strong> When caching multiple related subproblems</li>
                                        <li>✓ <strong>Iterative:</strong> When you only need the final answer (most cases)</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Pattern 4: Lazy Evaluation -->
                <div style="margin-top: 60px;">
                    <h3 style="color: var(--accent-red); font-size: 1.8rem; margin-bottom: 1rem;">Pattern: Lazy Evaluation (Generators)</h3>
                    <p style="font-size: 1.1rem; color: var(--text-secondary); margin-bottom: 2rem;">
                        <strong>Don't compute until needed.</strong> Generate values on-demand instead of computing everything upfront. Saves massive memory and avoids wasted computation.
                    </p>

                    <h4 style="margin-bottom: 1rem;">Example: Generate Permutations</h4>

                    <div class="code-explanation">
                        <div class="explanation-header" onclick="toggleExplanation(this)">
                            <span style="font-size: 1.1rem;">🔍 Eager vs Lazy Generation</span>
                            <button class="explanation-toggle">Show Details</button>
                        </div>
                        <div class="explanation-content">
                            <div class="explanation-section">
                                <h5>❌ Eager (Generate All Upfront):</h5>
                                <div class="code-container">
                                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                                    <pre><code class="language-python">def permutations_eager(arr):
    """Generate all permutations upfront"""
    if len(arr) <= 1:
        return [arr]
    
    result = []
    for i in range(len(arr)):
        rest = arr[:i] + arr[i+1:]
        for perm in permutations_eager(rest):
            result.append([arr[i]] + perm)
    return result

perms = permutations_eager([1, 2, 3, 4, 5])  # All 120 in memory!

# n=10: 3.6M permutations = 145 MB
# n=12: 479M permutations = 19 GB (CRASH!)</code></pre>
                                </div>

                                <div class="memory-impact">
                                    <h5>Memory Explosion:</h5>
                                    <pre>n=5:   120 perms      →    5 KB
n=10:  3.6M perms     →  145 MB ⚠️
n=12:  479M perms     →   19 GB ⚠️⚠️⚠️ (RAM overflow!)</pre>
                                    <p style="color: var(--accent-red);">Even if you only need the FIRST valid permutation, you still generate ALL of them!</p>
                                </div>
                            </div>

                            <div class="explanation-section">
                                <h5>✅ Lazy (Generator - On-Demand):</h5>
                                <div class="code-container">
                                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                                    <pre><code class="language-python">def permutations_lazy(arr):
    """Generate permutations one at a time"""
    if len(arr) <= 1:
        yield arr
        return
    
    for i in range(len(arr)):
        rest = arr[:i] + arr[i+1:]
        for perm in permutations_lazy(rest):
            yield [arr[i]] + perm  # Generate on-demand!

# Find first valid permutation
for perm in permutations_lazy([1, 2, 3, 4, 5]):
    if is_valid(perm):
        print(f"Found: {perm}")
        break  # Never generates remaining 119!

# Memory: 40 bytes (current permutation only!)
# Can process n=12, n=15, even n=20!</code></pre>
                                </div>

                                <div class="visual-diagram">
<pre>Generator State Machine:
Call next():
  ├─ Generate [1,2,3] ─────► Yield to caller
  │                          (caller processes)
  ├─ Resume here ◄───────────┘
  ├─ Generate [1,3,2] ─────► Yield to caller

Memory: Only ONE permutation at a time (40 bytes)
vs 145 MB eager for n=10!

When caller breaks: Generator stops, remaining NEVER generated!</pre>
                                </div>

                                <div class="performance-note">
                                    <h5>🚀 Performance Impact:</h5>
                                    <table style="width: 100%; margin-top: 1rem;">
                                        <tr>
                                            <th>Array Length</th>
                                            <th>Eager Memory</th>
                                            <th>Lazy Memory</th>
                                            <th>Savings</th>
                                        </tr>
                                        <tr>
                                            <td>n=10</td>
                                            <td style="color: var(--accent-red);">145 MB</td>
                                            <td style="color: var(--accent-green);">40 bytes</td>
                                            <td>3,625x</td>
                                        </tr>
                                        <tr>
                                            <td>n=12</td>
                                            <td style="color: var(--accent-red);">19 GB (crash)</td>
                                            <td style="color: var(--accent-green);">48 bytes</td>
                                            <td>∞ (enables solution!)</td>
                                        </tr>
                                    </table>
                                </div>
                            </div>

                            <div class="explanation-section">
                                <h5>🌍 Real-World: Reading Large Files</h5>
                                <div class="code-container">
                                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                                    <pre><code class="language-python"># ❌ Eager: Load entire file
def process_eager(filename):
    lines = open(filename).readlines()  # ⚠️ ALL in memory!
    for line in lines:
        process(line)
# 10 GB file = 10 GB RAM needed!

# ✅ Lazy: Stream line by line
def process_lazy(filename):
    for line in open(filename):  # Generator!
        process(line)
# 10 GB file = ~100 bytes RAM!</code></pre>
                                </div>

                                <div class="best-practices">
                                    <h5>💡 When to Use Lazy Evaluation:</h5>
                                    <ul>
                                        <li>✓ Processing large files (streaming)</li>
                                        <li>✓ Generating sequences (might not need all)</li>
                                        <li>✓ Infinite sequences (Fibonacci stream)</li>
                                        <li>✓ Pipeline transformations (map/filter chains)</li>
                                        <li>✓ Early termination possible (find first match)</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Cache-Conscious Programming -->
        <section id="cache">
            <h2>🚀 Cache-Conscious Optimization</h2>
            
            <div class="card">
                <div class="card-header">
                    <div class="icon">💨</div>
                    <h3>Why Cache Matters</h3>
                </div>
                <p>Modern CPUs have a massive speed gap between cache (L1: 4 cycles, 1ns) and RAM (200+ cycles, 100ns). Code that fits in cache can be 100x faster than cache-missing code with the same Big-O complexity.</p>
                
                <ul class="feature-list">
                    <li><strong>L1 Cache:</strong> 32-64 KB, 4 cycles (~1ns)</li>
                    <li><strong>L2 Cache:</strong> 256-512 KB, 12 cycles (~3ns)</li>
                    <li><strong>L3 Cache:</strong> 8-32 MB, 40 cycles (~10ns)</li>
                    <li><strong>RAM:</strong> GBs, 200+ cycles (~100ns)</li>
                </ul>

                <div class="callout warning">
                    <div class="callout-title">⚠️ Cache Miss Cost</div>
                    <p>A single cache miss costs 100+ cycles. For algorithms with billions of operations, cache optimization can provide 10x+ speedups even with the same algorithmic complexity!</p>
                </div>
            </div>

            <div class="card">
                <h3>Technique 1: Sequential Access Pattern</h3>
                
                <div class="code-container">
                    <div class="code-title">
                        ❌ Bad: Column-wise Matrix Access (Cache Killer)
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="keyword">def</span> <span class="function">matrix_sum_by_column</span>(matrix):
    <span class="string">"""Process each column - TERRIBLE for cache!"""</span>
    total = <span class="number">0</span>
    <span class="keyword">for</span> col <span class="keyword">in</span> <span class="function">range</span>(<span class="function">len</span>(matrix[<span class="number">0</span>])):
        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="function">range</span>(<span class="function">len</span>(matrix)):
            total += matrix[row][col]  <span class="comment"># ❌ Jumps by 1000s of bytes!</span>
    <span class="keyword">return</span> total

<span class="comment"># Memory layout (row-major):</span>
<span class="comment"># [row0: a,b,c,d] [row1: e,f,g,h] [row2: i,j,k,l]</span>
<span class="comment"># Access pattern: a → e → i (thousands of bytes apart!)</span>
<span class="comment"># Cache line (64 bytes) holds a,b,c,d but we only use 'a'!</span>
<span class="comment"># Result: 0% cache hit rate ❌</span></code></pre>
                </div>

                <div class="code-container" style="margin-top: 2rem;">
                    <div class="code-title">
                        ✅ Good: Row-wise Matrix Access (Cache Friendly)
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code><span class="keyword">def</span> <span class="function">matrix_sum_by_row</span>(matrix):
    <span class="string">"""Process each row - EXCELLENT for cache!"""</span>
    total = <span class="number">0</span>
    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="function">range</span>(<span class="function">len</span>(matrix)):
        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="function">range</span>(<span class="function">len</span>(matrix[<span class="number">0</span>])):
            total += matrix[row][col]  <span class="comment"># ✅ Sequential access!</span>
    <span class="keyword">return</span> total

<span class="comment"># Access pattern: a → b → c → d (contiguous!)</span>
<span class="comment"># Cache line holds a,b,c,d and we use ALL of them!</span>
<span class="comment"># Result: 94% cache hit rate ✅</span>
<span class="comment"># Performance: 6x faster on 1000×1000 matrix!</span></code></pre>
                </div>

                <div class="code-explanation">
                    <div class="explanation-header" onclick="toggleExplanation(this)">
                        <div class="explanation-title">
                            🔍 <span>Cache Line Behavior Analysis</span>
                        </div>
                        <button class="explanation-toggle">Show Details</button>
                    </div>
                    <div class="explanation-content">
                        <div class="explanation-section">
                            <h4>🏗️ How CPU Cache Lines Work</h4>
                            <div class="visual-diagram">
<pre>Cache Line Concept (64-byte chunks):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Matrix in memory (row-major):
[0,0] [0,1] [0,2] [0,3] | [1,0] [1,1] [1,2] [1,3]
  a     b     c     d   |   e     f     g     h
└─────────────────────┘   └─────────────────────┘
   Cache Line 1              Cache Line 2

Column access (BAD):
Step 1: Access [0,0] → Load cache line 1 (a,b,c,d)
Step 2: Access [1,0] → Load cache line 2 (e,f,g,h)
Step 3: Access [2,0] → Load cache line 3 (i,j,k,l)
Each access = cache MISS! ❌
Used data: a, e, i (3 elements)
Loaded data: a,b,c,d,e,f,g,h,i,j,k,l (12 elements)
Efficiency: 25% (wasted 75% of loaded data!)

Row access (GOOD):
Step 1: Access [0,0] → Load cache line 1 (a,b,c,d)
Step 2: Access [0,1] → Cache HIT! (b already loaded)
Step 3: Access [0,2] → Cache HIT! (c already loaded)  
Step 4: Access [0,3] → Cache HIT! (d already loaded)
One load serves 4 accesses! ✅
Efficiency: 100% (use all loaded data)</pre>
                            </div>
                        </div>

                        <div class="memory-impact">
                            <h5>📊 Real-World Benchmark (1000×1000 Matrix)</h5>
                            <ul style="margin-left: 1.5rem; margin-top: 0.5rem; line-height: 1.8;">
                                <li><strong>Column-wise:</strong> 30 seconds, 1 billion cache misses</li>
                                <li><strong>Row-wise:</strong> 5 seconds, 60 million cache misses (6x faster!)</li>
                                <li><strong>Cache hit rate:</strong> 0% vs 94%</li>
                                <li><strong>Same algorithm, same O(n²) complexity, 6x performance difference!</strong></li>
                            </ul>
                        </div>

                        <div class="best-practices">
                            <h5>✅ Cache-Friendly Programming Rules</h5>
                            <ul style="margin-left: 1.5rem; margin-top: 0.5rem; line-height: 1.8;">
                                <li><strong>Rule 1:</strong> Access memory sequentially when possible</li>
                                <li><strong>Rule 2:</strong> Keep working set small (< 32 KB for L1)</li>
                                <li><strong>Rule 3:</strong> Use contiguous structures (arrays) over scattered ones (linked lists)</li>
                                <li><strong>Rule 4:</strong> Process data in blocks that fit in cache</li>
                                <li><strong>Rule 5:</strong> Prefer depth-first over breadth-first for trees</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Decision Checklist -->
        <section id="checklist">
            <h2>✅ Memory Decision Checklist</h2>
            
            <div class="card">
                <div class="card-header">
                    <div class="icon">📋</div>
                    <h3>Systematic Evaluation Framework</h3>
                </div>
                <p>Before writing code, run through this checklist to ensure optimal memory and performance characteristics:</p>
            </div>

            <div class="pattern-grid">
                <div class="pattern-card green">
                    <span class="pattern-icon">🔍</span>
                    <div class="pattern-title">1. Identify Access Pattern</div>
                    <ul style="margin-left: 1.5rem; margin-top: 0.8rem; line-height: 1.8;">
                        <li>Lookup by key? → Hash Map</li>
                        <li>FIFO? → Queue/Deque</li>
                        <li>LIFO? → Stack</li>
                        <li>Sorted? → Tree/Heap</li>
                        <li>Top-K? → Min/Max Heap</li>
                    </ul>
                </div>

                <div class="pattern-card blue">
                    <span class="pattern-icon">📊</span>
                    <div class="pattern-title">2. Evaluate Data Size</div>
                    <ul style="margin-left: 1.5rem; margin-top: 0.8rem; line-height: 1.8;">
                        <li>< 100 items? Simple array OK</li>
                        <li>< 10K? Any structure works</li>
                        <li>> 100K? Consider cache</li>
                        <li>> 1M? Memory critical</li>
                    </ul>
                </div>

                <div class="pattern-card orange">
                    <span class="pattern-icon">⏱️</span>
                    <div class="pattern-title">3. Time Requirements</div>
                    <ul style="margin-left: 1.5rem; margin-top: 0.8rem; line-height: 1.8;">
                        <li>Real-time? Worst-case guarantees</li>
                        <li>Interactive? Average-case focus</li>
                        <li>Batch? Throughput priority</li>
                        <li>Optimize hot path first</li>
                    </ul>
                </div>

                <div class="pattern-card purple">
                    <span class="pattern-icon">💾</span>
                    <div class="pattern-title">4. Memory Constraints</div>
                    <ul style="margin-left: 1.5rem; margin-top: 0.8rem; line-height: 1.8;">
                        <li>Embedded? Minimal allocation</li>
                        <li>Mobile? Memory-conscious</li>
                        <li>Server? Balanced</li>
                        <li>Cloud? Speed over memory</li>
                    </ul>
                </div>
            </div>

            <div class="callout success">
                <div class="callout-title">🎯 Final Pro Tips</div>
                <ul style="margin-left: 1.5rem; margin-top: 0.8rem; line-height: 1.8;">
                    <li><strong>Measure, don't guess:</strong> Profile before optimizing</li>
                    <li><strong>Cache matters more than Big-O</strong> for modern hardware</li>
                    <li><strong>Start simple,</strong> optimize only proven bottlenecks</li>
                    <li><strong>The best code</strong> is readable AND fast</li>
                </ul>
            </div>
        </section>

        <!-- Real-World LRU Cache Implementation -->
        <section id="lru-cache" style="margin-top: 4rem;">
            <h2>🏗️ Real-World Design: LRU Cache</h2>
            
            <div class="card">
                <div class="card-header">
                    <h3 style="color: var(--accent-cyan);">📋 Design Challenge: Least Recently Used Cache</h3>
                    <p style="margin-top: 1rem;">Build a cache with:</p>
                    <ul style="margin-left: 2rem; margin-top: 0.8rem; line-height: 1.8;">
                        <li><strong>Get(key):</strong> O(1)</li>
                        <li><strong>Put(key, value):</strong> O(1)</li>
                        <li><strong>Eviction:</strong> Least recently used when full</li>
                        <li><strong>Capacity:</strong> 10,000 entries</li>
                    </ul>
                </div>

                <!-- Option 1: Array (Rejected) -->
                <div class="code-explanation" style="margin-top: 2rem;">
                    <div class="explanation-header" onclick="toggleExplanation(this)">
                        <span style="font-size: 1.1rem;">❌ Option 1: Array + Timestamps (REJECTED)</span>
                        <button class="explanation-toggle">Show Details</button>
                    </div>
                    <div class="explanation-content">
                        <div class="explanation-section">
                            <div class="code-container">
                                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                                <pre><code class="language-python">class LRUArray:
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = []  # [(key, value, timestamp), ...]
        self.time = 0
    
    def get(self, key):
        # ❌ Find key: O(n) - VIOLATES REQUIREMENT
        for i, (k, v, t) in enumerate(self.cache):
            if k == key:
                self.cache[i] = (k, v, self.time)
                self.time += 1
                return v
        return None
    
    def put(self, key, value):
        # ❌ Find if exists: O(n)
        # ❌ Find LRU: O(n)
        # ❌ Total: O(n) - VIOLATES REQUIREMENT
        pass</code></pre>
                            </div>

                            <div class="memory-impact">
                                <h5>❌ Why This Fails:</h5>
                                <ul>
                                    <li>❌ <strong>Get operation:</strong> Must scan entire array → O(n)</li>
                                    <li>❌ <strong>Put operation:</strong> Must find LRU by scanning timestamps → O(n)</li>
                                    <li>❌ <strong>For 10,000 entries:</strong> Average 5,000 comparisons per operation</li>
                                    <li>❌ <strong>Result:</strong> Cannot meet O(1) requirement</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Option 2: Hash Map Only (Partial) -->
                <div class="code-explanation" style="margin-top: 2rem;">
                    <div class="explanation-header" onclick="toggleExplanation(this)">
                        <span style="font-size: 1.1rem;">⚠️ Option 2: Hash Map Only (PARTIAL)</span>
                        <button class="explanation-toggle">Show Details</button>
                    </div>
                    <div class="explanation-content">
                        <div class="explanation-section">
                            <div class="code-container">
                                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                                <pre><code class="language-python">class LRUHashMap:
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = {}  # {key: (value, timestamp)}
        self.time = 0
    
    def get(self, key):
        if key in self.cache:  # ✓ O(1)
            value, _ = self.cache[key]
            self.cache[key] = (value, self.time)
            self.time += 1
            return value
        return None
    
    def put(self, key, value):
        if len(self.cache) >= self.capacity and key not in self.cache:
            # ❌ Find LRU: O(n) - VIOLATES REQUIREMENT
            lru_key = min(self.cache, key=lambda k: self.cache[k][1])
            del self.cache[lru_key]
        
        self.cache[key] = (value, self.time)
        self.time += 1</code></pre>
                            </div>

                            <div class="performance-note" style="border-color: var(--accent-orange);">
                                <h5>⚠️ Partial Solution:</h5>
                                <ul>
                                    <li>✓ <strong>Get operation:</strong> O(1) lookup and update</li>
                                    <li>❌ <strong>Eviction:</strong> Must scan all entries to find minimum timestamp → O(n)</li>
                                    <li>⚠️ <strong>Problem:</strong> Hash map doesn't maintain order</li>
                                    <li>⚠️ <strong>Result:</strong> Good for reads, poor for capacity-limited caches</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Option 3: Hash Map + Doubly Linked List (OPTIMAL) -->
                <div class="code-explanation" style="margin-top: 2rem;">
                    <div class="explanation-header" onclick="toggleExplanation(this)">
                        <span style="font-size: 1.1rem;">✅ Option 3: Hash Map + Doubly Linked List (OPTIMAL)</span>
                        <button class="explanation-toggle">Show Details</button>
                    </div>
                    <div class="explanation-content">
                        <div class="explanation-section">
                            <h5>🎯 The Hybrid Approach:</h5>
                            <div class="code-container">
                                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                                <pre><code class="language-python">class Node:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None

class LRUOptimal:
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = {}  # {key: Node}
        
        # Dummy head and tail for easy insertion/deletion
        self.head = Node(0, 0)
        self.tail = Node(0, 0)
        self.head.next = self.tail
        self.tail.prev = self.head
    
    def _remove(self, node):
        """Remove node from linked list: O(1)"""
        prev_node = node.prev
        next_node = node.next
        prev_node.next = next_node
        next_node.prev = prev_node
    
    def _add_to_head(self, node):
        """Add node right after head: O(1)"""
        node.next = self.head.next
        node.prev = self.head
        self.head.next.prev = node
        self.head.next = node
    
    def get(self, key):
        """O(1) operation"""
        if key in self.cache:
            node = self.cache[key]
            # Move to front (most recently used)
            self._remove(node)
            self._add_to_head(node)
            return node.value
        return None
    
    def put(self, key, value):
        """O(1) operation"""
        if key in self.cache:
            # Update existing
            node = self.cache[key]
            node.value = value
            self._remove(node)
            self._add_to_head(node)
        else:
            # Add new
            if len(self.cache) >= self.capacity:
                # Evict LRU (tail.prev)
                lru = self.tail.prev
                self._remove(lru)
                del self.cache[lru.key]
            
            new_node = Node(key, value)
            self._add_to_head(new_node)
            self.cache[key] = new_node

# ✅ All operations O(1)</code></pre>
                            </div>

                            <div class="visual-diagram">
<pre>Hybrid Data Structure Visualization:

Hash Map:                    Linked List (recency order):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
{                            Head ⇄ [Node C] ⇄ [Node A] ⇄ [Node B] ⇄ Tail
  'A': Node A  ───────────────────────────────┘            │
  'B': Node B  ──────────────────────────────────────────────────┘
  'C': Node C  ────────────┘
}

Operations:

1. get('A'):
   ├─ Hash map lookup: O(1) ✓
   ├─ Remove Node A from middle: O(1) ✓
   └─ Add Node A to head: O(1) ✓
   
   Result: Head ⇄ [Node A] ⇄ [Node C] ⇄ [Node B] ⇄ Tail

2. put('D', value) when full:
   ├─ Identify LRU (tail.prev = Node B): O(1) ✓
   ├─ Remove Node B: O(1) ✓
   ├─ Delete from hash map: O(1) ✓
   ├─ Create Node D: O(1) ✓
   └─ Add to head: O(1) ✓
   
   Result: Head ⇄ [Node D] ⇄ [Node A] ⇄ [Node C] ⇄ Tail

Memory Layout:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Per entry: key (8B) + value (8B) + prev (8B) + next (8B)
Total per entry: 32 bytes
Hash map overhead: ×1.5
Total: 10,000 × 32 × 1.5 = 480 KB

Tradeoff: Used more memory (pointers) to achieve O(1) time</pre>
                            </div>

                            <div class="best-practices">
                                <h5>💡 Why This Design Works:</h5>
                                <p style="margin-bottom: 1rem;"><strong>Hash Map Contribution:</strong></p>
                                <ul style="margin-left: 1.5rem; margin-bottom: 1rem;">
                                    <li>✓ Provides O(1) lookup by key</li>
                                    <li>✗ But doesn't maintain order</li>
                                </ul>
                                
                                <p style="margin-bottom: 1rem;"><strong>Doubly Linked List Contribution:</strong></p>
                                <ul style="margin-left: 1.5rem; margin-bottom: 1rem;">
                                    <li>✓ Maintains order (head = most recent, tail = least recent)</li>
                                    <li>✓ O(1) insertion/deletion with node reference</li>
                                    <li>✗ But O(n) search</li>
                                </ul>
                                
                                <p style="margin-bottom: 1rem;"><strong>Combined:</strong></p>
                                <ul style="margin-left: 1.5rem;">
                                    <li>🎯 Hash map stores key → node reference</li>
                                    <li>🎯 Linked list maintains recency order</li>
                                    <li>🎯 Together: O(1) for ALL operations!</li>
                                    <li>🎯 Classic example of hybrid data structures</li>
                                </ul>
                            </div>

                            <div class="performance-note">
                                <h5>🚀 Performance Comparison:</h5>
                                <table style="width: 100%; margin-top: 1rem;">
                                    <tr>
                                        <th>Approach</th>
                                        <th>Get</th>
                                        <th>Put</th>
                                        <th>Memory/Entry</th>
                                        <th>Verdict</th>
                                    </tr>
                                    <tr>
                                        <td>Array + Timestamps</td>
                                        <td style="color: var(--accent-red);">O(n)</td>
                                        <td style="color: var(--accent-red);">O(n)</td>
                                        <td>24 bytes</td>
                                        <td style="color: var(--accent-red);">❌ Rejected</td>
                                    </tr>
                                    <tr>
                                        <td>Hash Map Only</td>
                                        <td style="color: var(--accent-green);">O(1)</td>
                                        <td style="color: var(--accent-red);">O(n)</td>
                                        <td>20 bytes</td>
                                        <td style="color: var(--accent-orange);">⚠️ Partial</td>
                                    </tr>
                                    <tr>
                                        <td>HashMap + DLL</td>
                                        <td style="color: var(--accent-green);">O(1)</td>
                                        <td style="color: var(--accent-green);">O(1)</td>
                                        <td>48 bytes</td>
                                        <td style="color: var(--accent-green);">✅ OPTIMAL</td>
                                    </tr>
                                </table>
                            </div>

                            <div class="callout success">
                                <div class="callout-title">🎓 Design Lesson</div>
                                <p>This is a classic example of <strong>hybrid data structures</strong> - combining two structures to get the best of both worlds. Neither hash map nor linked list alone could achieve O(1) for all operations, but together they form the perfect solution.</p>
                                <p style="margin-top: 1rem;">This pattern appears in many real-world systems: databases, web caching, memory managers, and more!</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Conclusion -->
        <section style="margin-top: 4rem; margin-bottom: 4rem;">
            <div class="card" style="background: linear-gradient(135deg, rgba(0, 217, 255, 0.1), rgba(168, 85, 247, 0.1)); border-color: var(--accent-cyan);">
                <div class="card-header">
                    <div class="icon">🎓</div>
                    <h3>You've Mastered Memory Patterns!</h3>
                </div>
                <p style="font-size: 1.1rem; margin-bottom: 1.5rem;">You now understand how to choose the right data structure based on access patterns, optimize for cache performance, and make informed memory/time trade-offs. These skills separate senior engineers from beginners.</p>
                
                <div class="callout">
                    <div class="callout-title">🚀 Key Takeaways</div>
                    <ul class="feature-list" style="margin-top: 1rem;">
                        <li><strong>Pattern matching:</strong> Let the problem guide your structure choice</li>
                        <li><strong>Cache is king:</strong> Sequential access beats random 100:1</li>
                        <li><strong>Measure reality:</strong> Big-O doesn't tell the whole story</li>
                        <li><strong>Think in systems:</strong> Memory, cache, and time are all connected</li>
                    </ul>
                </div>

                <div style="text-align: center; margin-top: 2rem; padding: 2rem; background: rgba(88, 166, 255, 0.05); border-radius: 8px;">
                    <p style="font-size: 1.2rem; color: var(--accent-cyan); font-weight: 600;">
                        "The fastest data structure is the one that matches your access pattern."
                    </p>
                    <p style="margin-top: 1rem; color: var(--text-muted);">
                        Now go build something amazing! 🎉
                    </p>
                </div>
            </div>
        </section>
        
    </main>

    <script>
        // Progress Bar
        window.addEventListener('scroll', () => {
            const winScroll = document.body.scrollTop || document.documentElement.scrollTop;
            const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
            const scrolled = (winScroll / height) * 100;
            document.getElementById('progressBar').style.width = scrolled + '%';
        });

        // Toggle Explanation with Animation
        function toggleExplanation(header) {
            const content = header.nextElementSibling;
            const button = header.querySelector('.explanation-toggle');
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                button.textContent = 'Show Details';
                button.style.background = 'var(--accent-blue)';
                
                // Smooth scroll back to header
                header.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            } else {
                // Close other expanded explanations in the same card
                const card = header.closest('.card');
                if (card) {
                    card.querySelectorAll('.explanation-content.expanded').forEach(other => {
                        if (other !== content) {
                            other.classList.remove('expanded');
                            const otherButton = other.previousElementSibling.querySelector('.explanation-toggle');
                            if (otherButton) {
                                otherButton.textContent = 'Show Details';
                                otherButton.style.background = 'var(--accent-blue)';
                            }
                        }
                    });
                }
                
                content.classList.add('expanded');
                button.textContent = 'Hide Details';
                button.style.background = 'var(--accent-red)';
                
                // Add entrance animation to sections
                setTimeout(() => {
                    content.querySelectorAll('.explanation-section').forEach((section, index) => {
                        setTimeout(() => {
                            section.style.opacity = '0';
                            section.style.transform = 'translateY(10px)';
                            section.style.transition = 'all 0.3s ease';
                            setTimeout(() => {
                                section.style.opacity = '1';
                                section.style.transform = 'translateY(0)';
                            }, 10);
                        }, index * 100);
                    });
                }, 100);
            }
        }

        // Copy Code with Enhanced Feedback
        function copyCode(button) {
            const codeBlock = button.closest('.code-container').querySelector('pre code');
            const text = codeBlock.textContent;
            
            navigator.clipboard.writeText(text).then(() => {
                const originalText = button.textContent;
                const originalBg = button.style.background;
                
                button.textContent = '✓ Copied!';
                button.style.background = 'var(--accent-green)';
                button.style.transform = 'scale(1.1)';
                
                // Show notification
                showNotification('Code copied to clipboard!', 'success');
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = originalBg;
                    button.style.transform = 'scale(1)';
                }, 2000);
            }).catch(err => {
                showNotification('Failed to copy code', 'error');
                console.error('Copy failed:', err);
            });
        }

        // Show Notification
        function showNotification(message, type = 'success') {
            // Remove existing notification if any
            const existing = document.querySelector('.notification');
            if (existing) {
                existing.remove();
            }

            const notification = document.createElement('div');
            notification.className = 'notification show';
            notification.textContent = message;
            
            if (type === 'error') {
                notification.style.background = 'var(--accent-red)';
            }
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        // Active nav link on scroll
        const sections = document.querySelectorAll('section[id]');
        const navLinks = document.querySelectorAll('.nav-links a');

        window.addEventListener('scroll', () => {
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.clientHeight;
                if (pageYOffset >= sectionTop - 200) {
                    current = section.getAttribute('id');
                }
            });

            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href').slice(1) === current) {
                    link.classList.add('active');
                }
            });
        });

        // Smooth scroll with offset for fixed nav
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    const offset = 80; // Account for fixed nav
                    const targetPosition = target.getBoundingClientRect().top + window.pageYOffset - offset;
                    
                    window.scrollTo({
                        top: targetPosition,
                        behavior: 'smooth'
                    });
                }
            });
        });

        // Intersection Observer for fade-in animations
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('fade-in');
                    observer.unobserve(entry.target); // Only animate once
                }
            });
        }, { threshold: 0.1, rootMargin: '0px 0px -50px 0px' });

        document.querySelectorAll('.card, .pattern-card, .callout').forEach(el => {
            observer.observe(el);
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ctrl/Cmd + K to focus search (if implemented)
            if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                e.preventDefault();
                // Future: Add search functionality
            }
            
            // ESC to close all expanded explanations
            if (e.key === 'Escape') {
                document.querySelectorAll('.explanation-content.expanded').forEach(content => {
                    content.classList.remove('expanded');
                    const button = content.previousElementSibling.querySelector('.explanation-toggle');
                    if (button) {
                        button.textContent = 'Show Details';
                        button.style.background = 'var(--accent-blue)';
                    }
                });
            }
        });

        // Performance monitoring
        window.addEventListener('load', () => {
            const loadTime = performance.now();
            console.log(`✅ Page loaded in ${loadTime.toFixed(2)}ms`);
            
            // Log performance metrics
            if (performance.getEntriesByType) {
                const perfData = performance.getEntriesByType('navigation')[0];
                if (perfData) {
                    console.log('📊 Performance Metrics:');
                    console.log(`   DOM Content Loaded: ${perfData.domContentLoadedEventEnd - perfData.domContentLoadedEventStart}ms`);
                    console.log(`   Total Load Time: ${perfData.loadEventEnd - perfData.loadEventStart}ms`);
                }
            }
        });

        // Add hover effect to code lines
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.code-line').forEach(line => {
                line.addEventListener('mouseenter', function() {
                    this.style.background = 'rgba(88, 166, 255, 0.1)';
                });
                
                line.addEventListener('mouseleave', function() {
                    this.style.background = '';
                });
            });

            // Add copy functionality to visual diagrams
            document.querySelectorAll('.visual-diagram').forEach(diagram => {
                const copyBtn = document.createElement('button');
                copyBtn.className = 'copy-btn';
                copyBtn.textContent = 'Copy Diagram';
                copyBtn.style.position = 'absolute';
                copyBtn.style.top = '10px';
                copyBtn.style.right = '10px';
                
                diagram.style.position = 'relative';
                diagram.appendChild(copyBtn);
                
                copyBtn.addEventListener('click', function() {
                    const text = diagram.querySelector('pre')?.textContent || diagram.textContent;
                    navigator.clipboard.writeText(text).then(() => {
                        const original = this.textContent;
                        this.textContent = '✓ Copied!';
                        this.style.background = 'var(--accent-green)';
                        
                        setTimeout(() => {
                            this.textContent = original;
                            this.style.background = '';
                        }, 2000);
                    });
                });
            });

            // Add reading progress indicator
            console.log('📚 Memory Patterns Guide loaded successfully!');
            console.log('💡 Tip: Use ESC to close expanded sections');
            console.log('💡 Tip: Click "Copy" buttons to save code snippets');
        });

        // Track scroll depth for analytics (optional)
        let maxScroll = 0;
        window.addEventListener('scroll', () => {
            const scrollPercentage = (window.scrollY / (document.documentElement.scrollHeight - window.innerHeight)) * 100;
            if (scrollPercentage > maxScroll) {
                maxScroll = Math.round(scrollPercentage);
                // Could send to analytics here
            }
        });

        // Add table of contents highlighting
        const tocObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const id = entry.target.getAttribute('id');
                    navLinks.forEach(link => {
                        if (link.getAttribute('href') === `#${id}`) {
                            link.style.color = 'var(--accent-cyan)';
                        } else {
                            link.style.color = '';
                        }
                    });
                }
            });
        }, { threshold: 0.3 });

        sections.forEach(section => {
            if (section.id) {
                tocObserver.observe(section);
            }
        });
    </script>
</body>
</html>