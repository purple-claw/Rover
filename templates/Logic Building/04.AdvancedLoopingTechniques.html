<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rover - Advanced Looping Techniques</title>
    <style>
        /* ==================== FONT IMPORT ==================== */
        @import url('https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400;500;600;700&display=swap');

        /* ==================== GLASSMORPHISM THEME ==================== */
        :root {
            /* Pure Black Base */
            --bg-primary: #000000;
            --bg-secondary: #0a0a0a;
            
            /* Glass Effect Colors */
            --glass-white: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-highlight: rgba(255, 255, 255, 0.15);
            
            /* McLaren Orange */
            --mclaren-orange: #FF8000;
            --mclaren-glow: rgba(255, 128, 0, 0.3);
            --mclaren-light: #FFA040;
            --mclaren-dark: #CC6600;
            
            /* RedBull Red */
            --redbull-red: #DC0000;
            --redbull-blue: #1E41FF;
            --redbull-glow: rgba(220, 0, 0, 0.3);
            --redbull-light: #FF3333;
            
            /* Meta Blue */
            --meta-blue: #0081FB;
            --meta-glow: rgba(0, 129, 251, 0.3);
            --meta-light: #33A3FF;
            --meta-dark: #0066CC;
            
            /* Text Colors - Ultra White */
            --text-primary: #FFFFFF;
            --text-secondary: #FFFFFF;
            --text-muted: rgba(255, 255, 255, 0.9);
            --text-dim: rgba(255, 255, 255, 0.7);
            
            /* Code Syntax */
            --code-bg: rgba(20, 20, 20, 0.6);
            --code-keyword: #FF8000;
            --code-function: #0081FB;
            --code-string: #3fb950;
            --code-comment: rgba(255, 255, 255, 0.4);
            --code-number: #DC0000;
            --code-variable: #FFA040;
            
            /* Layout */
            --container-width: 1100px;
            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 2.5rem;
            --spacing-2xl: 3rem;
            
            /* Border Radius */
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-xl: 24px;
            
            /* Animations */
            --transition-fast: 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-normal: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            overflow-x: hidden;
            width: 100%;
        }

        body {
            font-family: 'Quicksand', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #000000;
            color: #FFFFFF;
            line-height: 1.7;
            overflow-x: hidden;
            position: relative;
            font-size: 16px;
            font-weight: 400;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            width: 100%;
            max-width: 100vw;
        }

        h1, h2, h3, h4 {
            font-family: 'Quicksand', sans-serif;
            font-weight: 600;
            letter-spacing: -0.03em;
        }

        code, pre {
            font-family: 'Courier New', monospace;
            font-weight: 400;
        }

        /* Progress Bar */
        #reading-progress {
            position: fixed;
            top: 0;
            left: 0;
            width: 0%;
            height: 3px;
            background: linear-gradient(90deg, var(--mclaren-orange), var(--mclaren-light));
            box-shadow: 0 0 10px var(--mclaren-glow);
            z-index: 9999;
            transition: width 0.1s ease;
        }

        /* Glass Container */
        .container {
            max-width: var(--container-width);
            margin: 0 auto;
            padding: 0 var(--spacing-lg);
            position: relative;
            z-index: 1;
        }

        /* Navigation */
        nav {
            position: sticky;
            top: 0;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(24px) saturate(180%);
            -webkit-backdrop-filter: blur(24px) saturate(180%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.12);
            padding: 0.75rem 0;
            box-shadow: 
                0 1px 3px rgba(0, 0, 0, 0.5),
                0 1px 20px rgba(255, 128, 0, 0.1),
                inset 0 -1px 0 rgba(255, 255, 255, 0.05);
        }

        nav::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, 
                transparent,
                rgba(255, 128, 0, 0.3) 20%,
                rgba(255, 128, 0, 0.5) 50%,
                rgba(255, 128, 0, 0.3) 80%,
                transparent
            );
            opacity: 0.8;
        }

        .nav-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 2rem;
            padding: 0 var(--spacing-lg);
            max-width: var(--container-width);
            margin: 0 auto;
        }

        .nav-logo {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--mclaren-orange);
            text-decoration: none;
            letter-spacing: 0.1em;
        }

        .nav-links {
            display: flex;
            gap: 2rem;
            list-style: none;
        }

        .nav-link {
            color: rgba(255, 255, 255, 0.8);
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            transition: all var(--transition-fast);
            position: relative;
            padding: 0.5rem 0;
        }

        .nav-link:hover {
            color: var(--mclaren-orange);
            text-shadow: 0 0 20px var(--mclaren-glow);
        }

        .nav-link.active::after {
            content: '';
            position: absolute;
            bottom: -3px;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--mclaren-orange);
            box-shadow: 0 0 10px var(--mclaren-glow);
        }

        /* Hamburger Menu */
        .hamburger {
            display: none;
            flex-direction: column;
            gap: 5px;
            background: none;
            border: none;
            cursor: pointer;
            padding: 8px;
            z-index: 1001;
        }

        .hamburger span {
            display: block;
            width: 25px;
            height: 2px;
            background: var(--mclaren-orange);
            transition: all 0.3s ease;
            border-radius: 2px;
        }

        .hamburger.active span:nth-child(1) {
            transform: rotate(45deg) translate(7px, 7px);
        }

        .hamburger.active span:nth-child(2) {
            opacity: 0;
        }

        .hamburger.active span:nth-child(3) {
            transform: rotate(-45deg) translate(7px, -7px);
        }

        .mobile-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 999;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .mobile-overlay.active {
            display: block;
            opacity: 1;
        }

        /* Hero Section */
        .hero {
            padding: var(--spacing-2xl) 0;
            text-align: center;
            position: relative;
            margin-bottom: var(--spacing-xl);
            z-index: 1;
        }

        .hero h1 {
            font-size: 3.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: var(--mclaren-orange);
            background: linear-gradient(135deg, 
                var(--mclaren-orange) 0%, 
                var(--mclaren-light) 50%, 
                var(--mclaren-orange) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: glow 3s ease-in-out infinite;
        }

        @supports not (background-clip: text) {
            .hero h1 {
                color: var(--mclaren-orange) !important;
                -webkit-text-fill-color: var(--mclaren-orange) !important;
            }
        }

        @keyframes glow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2); }
        }

        .hero p {
            font-size: 1.3rem;
            color: var(--text-muted);
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
        }

        /* Section Styling */
        .section {
            margin-bottom: var(--spacing-2xl);
            opacity: 0;
            transform: translateY(30px);
            transition: all 0.8s ease;
        }

        .section.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .section-header {
            margin-bottom: var(--spacing-lg);
            padding-bottom: var(--spacing-sm);
            border-bottom: 1px solid var(--glass-border);
        }

        .section-title {
            font-size: 2.2rem;
            color: var(--text-primary);
            margin-bottom: 0.75rem;
            font-weight: 700;
        }

        .section-subtitle {
            color: var(--text-muted);
            font-size: 1.1rem;
        }

        /* Practical Approach Box */
        .practical-approach {
            background: linear-gradient(135deg, 
                rgba(0, 129, 251, 0.1), 
                rgba(0, 129, 251, 0.05));
            border: 1px solid var(--meta-blue);
            border-left: 4px solid var(--meta-blue);
            border-radius: var(--radius-sm);
            padding: var(--spacing-md);
            margin: var(--spacing-lg) 0;
        }

        .practical-approach h3 {
            color: var(--meta-blue);
            font-size: 1.2rem;
            margin-bottom: var(--spacing-sm);
        }

        .practical-approach ul {
            list-style: none;
            padding-left: 0;
            margin-top: var(--spacing-md);
        }

        .practical-approach li {
            position: relative;
            padding: 0.6rem 0.75rem 0.6rem 2.2rem;
            margin: 0.75rem 0;
            line-height: 1.8;
            color: var(--text-muted);
            background: rgba(0, 129, 251, 0.05);
            border-radius: 6px;
            border-left: 3px solid rgba(0, 129, 251, 0.3);
        }

        .practical-approach li::before {
            content: '✓';
            position: absolute;
            left: 0.6rem;
            top: 0.6rem;
            color: var(--meta-blue);
            font-weight: bold;
            font-size: 1.1rem;
            transition: all 0.2s ease;
        }

        .practical-approach strong {
            color: var(--meta-light);
            font-weight: 600;
        }

        /* Theoretical Dive Box */
        .theoretical-dive {
            background: linear-gradient(135deg, 
                rgba(255, 128, 0, 0.1), 
                rgba(255, 128, 0, 0.05));
            border: 1px solid var(--mclaren-orange);
            border-left: 4px solid var(--mclaren-orange);
            border-radius: var(--radius-sm);
            padding: var(--spacing-md);
            margin: var(--spacing-lg) 0;
        }

        .theoretical-dive h3 {
            color: var(--mclaren-orange);
            font-size: 1.3rem;
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-sm);
            border-bottom: 2px solid rgba(255, 128, 0, 0.2);
        }

        .theoretical-dive h4 {
            color: var(--mclaren-light);
            font-size: 1.05rem;
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-xs);
            font-weight: 600;
        }

        .theoretical-dive p {
            margin: var(--spacing-sm) 0;
            line-height: 1.8;
        }

        .theoretical-dive > h3::before {
            content: '📚 ';
            opacity: 0.8;
        }

        .theory-section {
            background: rgba(0, 0, 0, 0.3);
            padding: var(--spacing-md);
            border-radius: var(--radius-sm);
            margin: var(--spacing-sm) 0;
            border-left: 3px solid rgba(255, 128, 0, 0.5);
        }

        .theory-section ul {
            list-style: none;
            padding-left: 0;
            margin-top: var(--spacing-sm);
        }

        .theory-section > p + ul {
            margin-top: var(--spacing-md);
        }

        .theory-section li {
            position: relative;
            padding: 0.5rem 0.75rem 0.5rem 2rem;
            margin: 0.75rem 0;
            line-height: 1.8;
            color: var(--text-muted);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.02);
        }

        .theory-section > ul > li::before {
            content: '▸';
            position: absolute;
            left: 0.5rem;
            top: 0.5rem;
            color: var(--mclaren-orange);
            font-weight: bold;
            font-size: 1.2rem;
            transition: all 0.2s ease;
        }

        .theory-section ul ul {
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
            padding-left: 1rem;
        }

        .theory-section ul ul li {
            padding: 0.35rem 0.5rem 0.35rem 1.5rem;
            margin: 0.4rem 0;
            font-size: 0.95rem;
            background: rgba(0, 129, 251, 0.03);
            border-left: 2px solid rgba(0, 129, 251, 0.2);
        }

        .theory-section ul ul li::before {
            content: '→';
            position: absolute;
            left: 0.3rem;
            top: 0.35rem;
            color: var(--meta-blue);
            font-weight: normal;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .theory-section strong {
            color: var(--mclaren-light);
            font-weight: 600;
        }

        .theory-section code {
            background: rgba(255, 128, 0, 0.1);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-size: 0.9rem;
            color: var(--mclaren-orange);
            border: 1px solid rgba(255, 128, 0, 0.2);
        }

        .theory-section em {
            color: var(--meta-light);
            font-style: italic;
        }

        /* Hover effects for theory lists */
        .theory-section > ul > li {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .theory-section > ul > li:hover {
            background: rgba(255, 128, 0, 0.08);
            transform: translateX(5px);
            color: var(--text-primary);
            box-shadow: 0 2px 12px rgba(255, 128, 0, 0.1);
        }

        .theory-section > ul > li:hover::before {
            color: var(--mclaren-light);
            transform: translateX(3px) scale(1.2);
        }

        .theory-section ul ul li {
            transition: all 0.2s ease;
        }

        .theory-section ul ul li:hover {
            background: rgba(0, 129, 251, 0.08);
            border-left-color: var(--meta-blue);
            transform: translateX(3px);
        }

        .theory-section ul ul li:hover::before {
            color: var(--meta-light);
            transform: translateX(2px);
        }

        /* Practical approach hover effects */
        .practical-approach li {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .practical-approach li:hover {
            background: rgba(0, 129, 251, 0.12);
            border-left-color: var(--meta-blue);
            transform: translateX(5px);
            color: var(--text-primary);
            box-shadow: 0 2px 8px rgba(0, 129, 251, 0.15);
        }

        .practical-approach li:hover::before {
            color: var(--meta-light);
            transform: scale(1.3);
        }

        /* Add spacing between major bullet groups */
        .theory-section > ul > li + li {
            margin-top: 1.2rem;
        }

        /* Style for nested list headers (strong tags at start of li) */
        .theory-section li > strong:first-child {
            display: block;
            margin-bottom: 0.3rem;
            color: var(--mclaren-orange);
            font-size: 1.05rem;
        }

        /* Content Blocks */
        .content-block {
            background: var(--glass-white);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            padding: var(--spacing-lg);
            margin: var(--spacing-md) 0;
        }

        /* Module Structure Cards */
        .module-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: var(--spacing-md);
            margin: var(--spacing-lg) 0;
        }

        .module-card {
            background: var(--glass-white);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            padding: var(--spacing-md);
            transition: all var(--transition-normal);
        }

        .module-card:hover {
            border-color: rgba(255, 128, 0, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(255, 128, 0, 0.1);
        }

        .module-card h3 {
            font-size: 1.125rem;
            margin-bottom: var(--spacing-sm);
            color: var(--mclaren-orange);
            font-weight: 600;
        }

        .module-card ul {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .module-card li {
            padding: 0.375rem 0;
            color: var(--text-muted);
            font-size: 0.9375rem;
            line-height: 1.6;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        }

        .module-card li:last-child {
            border-bottom: none;
        }

        .content-block h3 {
            font-size: 1.7rem;
            margin-bottom: var(--spacing-md);
            color: var(--text-primary);
            font-weight: 600;
        }

        .content-block h4 {
            font-size: 1.35rem;
            margin: var(--spacing-md) 0 var(--spacing-sm) 0;
            color: var(--mclaren-light);
            font-weight: 600;
        }

        .content-block p {
            margin: var(--spacing-sm) 0;
            line-height: 1.8;
            font-size: 1.05rem;
        }

        .content-block ul, .content-block ol {
            margin-left: var(--spacing-lg);
            margin-top: var(--spacing-sm);
        }

        .content-block li {
            margin: var(--spacing-xs) 0;
            line-height: 1.8;
        }

        /* Code Block Styling */
        .code-block {
            background: linear-gradient(135deg, rgba(20, 20, 20, 0.8), rgba(10, 10, 10, 0.9));
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            padding: var(--spacing-md);
            margin: var(--spacing-md) 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            position: relative;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: all var(--transition-normal);
        }

        .code-block:hover {
            border-color: rgba(255, 128, 0, 0.3);
            box-shadow: 0 6px 20px rgba(255, 128, 0, 0.15);
        }

        .code-block pre {
            margin: 0;
            white-space: pre;
        }

        .code-block code {
            color: var(--text-primary);
        }

        /* Syntax Highlighting */
        .keyword { color: var(--code-keyword); font-weight: 600; }
        .function { color: var(--code-function); font-weight: 600; }
        .string { color: var(--code-string); }
        .comment { color: var(--code-comment); font-style: italic; }
        .number { color: var(--code-number); font-weight: 600; }
        .variable { color: var(--code-variable); }
        .operator { color: var(--text-primary); }
        .output { color: #3fb950; }

        /* Feynman-Style Deep Dive */
        .feynman-dive {
            background: linear-gradient(135deg, 
                rgba(255, 128, 0, 0.03), 
                rgba(220, 0, 0, 0.03));
            border: 1px solid rgba(255, 128, 0, 0.3);
            border-radius: var(--radius-md);
            padding: var(--spacing-lg);
            margin: var(--spacing-lg) 0;
            position: relative;
            overflow: hidden;
        }

        .feynman-dive h3 {
            color: var(--mclaren-orange);
            font-size: 1.8rem;
            margin-bottom: var(--spacing-lg);
            text-shadow: 0 0 20px var(--mclaren-glow);
        }

        .feynman-dive h4 {
            color: var(--mclaren-light);
            font-size: 1.3rem;
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        .feynman-intro {
            font-size: 1.1rem;
            font-style: italic;
            color: var(--text-muted);
            margin-bottom: var(--spacing-lg);
            padding: var(--spacing-md);
            background: rgba(0, 0, 0, 0.3);
            border-left: 4px solid var(--mclaren-orange);
            border-radius: var(--radius-sm);
        }

        .copy-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: transparent;
            border: 1px solid rgba(255, 128, 0, 0.4);
            border-radius: 6px;
            padding: 0.4rem 0.9rem;
            font-size: 11px;
            font-weight: 600;
            color: var(--mclaren-orange);
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: 'Quicksand', sans-serif;
        }

        .copy-btn:hover {
            background: rgba(255, 128, 0, 0.1);
            border-color: var(--mclaren-orange);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(255, 128, 0, 0.2);
        }

        .copy-btn:active {
            transform: translateY(0);
        }

        /* Interactive Demo */
        .interactive-demo {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            position: relative;
            transition: all 0.3s ease;
        }

        .interactive-demo:hover {
            border-color: rgba(255, 128, 0, 0.2);
            box-shadow: 0 4px 20px rgba(255, 128, 0, 0.05);
        }

        .interactive-demo h3 {
            font-size: 1.25rem;
            margin-bottom: 0.5rem;
            color: var(--mclaren-orange);
            font-weight: 600;
        }

        .demo-desc {
            color: var(--text-dim);
            margin-bottom: 1rem;
            font-size: 0.95rem;
        }

        .demo-controls {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: var(--spacing-md);
            padding: 1rem;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 10px;
        }

        .btn {
            padding: 0.6rem 1.2rem;
            font-size: 13px;
            font-weight: 600;
            background: transparent;
            border: 1px solid rgba(255, 128, 0, 0.3);
            color: var(--mclaren-orange);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: 'Quicksand', sans-serif;
        }

        .btn:hover {
            background: rgba(255, 128, 0, 0.1);
            border-color: var(--mclaren-orange);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 128, 0, 0.15);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .playground-canvas {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 10px;
            padding: 1.25rem;
            min-height: 200px;
        }

        /* Iteration Box */
        .iteration-box {
            min-width: 80px;
            height: 80px;
            background: linear-gradient(135deg, var(--meta-blue), var(--meta-dark));
            border: 2px solid var(--glass-border);
            border-radius: var(--radius-sm);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            transition: all var(--transition-normal);
            cursor: pointer;
        }

        .iteration-box.active {
            background: linear-gradient(135deg, var(--mclaren-orange), var(--mclaren-dark));
            transform: scale(1.15);
            box-shadow: 0 10px 30px var(--mclaren-glow);
            z-index: 10;
        }

        .iteration-box.completed {
            background: linear-gradient(135deg, #3fb950, #2ea043);
            opacity: 0.6;
        }

        .iteration-label {
            font-size: 0.75rem;
            opacity: 0.8;
        }

        .iteration-value {
            font-size: 1.25rem;
        }

        /* Info and Warning Boxes */
        .info-box {
            background: linear-gradient(135deg, 
                rgba(0, 129, 251, 0.1), 
                rgba(0, 129, 251, 0.05));
            border: 1px solid var(--meta-blue);
            border-left: 4px solid var(--meta-blue);
            border-radius: var(--radius-sm);
            padding: var(--spacing-md);
            margin: var(--spacing-md) 0;
            position: relative;
            padding-left: 50px;
            line-height: 1.8;
        }

        .info-box::before {
            content: 'ℹ';
            position: absolute;
            left: 15px;
            top: 15px;
            color: var(--meta-blue);
            font-size: 1.5rem;
            font-weight: bold;
        }

        .info-box strong {
            color: var(--meta-light);
            display: block;
            margin-bottom: 0.5rem;
        }

        .info-box br {
            display: block;
            margin-bottom: 0.3rem;
        }

        .warning-box {
            background: linear-gradient(135deg, 
                rgba(220, 0, 0, 0.1), 
                rgba(220, 0, 0, 0.05));
            border: 1px solid var(--redbull-red);
            border-left: 4px solid var(--redbull-red);
            border-radius: var(--radius-sm);
            padding: var(--spacing-md);
            margin: var(--spacing-md) 0;
            position: relative;
            padding-left: 50px;
            line-height: 1.8;
        }

        .warning-box::before {
            content: '⚠';
            position: absolute;
            left: 15px;
            top: 15px;
            color: var(--redbull-red);
            font-size: 1.5rem;
            font-weight: bold;
        }

        .warning-box strong {
            color: var(--redbull-light);
            display: block;
            margin-bottom: 0.5rem;
        }

        /* Collapsible Sections */
        .collapsible-section {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            margin: 1rem 0;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .collapsible-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            cursor: pointer;
            user-select: none;
            transition: all 0.3s ease;
        }

        .collapsible-header:hover {
            background: rgba(255, 128, 0, 0.05);
        }

        .collapsible-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .collapsible-arrow {
            transition: transform 0.3s ease;
            color: var(--mclaren-orange);
        }

        .collapsible-section.open .collapsible-arrow {
            transform: rotate(180deg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .collapsible-section.open .collapsible-content {
            max-height: 10000px;
        }

        .collapsible-inner {
            padding: 0 1.5rem 1.5rem;
        }

        /* Animated List */
        .animated-list {
            list-style: none;
            padding: 0;
        }

        .animated-list-item {
            padding: 0.75rem 1rem;
            margin: 0.5rem 0;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .animated-list-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 2px;
            background: var(--mclaren-orange);
            transform: scaleY(0);
            transition: transform 0.3s ease;
        }

        .animated-list-item:hover {
            background: rgba(255, 128, 0, 0.08);
            border-color: rgba(255, 128, 0, 0.2);
            transform: translateX(8px);
        }

        .animated-list-item:hover::before {
            transform: scaleY(1);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            body {
                overflow-x: hidden;
                width: 100%;
                max-width: 100vw;
            }

            nav {
                padding: 0.75rem 0;
                width: 100%;
            }

            .nav-container {
                position: relative;
                justify-content: center;
                padding: 0 var(--spacing-md);
                width: 100%;
            }

            .nav-logo {
                font-size: 1.25rem;
                z-index: 1002;
            }

            .hamburger {
                display: flex;
                position: absolute;
                right: var(--spacing-md);
                top: 50%;
                transform: translateY(-50%);
                z-index: 1002;
            }

            .nav-links {
                position: fixed;
                top: 0;
                right: -100%;
                height: 100vh;
                width: 85%;
                max-width: 320px;
                background: rgba(0, 0, 0, 0.98);
                backdrop-filter: blur(24px);
                -webkit-backdrop-filter: blur(24px);
                flex-direction: column;
                padding: 5rem 2rem 2rem;
                gap: 0;
                transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                            opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                            visibility 0s linear 0.4s;
                border-left: 1px solid var(--glass-border);
                z-index: 1001;
                box-shadow: -4px 0 24px rgba(0, 0, 0, 0.5);
                overflow-y: auto;
                visibility: hidden;
                opacity: 0;
                pointer-events: none;
            }

            .nav-links.active {
                right: 0;
                visibility: visible;
                opacity: 1;
                pointer-events: all;
                transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                            opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                            visibility 0s linear 0s;
            }

            .nav-link {
                font-size: 15px;
                padding: 1rem 1.25rem;
                border-bottom: 1px solid rgba(255, 255, 255, 0.05);
                width: 100%;
                border-radius: 0;
            }

            .nav-link:hover {
                background: rgba(255, 128, 0, 0.1);
                padding-left: 1.5rem;
            }

            .nav-link.active {
                background: rgba(255, 128, 0, 0.15);
                border-left: 3px solid var(--mclaren-orange);
            }

            .nav-link.active::after {
                display: none;
            }

            .hero {
                padding: var(--spacing-xl) 0;
                width: 100%;
                max-width: 100%;
            }

            .hero h1 {
                font-size: 2rem;
                line-height: 1.2;
            }

            .hero p {
                font-size: 1rem;
                padding: 0 var(--spacing-sm);
            }

            .container {
                padding: 0 var(--spacing-md);
                width: 100%;
                max-width: 100%;
                overflow-x: hidden;
            }

            .section {
                width: 100%;
                max-width: 100%;
                overflow-x: hidden;
            }

            .section-title {
                font-size: 1.5rem;
                word-wrap: break-word;
            }

            .content-block {
                padding: var(--spacing-md);
                width: 100%;
                max-width: 100%;
                overflow-x: hidden;
            }

            .interactive-demo {
                padding: var(--spacing-md);
                width: 100%;
                max-width: 100%;
                overflow-x: hidden;
            }

            .demo-controls {
                flex-direction: column;
                align-items: stretch;
                width: 100%;
            }

            .btn {
                width: 100%;
            }

            .code-block {
                max-width: 100%;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                font-size: 12px;
                padding: var(--spacing-sm);
            }

            .code-block pre {
                max-width: 100%;
                overflow-x: auto;
            }

            .playground-canvas {
                width: 100%;
                max-width: 100%;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .module-grid {
                grid-template-columns: 1fr;
                width: 100%;
            }

            .module-card {
                width: 100%;
                max-width: 100%;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 0 var(--spacing-sm);
            }

            .hero h1 {
                font-size: 1.75rem;
            }

            .hero p {
                font-size: 0.9375rem;
            }

            .section-title {
                font-size: 1.25rem;
            }

            .code-block {
                font-size: 11px;
                padding: 0.625rem;
            }

            .copy-btn {
                padding: 0.3rem 0.625rem;
                font-size: 9px;
            }

            .interactive-demo h3 {
                font-size: 1.125rem;
            }

            .demo-controls {
                padding: 0.75rem;
            }

            .iteration-box {
                min-width: 60px;
                height: 60px;
                font-size: 0.875rem;
            }
        }
    </style>
</head>
<body>
    <!-- Reading Progress Bar -->
    <div id="reading-progress"></div>

    <!-- Mobile Overlay -->
    <div class="mobile-overlay" id="mobileOverlay"></div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="/" class="nav-logo">ROVER</a>
            
            <div class="nav-links" id="navLinks">
                <a href="#section1" class="nav-link">Advanced Single Loops</a>
                <a href="#section2" class="nav-link">Advanced Nested Loops</a>
                <a href="#section3" class="nav-link">Optimizations</a>
                <a href="#section4" class="nav-link">Mathematical Patterns</a>
                <a href="#section5" class="nav-link">State Machines</a>
            </div>

            <button class="hamburger" id="hamburger" aria-label="Toggle menu">
                <span></span>
                <span></span>
                <span></span>
            </button>
        </div>
    </nav>

    <!-- Hero Section -->
    <header class="hero">
        <div class="container">
            <h1>ADVANCED LOOPING TECHNIQUES</h1>
            <p style="margin-top: 1rem;">You've mastered the fundamentals. Now enter the realm of <strong>advanced patterns</strong> - the techniques that separate good programmers from exceptional ones. These patterns solve complex problems elegantly.</p>
        </div>
    </header>

    <!-- Main Content -->
    <main class="container">

        <!-- Module Structure -->
        <article id="module-structure" class="section">
            <div class="section-header">
                <h2 class="section-title">MODULE STRUCTURE - ADVANCED PATTERNS</h2>
            </div>

            <div class="module-grid">
                <div class="module-card">
                    <h3>SECTION 1: Advanced Single Loop</h3>
                    <ul>
                        <li>Powers of Two Iteration</li>
                        <li>Digit-by-Digit Processing</li>
                        <li>GCD Iteration (Euclidean)</li>
                        <li>Conditional Skip Patterns</li>
                        <li>Multiple Pointers</li>
                        <li>State Tracking Patterns</li>
                    </ul>
                </div>

                <div class="module-card">
                    <h3>SECTION 2: Advanced Nested</h3>
                    <ul>
                        <li>Triangle Patterns</li>
                        <li>Diamond/Pyramid Patterns</li>
                        <li>Spiral Matrix Traversal</li>
                        <li>Diagonal Traversal</li>
                        <li>Layer-by-Layer Processing</li>
                    </ul>
                </div>

                <div class="module-card">
                    <h3>SECTION 3: Optimizations </h3>
                    <ul>
                        <li>Loop Fusion and Fission</li>
                        <li>Early Termination Strategies</li>
                        <li>Amortized Loop Techniques</li>
                        <li>Cache-Aware Loop Design</li>
                    </ul>
                </div>

                <div class="module-card">
                    <h3>SECTION 4: Mathematical </h3>
                    <ul>
                        <li>Prime Number Patterns</li>
                        <li>Fibonacci Variants</li>
                        <li>Fast Exponentiation</li>
                        <li>Modular Arithmetic Loops</li>
                    </ul>
                </div>

                <div class="module-card">
                    <h3>SECTION 5: State Machines</h3>
                    <ul>
                        <li>Multi-State Tracking</li>
                        <li>Parser Patterns</li>
                        <li>Run-Length Encoding</li>
                        <li>Sliding Window with State</li>
                    </ul>
                </div>
            </div>
        </article>

        <!-- SECTION 1: ADVANCED SINGLE LOOP PATTERNS -->
        <article id="section1" class="section">
            <div class="section-header">
                <h2 class="section-title">SECTION 1: ADVANCED SINGLE LOOP PATTERNS</h2>
            </div>

            <div class="feynman-dive">
                <h3>Welcome To The Advanced Loop Dojo</h3>
                <p class="feynman-intro">
                    You've learned to write loops. Cool. Now let's learn to write loops that don't suck. The difference between a junior developer and a senior one isn't knowing more syntax - it's knowing WHICH loop pattern solves WHICH problem class. You're about to learn patterns that eliminate entire categories of O(n²) brute force nonsense and replace them with elegant O(n) or O(log n) solutions. This is where algorithm design stops being "try random stuff until it works" and starts being "ah yes, this is clearly a two-pointer problem."
                </p>

                <h4>Why Advanced Patterns Matter</h4>
                <p>
                    Because in the real world, nobody cares if your algorithm is "technically correct" if it takes 3 hours to process user data. Performance matters. Efficiency matters. And 90% of performance optimization isn't fancy machine learning or distributed systems - it's just <strong>choosing the right loop pattern</strong>. Use a nested loop where a two-pointer would work? You just made your code 1000× slower. Use linear search where binary search applies? Same problem. These patterns are your performance toolkit.
                </p>

                <h4>The Pattern Library Mental Model</h4>
                <p>
                    Think of these patterns as recipes. You don't memorize every possible meal - you memorize techniques (sauté, braise, roast) and apply them to different ingredients. Same here. Memorize the pattern (powers of 2, digit extraction, GCD, etc.), recognize when a problem matches the pattern structure, apply it. Over time, pattern recognition becomes instant. You'll look at a problem and immediately think "oh, that's sliding window with state" or "that's triangular nested loops." That's mastery.
                </p>
            </div>

            <!-- Practical Approach -->
            <div class="practical-approach">
                <h3>Step-by-step practical approach</h3>
                <ul>
                    <li><strong>Master the math:</strong> Understand WHY these patterns work mathematically before coding them</li>
                    <li><strong>Trace by hand:</strong> For powers of 2, write out the sequence: 1, 2, 4, 8, 16... until pattern is clear</li>
                    <li><strong>Practice digit extraction:</strong> Try num % 10 and num // 10 with different numbers to internalize</li>
                    <li><strong>Recognize logarithmic:</strong> When you double/halve each iteration, you're in O(log n) territory</li>
                    <li><strong>Build pattern library:</strong> Keep these templates handy - they appear in countless problems</li>
                </ul>
            </div>

            <!-- Theoretical Dive -->
            <div class="theoretical-dive">
                <h3>🎓 Deep Theoretical Dive</h3>
                
                <div class="theory-section">
                    <h4>Logarithmic Iteration & Time Complexity</h4>
                    <p><strong>Key Concept:</strong> Powers of 2 iteration (i *= 2) creates logarithmic time complexity O(log n)</p>
                    <ul>
                        <li><strong>Why it's logarithmic:</strong> Each iteration doubles the value, creating inverse exponential growth</li>
                        <li><strong>The math:</strong> While 2^k grows exponentially with k, reaching n requires only log₂(n) doublings</li>
                        <li><strong>Real-world impact:</strong> log₂(1,000,000) ≈ 20 iterations (not 1 million!)</li>
                        <li><strong>Where you'll see this:</strong>
                            <ul>
                                <li>Binary search algorithms</li>
                                <li>Divide-and-conquer strategies</li>
                                <li>Tree height calculations</li>
                                <li>Dynamic array resizing</li>
                            </ul>
                        </li>
                    </ul>
                </div>

                <div class="theory-section">
                    <h4>Digit Extraction & Base-10 Arithmetic</h4>
                    <p><strong>The Magic Formula:</strong> num % 10 and num // 10</p>
                    <ul>
                        <li><strong>Mathematical foundation:</strong> Any number = Σ(digit × 10^position)
                            <ul>
                                <li>Example: 12345 = 1×10⁴ + 2×10³ + 3×10² + 4×10¹ + 5×10⁰</li>
                            </ul>
                        </li>
                        <li><strong>How it works:</strong>
                            <ul>
                                <li><code>num % 10</code> extracts the rightmost digit (the 10⁰ coefficient)</li>
                                <li><code>num // 10</code> removes rightmost digit by shifting all digits right</li>
                            </ul>
                        </li>
                        <li><strong>Generalization:</strong> Works for any base (num % base, num // base)</li>
                        <li><strong>Performance:</strong> O(1) space, no string allocation overhead</li>
                    </ul>
                </div>

                <div class="theory-section">
                    <h4>Euclidean Algorithm & Number Theory</h4>
                    <p><strong>The 2300-Year-Old Optimization:</strong> gcd(a, b) = gcd(b, a mod b)</p>
                    <ul>
                        <li><strong>Mathematical proof:</strong>
                            <ul>
                                <li>Any common divisor of a and b also divides (a - b)</li>
                                <li>Repeated subtraction ≡ modulo operation</li>
                                <li>Therefore: gcd(a, b) = gcd(b, a % b)</li>
                            </ul>
                        </li>
                        <li><strong>Complexity analysis:</strong>
                            <ul>
                                <li>Time: O(log min(a,b)) proven by Lamé's theorem</li>
                                <li>Each step at least halves one number</li>
                                <li>Example: gcd(1,000,000, 1) takes only ~2 operations</li>
                            </ul>
                        </li>
                        <li><strong>Real-world applications:</strong>
                            <ul>
                                <li>RSA encryption (cryptographic key generation)</li>
                                <li>Fraction simplification</li>
                                <li>Modular arithmetic operations</li>
                                <li>LCD calculations</li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>

            <!-- PATTERN 1: Powers of Two -->
            <div class="feynman-dive">
                <h3>The "Why Would Anyone Loop Like This?" Pattern</h3>
                <p class="feynman-intro">
                    So you want to visit positions 1, 2, 4, 8, 16... instead of the boring 1, 2, 3, 4, 5? Congratulations, you've discovered that computers speak binary and you're finally having a conversation in their native language. This isn't just a fancy loop - it's literally how binary search, memory allocation, and half the internet's infrastructure works.
                </p>

                <h4>Why This Pattern Is Actually Genius</h4>
                <p>
                    Look, if you need to check something at exponentially growing intervals, you have two choices: (1) Write a for loop that goes 1 to n and skip most values like an idiot, or (2) Be smart and multiply by 2 each time. The difference? O(n) vs O(log n). For n=1,000,000, that's the difference between a million iterations and about 20. <strong>Twenty.</strong> Let that sink in.
                </p>

                <h4>Where This Shows Up (And Why You Should Care)</h4>
                <p>
                    Binary search? Powers of 2. Dynamic array resizing (like Python's list.append)? Powers of 2. Tree depths? Powers of 2. Network retry backoff? Powers of 2. It's everywhere because doubling is the mathematical equivalent of "go big or go home." Each step covers exponentially more ground than the last, which is exactly what you want when searching through massive spaces efficiently.
                </p>

                <h4>The Math That Makes It Click</h4>
                <p>
                    Here's the mind-bender: To reach n by doubling, you need log₂(n) doublings. So log₂(1024) = 10 doublings. log₂(1,000,000) ≈ 20 doublings. This is why algorithms with O(log n) complexity are considered "basically free" - even with a billion elements, you're doing maybe 30 operations. That's faster than reading this sentence.
                </p>
            </div>

            <div class="content-block">
                <h4>PATTERN 1: Powers of Two Iteration</h4>
                <p><strong>When to use:</strong> Processing at exponential intervals, binary search levels, divide-and-conquer depths</p>

                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    <pre><code># Iterate through powers of 2: 1, 2, 4, 8, 16, ...
i = 1
while i <= n:
    # Process at index i
    print(i)
    i *= 2

# For n = 20:
# Visits: 1, 2, 4, 8, 16
# Only 5 iterations for n=20 (log₂(20) ≈ 4.3)</code></pre>
                </div>

                <p><strong>Real Example - Find Highest Power of 2 ≤ n:</strong></p>
                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    <pre><code>def highest_power_of_2(n):
    """
    Find largest power of 2 that doesn't exceed n
    
    Example: n = 50 → returns 32 (2^5)
    """
    power = 1
    while power * 2 <= n:
        power *= 2
    return power

# Trace for n = 50:
# power = 1: 1*2=2 ≤ 50? Yes, power=2
# power = 2: 2*2=4 ≤ 50? Yes, power=4
# power = 4: 4*2=8 ≤ 50? Yes, power=8
# power = 8: 8*2=16 ≤ 50? Yes, power=16
# power = 16: 16*2=32 ≤ 50? Yes, power=32
# power = 32: 32*2=64 ≤ 50? NO, stop
# Return 32</code></pre>
                </div>
            </div>

            <!-- Interactive Demo: Powers of Two -->
            <div class="interactive-demo">
                <h3>Interactive: Powers of Two Visualizer</h3>
                <p class="demo-desc">Watch how powers of 2 grow exponentially! See the logarithmic number of iterations.</p>
                
                <div class="demo-controls">
                    <label style="color: var(--text-muted);">Target value (n):</label>
                    <input type="number" id="powers-n" value="100" min="1" max="10000" 
                           style="width: 100px; padding: 0.5rem; background: var(--code-bg); border: 1px solid var(--glass-border); color: white; border-radius: 6px;">
                    <button class="btn" onclick="powersDemo.visualize()">Visualize</button>
                    <button class="btn" onclick="powersDemo.animate()">Animate Steps</button>
                </div>
                
                <div class="playground-canvas">
                    <div id="powers-visual" style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-bottom: 20px;">
                        <!-- Populated by JS -->
                    </div>
                    <div id="powers-output" style="padding: 15px; background: rgba(0,0,0,0.3); border-radius: 6px; color: var(--text-muted);">
                        Set a target value and click "Visualize"
                    </div>
                </div>
            </div>

            <!-- PATTERN 2: Digit-by-Digit Processing -->
            <div class="feynman-dive">
                <h3>The "Peeling Onions, But Make It Math" Pattern</h3>
                <p class="feynman-intro">
                    You know what's annoying? Converting a number to a string just to iterate through its digits. You know what's satisfying? Realizing you can extract digits using nothing but modulo and integer division - no string conversion, no array allocation, just pure mathematical badassery. Welcome to digit-by-digit processing, where % 10 is your best friend and // 10 is your ride-or-die.
                </p>

                <h4>The Modulo Magic Trick</h4>
                <p>
                    Here's the secret sauce: <strong>num % 10 always gives you the rightmost digit</strong>. Always. Why? Because modulo 10 is literally asking "what's left after I remove all complete tens?" And what's left is... the ones place. Mind. Blown. Then num // 10 says "cool, now delete that digit by shifting everything right." It's like peeling an onion, except instead of crying, you're extracting digits like a mathematician.
                </p>

                <h4>Why This Beats String Conversion</h4>
                <p>
                    Sure, you could do str(num)[i] and iterate through a string. And if you want to waste memory, allocate a string object, and make your code look like it was written by someone who doesn't understand basic arithmetic, go ahead. But digit extraction with % and // is: (1) Faster (no string allocation), (2) More memory efficient (O(1) space), (3) Works in any base (% base, // base), and (4) Makes you look like you actually understand how numbers work in computers.
                </p>

                <h4>The Right-to-Left Gotcha</h4>
                <p>
                    Plot twist: This extracts digits <em>right to left</em> (ones, tens, hundreds...). If you need left-to-right, you'll have to reverse the process or use recursion. But honestly? Most digit problems don't care about order, and when they do (like reversing a number), the right-to-left extraction is exactly what you want. It's not a bug, it's a feature.
                </p>
            </div>

            <div class="content-block">
                <h4>PATTERN 2: Digit-by-Digit Processing</h4>
                <p><strong>When to use:</strong> Number manipulation, digit operations, mathematical problems</p>

                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    <pre><code># Process each digit of a number from right to left
num = 12345
while num > 0:
    digit = num % 10  # Get rightmost digit
    # Process digit
    num //= 10        # Remove rightmost digit

# Iteration trace:
# num=12345: digit=5, num=1234
# num=1234:  digit=4, num=123
# num=123:   digit=3, num=12
# num=12:    digit=2, num=1
# num=1:     digit=1, num=0</code></pre>
                </div>

                <p><strong>Real Example - Reverse a Number:</strong></p>
                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    <pre><code>def reverse_number(num):
    """
    Reverse digits of a number
    
    Example: 12345 → 54321
    """
    reversed_num = 0
    while num > 0:
        digit = num % 10
        reversed_num = reversed_num * 10 + digit
        num //= 10
    return reversed_num

# Detailed trace for num = 123:
# Initial: reversed_num = 0
# 
# Iteration 1:
#   digit = 123 % 10 = 3
#   reversed_num = 0 * 10 + 3 = 3
#   num = 123 // 10 = 12
# 
# Iteration 2:
#   digit = 12 % 10 = 2
#   reversed_num = 3 * 10 + 2 = 32
#   num = 12 // 10 = 1
# 
# Iteration 3:
#   digit = 1 % 10 = 1
#   reversed_num = 32 * 10 + 1 = 321
#   num = 1 // 10 = 0
# 
# Return 321</code></pre>
                </div>
            </div>

            <!-- Interactive Demo: Digit Processing -->
            <div class="interactive-demo">
                <h3>Interactive: Digit Extraction Simulator</h3>
                <p class="demo-desc">See how digits are extracted one by one from right to left!</p>
                
                <div class="demo-controls">
                    <label style="color: var(--text-muted);">Enter a number:</label>
                    <input type="number" id="digit-num" value="12345" min="0" 
                           style="width: 150px; padding: 0.5rem; background: var(--code-bg); border: 1px solid var(--glass-border); color: white; border-radius: 6px;">
                    <button class="btn" onclick="digitDemo.start()">Start Extraction</button>
                    <button class="btn" onclick="digitDemo.reverse()">Reverse Number</button>
                    <button class="btn" onclick="digitDemo.sumDigits()">Sum Digits</button>
                </div>
                
                <div class="playground-canvas">
                    <div id="digit-steps" style="margin-bottom: 20px; font-family: 'Courier New', monospace; min-height: 150px;">
                        <!-- Populated by JS -->
                    </div>
                    <div id="digit-result" style="padding: 15px; background: rgba(255, 128, 0, 0.1); border: 1px solid var(--mclaren-orange); border-radius: 6px; color: var(--mclaren-orange); font-weight: 600; text-align: center;">
                        Choose an operation above
                    </div>
                </div>
            </div>

            <!-- PATTERN 3: GCD Iteration -->
            <div class="feynman-dive">
                <h3>The "Ancient Greeks Were Smarter Than Your CS Professor" Algorithm</h3>
                <p class="feynman-intro">
                    Euclid figured this out around 300 BCE. Let me repeat: This algorithm is over 2,300 years old and we're still using it because nobody's found anything better. It's one of the oldest algorithms still in widespread use, and it's so elegant it makes modern programmers weep. The fact that you can find the greatest common divisor of two massive numbers in logarithmic time using nothing but modulo operations is borderline witchcraft.
                </p>

                <h4>The Insight That Took Humanity 2000+ Years</h4>
                <p>
                    Here's the mathematical truth bomb: gcd(a, b) = gcd(b, a % b). That's it. That's the whole algorithm. Why does this work? Because any number that divides both a and b also divides their difference (a - b). And a % b is just repeated subtraction until you can't subtract anymore. So instead of subtracting 100 - 30 - 30 - 30 = 10, you just do 100 % 30 = 10 in one shot. Same result, way faster.
                </p>

                <h4>Why Modulo Is Your Best Friend Here</h4>
                <p>
                    The naive approach: Keep subtracting the smaller from the larger until they're equal. That works, but it's slow as hell. For gcd(1000000, 1), you'd subtract 1 a million times like a caveman with an abacus. The modulo version? Two operations. <strong>Two.</strong> This is why the Euclidean algorithm runs in O(log min(a,b)) time - each step at least halves one of the numbers, forcing rapid convergence.
                </p>

                <h4>Where This Actually Matters</h4>
                <p>
                    RSA encryption (you know, the thing securing your bank transactions) uses this algorithm with 2048-bit numbers. Without the Euclidean algorithm's efficiency, public-key cryptography would be computationally infeasible. So yeah, that 2300-year-old loop pattern is literally protecting your credit card right now. You're welcome, Euclid.
                </p>
            </div>

            <div class="content-block">
                <h4>PATTERN 3: GCD Iteration (Euclidean Algorithm)</h4>
                <p><strong>When to use:</strong> Finding greatest common divisor, simplifying fractions</p>

                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    <pre><code>def gcd(a, b):
    """
    Find GCD using Euclidean algorithm
    
    Key insight: gcd(a, b) = gcd(b, a % b)
    """
    while b != 0:
        temp = b
        b = a % b
        a = temp
    return a

# Trace for gcd(48, 18):
# a=48, b=18: temp=18, b=48%18=12, a=18
# a=18, b=12: temp=12, b=18%12=6,  a=12
# a=12, b=6:  temp=6,  b=12%6=0,   a=6
# a=6,  b=0:  stop
# Return 6</code></pre>
                </div>

                <div class="info-box">
                    <strong>Why this works:</strong><br>
                    Mathematical property: Any divisor of both a and b also divides (a - b).<br>
                    By repeatedly subtracting, we find GCD.<br><br>
                    <strong>Optimization:</strong> Instead of subtracting, use modulo.<br>
                    a % b is equivalent to repeated subtraction, but much faster!<br><br>
                    Example: gcd(100, 30)<br>
                    Subtraction: 100-30=70, 70-30=40, 40-30=10, 30-10=20, 20-10=10, 10-10=0<br>
                    Modulo: 100%30=10, 30%10=0 (just 2 steps!)
                </div>
            </div>

            <!-- Interactive Demo: GCD Visualizer -->
            <div class="interactive-demo">
                <h3>Interactive: GCD Algorithm Visualizer</h3>
                <p class="demo-desc">Watch the Euclidean algorithm find the greatest common divisor step by step!</p>
                
                <div class="demo-controls">
                    <label style="color: var(--text-muted);">Number 1:</label>
                    <input type="number" id="gcd-a" value="48" min="1" 
                           style="width: 100px; padding: 0.5rem; background: var(--code-bg); border: 1px solid var(--glass-border); color: white; border-radius: 6px;">
                    <label style="color: var(--text-muted);">Number 2:</label>
                    <input type="number" id="gcd-b" value="18" min="1" 
                           style="width: 100px; padding: 0.5rem; background: var(--code-bg); border: 1px solid var(--glass-border); color: white; border-radius: 6px;">
                    <button class="btn" onclick="gcdDemo.calculate()">Calculate GCD</button>
                    <button class="btn" onclick="gcdDemo.stepThrough()">Step Through</button>
                </div>
                
                <div class="playground-canvas">
                    <div id="gcd-visualization" style="margin-bottom: 20px;">
                        <!-- Populated by JS -->
                    </div>
                    <div id="gcd-result" style="padding: 15px; background: rgba(0, 129, 251, 0.1); border: 1px solid var(--meta-blue); border-radius: 6px;">
                        Enter two numbers and calculate their GCD
                    </div>
                </div>
            </div>

            <!-- Remaining Single Loop Patterns -->
            <div class="feynman-dive">
                <h3>The "Who Says You Can Only Have One Loop Variable?" Rebellion</h3>
                <p class="feynman-intro">
                    Most programmers think: one loop = one counter. Wrong. Dead wrong. You can have as many pointers as you want dancing through different arrays in perfect synchronization. This is merge sort's secret weapon, two-pointer technique's bread and butter, and the reason you can merge two sorted arrays in O(n) instead of O(n²). It's like conducting an orchestra where each musician (pointer) plays at their own pace, but the result is beautiful harmony.
                </p>

                <h4>The Merge Sort Flex</h4>
                <p>
                    Here's why this pattern is clutch: You've got two sorted arrays. Naive approach? Nested loops comparing everything - O(n·m) time, gross. Smart approach? Two pointers, one loop, always pick the smaller of the two current elements. Result? O(n+m) time, which for equal-sized arrays is O(n) vs O(n²). That's the difference between "instant" and "go get coffee while it runs." This is literally how merge sort achieves O(n log n) - by merging efficiently.
                </p>

                <h4>The Independence Principle</h4>
                <p>
                    Each pointer moves independently based on conditions. Pointer i advances when you pick from array1. Pointer j advances when you pick from array2. They're not locked in step like a standard for loop - they're making independent decisions based on the data. This is the essence of the two-pointer technique: <strong>different rates of progression through different structures, coordinated by a single loop</strong>. Once you see it, you can't unsee it.
                </p>

                <h4>Why This Breaks People's Brains</h4>
                <p>
                    Because they're used to loops where the iteration is predictable. i goes 0, 1, 2, 3... nice and linear. But here? i might go 0, 1, 1, 2, 2, 2, 3 while j goes 0, 0, 1, 1, 2, 3, 3. The progression depends on the data, not a predetermined sequence. That's what makes it powerful and what makes it confusing. Master this, and a whole class of O(n²) problems become O(n).
                </p>
            </div>

            <div class="content-block">
                <h4>PATTERN 4: Multiple Pointers in Single Loop</h4>
                <p><strong>When to use:</strong> Processing multiple arrays simultaneously, merge operations</p>

                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    <pre><code># Merge two sorted arrays
def merge_sorted_arrays(arr1, arr2):
    i = j = 0
    result = []
    
    # Single loop, but two pointers
    while i < len(arr1) and j < len(arr2):
        if arr1[i] <= arr2[j]:
            result.append(arr1[i])
            i += 1
        else:
            result.append(arr2[j])
            j += 1
    
    # Append remaining
    result.extend(arr1[i:])
    result.extend(arr2[j:])
    
    return result

# Example: merge([1, 3, 5], [2, 4, 6])
# → [1, 2, 3, 4, 5, 6]</code></pre>
                </div>
            </div>

            <!-- Interactive Demo: Merge Arrays -->
            <div class="interactive-demo">
                <h3>Interactive: Merge Sorted Arrays</h3>
                <p class="demo-desc">Watch how two pointers merge sorted arrays in linear time!</p>
                
                <div class="demo-controls">
                    <label style="color: var(--text-muted);">Array 1 (comma-separated):</label>
                    <input type="text" id="merge-arr1" value="1,3,5,7" 
                           style="width: 200px; padding: 0.5rem; background: var(--code-bg); border: 1px solid var(--glass-border); color: white; border-radius: 6px;">
                    <label style="color: var(--text-muted);">Array 2:</label>
                    <input type="text" id="merge-arr2" value="2,4,6" 
                           style="width: 200px; padding: 0.5rem; background: var(--code-bg); border: 1px solid var(--glass-border); color: white; border-radius: 6px;">
                    <button class="btn" onclick="mergeDemo.animate()">Animate Merge</button>
                </div>
                
                <div class="playground-canvas">
                    <div id="merge-visual" style="margin-bottom: 20px; min-height: 200px;">
                        <!-- Populated by JS -->
                    </div>
                    <div id="merge-output" style="padding: 15px; background: rgba(59, 185, 80, 0.1); border: 1px solid #3fb950; border-radius: 6px; font-family: 'Courier New', monospace;">
                        Click "Animate Merge" to see the process
                    </div>
                </div>
            </div>

        </article>

        <!-- SECTION 2: ADVANCED NESTED LOOP PATTERNS -->
        <article id="section2" class="section">
            <div class="section-header">
                <h2 class="section-title">SECTION 2: ADVANCED NESTED LOOP PATTERNS</h2>
            </div>

            <div class="feynman-dive">
                <h3>The "Think In Geometry, Code In Loops" Masterclass</h3>
                <p class="feynman-intro">
                    Here's a secret that will change how you think about nested loops forever: <strong>They're all just geometric patterns</strong>. Rectangles, triangles, diamonds, spirals - every nested loop creates a shape when you plot which (i,j) pairs it visits. And here's the kicker: Once you can VISUALIZE the shape, the code writes itself. This section isn't about memorizing star patterns (though you will). It's about training your brain to see the geometry in the problem, then translating that geometry into loop bounds.
                </p>

                <h4>Why Pattern Printing Isn't Useless Busywork</h4>
                <p>
                    Every CS student groans when they see "print a diamond pattern." It feels like hazing. But then they hit a DP problem requiring a triangular table where dp[i][j] only exists for j ≤ i, and suddenly that triangle pattern makes perfect sense. Or they need to process matrix diagonals and remember "oh yeah, i+j = constant for diagonals." The star patterns aren't the goal - they're the TRAINING WHEELS for understanding dependent nested loops. The stars are just making the abstract concrete.
                </p>

                <h4>The Formula Derivation Skill</h4>
                <p>
                    Amateur approach: "I'll try different loop bounds until it looks right." Professional approach: "For row i, I need n-i-1 spaces and 2i+1 stars because I want the sequence 1,3,5,7... centered." See the difference? One is trial and error. The other is mathematical reasoning. Once you derive the formula (spaces = n-i-1, stars = 2i+1), the code is trivial. The hard part isn't the loops - it's the math. And if you can do the math, the code is just typing.
                </p>

                <h4>Spiral and Layer Patterns: The Boss Fight</h4>
                <p>
                    Spiral traversal is where people realize "oh, nested loops can be ACTUALLY complicated." But it's still just geometry: Walk the perimeter (four directions), shrink boundaries, repeat. The complexity comes from bookkeeping (top, bottom, left, right pointers), not from the concept. Once you see it as "layer-by-layer boundary walking," it clicks. This is a recurring pattern: What looks complicated is usually just careful state management. Master the state, master the algorithm.
                </p>
            </div>

            <!-- Practical Approach -->
            <div class="practical-approach">
                <h3>Step-by-step practical approach</h3>
                <ul>
                    <li><strong>Visualize first:</strong> Draw the pattern on paper before coding - triangles, diamonds, spirals become obvious</li>
                    <li><strong>Find the formula:</strong> For row i, how many elements? Spaces? Stars? Derive the mathematical relationship</li>
                    <li><strong>Test small cases:</strong> Run patterns with n=3, n=4 to verify formula before scaling up</li>
                    <li><strong>Understand symmetry:</strong> Diamond is upper triangle + reversed lower triangle</li>
                    <li><strong>Layer thinking:</strong> Spiral and layer patterns process boundaries in order: top → right → bottom → left</li>
                </ul>
            </div>

            <!-- Theoretical Dive -->
            <div class="theoretical-dive">
                <h3>🎓 Deep Theoretical Dive</h3>
                
                <div class="theory-section">
                    <h4>Pattern Generation & Mathematical Sequences</h4>
                    <p><strong>Triangular Number Sequences in Action:</strong></p>
                    <ul>
                        <li><strong>Left-aligned triangle:</strong> Row i has (i+1) elements (0-indexed)
                            <ul>
                                <li>Creates sequence: 0, 1, 3, 6, 10, 15...</li>
                                <li>Formula: T(n) = n(n+1)/2 (triangular numbers)</li>
                            </ul>
                        </li>
                        <li><strong>Right-aligned triangle:</strong> Add (n-i-1) leading spaces per row
                            <ul>
                                <li>Spaces decrease: n-1, n-2, n-3, ..., 0</li>
                                <li>Stars increase: 1, 2, 3, ..., n</li>
                            </ul>
                        </li>
                        <li><strong>Diamond patterns:</strong> Two triangles combined
                            <ul>
                                <li>Upper half: 2i+1 stars (odd sequence: 1, 3, 5, 7...)</li>
                                <li>Lower half: mirrors the upper pattern</li>
                                <li>Symmetry property makes it reversible</li>
                            </ul>
                        </li>
                    </ul>
                </div>

                <div class="theory-section">
                    <h4>Spiral Traversal & Boundary Iteration</h4>
                    <p><strong>Layer-by-Layer Processing Algorithm:</strong></p>
                    <ul>
                        <li><strong>The four-direction pattern:</strong>
                            <ul>
                                <li>→ Top row: left to right (col: left → right)</li>
                                <li>↓ Right column: top to bottom (row: top → bottom)</li>
                                <li>← Bottom row: right to left (col: right → left)</li>
                                <li>↑ Left column: bottom to top (row: bottom → top)</li>
                            </ul>
                        </li>
                        <li><strong>Boundary management:</strong>
                            <ul>
                                <li>Four pointers: top, bottom, left, right</li>
                                <li>After each layer: shrink boundaries inward</li>
                                <li>Continue while: top ≤ bottom AND left ≤ right</li>
                            </ul>
                        </li>
                        <li><strong>Edge case handling:</strong>
                            <ul>
                                <li>Single-row matrices: skip bottom traversal</li>
                                <li>Single-column matrices: skip left traversal</li>
                                <li>Conditionals prevent duplicate element processing</li>
                            </ul>
                        </li>
                    </ul>
                </div>

                <div class="theory-section">
                    <h4>Diagonal Traversal Patterns</h4>
                    <p><strong>Mathematical Invariants for Diagonals:</strong></p>
                    <ul>
                        <li><strong>Main diagonal:</strong> i = j (constant difference = 0)
                            <ul>
                                <li>Elements: (0,0), (1,1), (2,2), (3,3)...</li>
                            </ul>
                        </li>
                        <li><strong>Anti-diagonal:</strong> i + j = n - 1
                            <ul>
                                <li>For 4×4 matrix: (0,3), (1,2), (2,1), (3,0)</li>
                            </ul>
                        </li>
                        <li><strong>Parallel diagonals (↗ direction):</strong> i - j = constant
                            <ul>
                                <li>Example: Diagonal with i-j = 1: (1,0), (2,1), (3,2)...</li>
                            </ul>
                        </li>
                        <li><strong>Parallel diagonals (↖ direction):</strong> i + j = constant
                            <ul>
                                <li>Iterate one variable, calculate the other</li>
                                <li>No coordinate storage needed!</li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>

            <!-- PATTERN 7: Triangle Patterns -->
            <div class="feynman-dive">
                <h3>The "It's Just ASCII Art, But Make It Educational" Pattern</h3>
                <p class="feynman-intro">
                    You might think printing star patterns is some kind of CS101 hazing ritual designed to make you question your life choices. And you'd be partly right. But here's the plot twist: These "useless" patterns teach you the EXACT loop structure you need for: dynamic programming triangular tables, Floyd's triangle, Pascal's triangle, and half the "print a pattern" interview questions that assess whether you can think in 2D. Master this, and you've mastered triangular nested loop dependencies.
                </p>

                <h4>Why Triangles Matter (No, Really)</h4>
                <p>
                    A triangle pattern like "row i has i stars" directly maps to the algorithmic pattern "process i elements at position i." Sound familiar? That's literally how you fill a DP table where dp[i][j] only exists for j ≤ i. Or process all pairs where j < i. Or build the lower triangle of a matrix. The star pattern is just the visual representation of <strong>dependent nested loops</strong> - where the inner loop's range depends on the outer loop's variable.
                </p>

                <h4>The Formula That Unlocks Everything</h4>
                <p>
                    For row i (0-indexed), you need (n - i - 1) spaces and (2i + 1) stars for a centered pattern. Why 2i+1? Because you're generating the sequence of odd numbers: 1, 3, 5, 7... which is the natural pyramid growth pattern. This isn't arbitrary - it's arithmetic sequences in action. Once you see that spaces decrease linearly (n, n-1, n-2...) and stars increase linearly or by formula, you can generate ANY pattern by adjusting the formulas.
                </p>

                <h4>The Secret Nobody Tells You</h4>
                <p>
                    You don't actually need to memorize these patterns. You need to understand the <em>relationship</em> between row number and output. Row 0 has what? Row 1 has what? Find the pattern, express it mathematically, code it. That's it. The loop structure follows directly from the math. This is how real programmers think - not "what's the pattern for this?" but "what's the mathematical relationship, and how do I code it?"
                </p>
            </div>

            <div class="content-block">
                <h4>PATTERN 7: Right Triangle Patterns</h4>
                <p><strong>Type 1: Left-Aligned Triangle</strong></p>

                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    <pre><code>def print_left_triangle(n):
    """
    *
    **
    ***
    ****
    """
    for i in range(1, n+1):
        for j in range(i):
            print("*", end="")
        print()

# Analysis:
# Row 1: 1 star  (range(1) → 1 iteration)
# Row 2: 2 stars (range(2) → 2 iterations)
# Row 3: 3 stars (range(3) → 3 iterations)
# Total stars: 1+2+3+...+n = n(n+1)/2</code></pre>
                </div>

                <p><strong>Type 2: Right-Aligned Triangle</strong></p>
                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    <pre><code>def print_right_triangle(n):
    """
       *
      **
     ***
    ****
    """
    for i in range(1, n+1):
        # Print spaces
        for j in range(n - i):
            print(" ", end="")
        # Print stars
        for j in range(i):
            print("*", end="")
        print()

# Analysis for n=4:
# Row 1: 3 spaces, 1 star  (n-1 spaces)
# Row 2: 2 spaces, 2 stars (n-2 spaces)
# Row 3: 1 space,  3 stars (n-3 spaces)
# Row 4: 0 spaces, 4 stars (n-4 spaces)</code></pre>
                </div>
            </div>

            <!-- Interactive Demo: Triangle Patterns -->
            <div class="interactive-demo">
                <h3>Interactive: Triangle Pattern Generator</h3>
                <p class="demo-desc">Generate and visualize different triangle patterns!</p>
                
                <div class="demo-controls">
                    <label style="color: var(--text-muted);">Pattern type:</label>
                    <select id="triangle-type" style="padding: 0.5rem; background: var(--code-bg); border: 1px solid var(--glass-border); color: white; border-radius: 6px; font-family: 'Quicksand', sans-serif;">
                        <option value="left">Left-Aligned</option>
                        <option value="right">Right-Aligned</option>
                        <option value="inverted">Inverted</option>
                        <option value="number">Number Triangle</option>
                    </select>
                    <label style="color: var(--text-muted);">Size:</label>
                    <input type="number" id="triangle-size" value="5" min="1" max="10" 
                           style="width: 70px; padding: 0.5rem; background: var(--code-bg); border: 1px solid var(--glass-border); color: white; border-radius: 6px;">
                    <button class="btn" onclick="triangleDemo.generate()">Generate</button>
                </div>
                
                <div class="playground-canvas">
                    <div id="triangle-pattern" style="font-family: 'Courier New', monospace; font-size: 18px; line-height: 1.4; white-space: pre; color: var(--mclaren-orange); text-align: center; padding: 20px;">
                        Choose a pattern type and size
                    </div>
                    <div id="triangle-formula" style="margin-top: 15px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 6px; color: var(--text-muted);">
                        Formula will appear here
                    </div>
                </div>
            </div>

            <!-- PATTERN 8: Diamond Pattern -->
            <div class="content-block">
                <h4>PATTERN 8: Diamond/Pyramid Patterns</h4>
                
                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    <pre><code>def print_diamond(n):
    """
       *
      ***
     *****
    *******
     *****
      ***
       *
    """
    # Upper half (including middle)
    for i in range(n):
        # Spaces
        for j in range(n - i - 1):
            print(" ", end="")
        # Stars
        for j in range(2 * i + 1):
            print("*", end="")
        print()
    
    # Lower half
    for i in range(n - 2, -1, -1):
        # Spaces
        for j in range(n - i - 1):
            print(" ", end="")
        # Stars
        for j in range(2 * i + 1):
            print("*", end="")
        print()

# For n=4, upper half trace:
# i=0: spaces=3, stars=1  →    *
# i=1: spaces=2, stars=3  →   ***
# i=2: spaces=1, stars=5  →  *****
# i=3: spaces=0, stars=7  → *******

# Formula for row i (0-indexed):
# - Spaces before: n - i - 1
# - Number of stars: 2*i + 1
# 
# Why 2*i + 1?
# Row 0: 1 star  = 2*0 + 1
# Row 1: 3 stars = 2*1 + 1
# Row 2: 5 stars = 2*2 + 1
# Pattern: Odd numbers!</code></pre>
                </div>
            </div>

            <!-- Interactive Demo: Diamond Pattern -->
            <div class="interactive-demo">
                <h3>Interactive: Diamond Pattern Generator</h3>
                <p class="demo-desc">Create beautiful diamond and pyramid patterns with custom sizes!</p>
                
                <div class="demo-controls">
                    <label style="color: var(--text-muted);">Pattern:</label>
                    <select id="diamond-type" style="padding: 0.5rem; background: var(--code-bg); border: 1px solid var(--glass-border); color: white; border-radius: 6px; font-family: 'Quicksand', sans-serif;">
                        <option value="diamond">Diamond</option>
                        <option value="pyramid">Pyramid</option>
                        <option value="number-diamond">Number Diamond</option>
                        <option value="hollow-diamond">Hollow Diamond</option>
                    </select>
                    <label style="color: var(--text-muted);">Size:</label>
                    <input type="number" id="diamond-size" value="4" min="2" max="8" 
                           style="width: 70px; padding: 0.5rem; background: var(--code-bg); border: 1px solid var(--glass-border); color: white; border-radius: 6px;">
                    <button class="btn" onclick="diamondDemo.generate()">Generate</button>
                </div>
                
                <div class="playground-canvas">
                    <div id="diamond-pattern" style="font-family: 'Courier New', monospace; font-size: 16px; line-height: 1.3; white-space: pre; color: var(--mclaren-orange); text-align: center; padding: 20px;">
                        Select options and click Generate
                    </div>
                </div>
            </div>

            <!-- PATTERN 9: Spiral Traversal -->
            <div class="feynman-dive">
                <h3>The "Let's Walk Around The Block, But Make It A Matrix" Algorithm</h3>
                <p class="feynman-intro">
                    Spiral matrix traversal is what happens when someone asks "what if we processed a 2D array, but like, in the most inconvenient order possible?" And then it turns out this "inconvenient" order is actually SUPER useful for problems involving image processing, matrix rotation, and Google interview questions designed to make you cry. The algorithm is deceptively simple: walk the perimeter, shrink the boundaries, repeat. It's like peeling an onion, except the onion is a matrix and you're collecting values instead of crying (well, maybe you're still crying a little).
                </p>

                <h4>The Four-Direction Dance</h4>
                <p>
                    Here's the pattern: Go right across the top row. Go down the right column. Go left across the bottom row. Go up the left column. Boom, you've processed one "layer" of the matrix. Now shrink your boundaries (top++, right--, bottom--, left++) and do it again. Keep going until you've spiraled to the center. The beauty? Four simple loops per layer, each with a clear direction and range. No complex conditionals, no trying to figure out "am I going clockwise or counterclockwise?" - just a systematic boundary walk.
                </p>

                <h4>Why The Boundary Checks Matter</h4>
                <p>
                    Those `if (top <= bottom)` checks before the left and bottom traversals? That's not paranoia, that's <strong>correctness</strong>. For non-square matrices (like 3×5 or 4×2), the last layer might be a single row or single column. Without the checks, you'd process elements twice - once going right, once going left. The checks ensure: "only traverse bottom row if there's actually a row below the top row" and "only traverse left column if there's actually a column to the left of the right column."
                </p>

                <h4>The Mind-Bending Realization</h4>
                <p>
                    This algorithm processes an n×m matrix in exactly n×m operations - one per element. It looks complex with four loops and shrinking boundaries, but it's actually O(n·m) - optimal. You can't do better than visiting each element once. The "complexity" is all in the bookkeeping (tracking boundaries), not the work. This is a recurring theme: sometimes the setup looks complicated, but the actual computational complexity is as simple as it gets.
                </p>
            </div>

            <div class="content-block">
                <h4>PATTERN 9: Spiral Matrix Traversal</h4>
                <p><strong>When to use:</strong> Matrix problems, spiral order processing</p>

                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    <pre><code>def spiral_order(matrix):
    """
    Traverse matrix in spiral order (clockwise from outside to inside)
    
    Example:
    [[1,  2,  3,  4],
     [5,  6,  7,  8],
     [9, 10, 11, 12]]
    
    Output: [1,2,3,4,8,12,11,10,9,5,6,7]
    """
    if not matrix:
        return []
    
    result = []
    top = 0
    bottom = len(matrix) - 1
    left = 0
    right = len(matrix[0]) - 1
    
    while top <= bottom and left <= right:
        # Traverse right (top row, left to right)
        for col in range(left, right + 1):
            result.append(matrix[top][col])
        top += 1
        
        # Traverse down (right column, top to bottom)
        for row in range(top, bottom + 1):
            result.append(matrix[row][right])
        right -= 1
        
        # Traverse left (bottom row, right to left)
        if top <= bottom:  # Check if row still exists
            for col in range(right, left - 1, -1):
                result.append(matrix[bottom][col])
            bottom -= 1
        
        # Traverse up (left column, bottom to top)
        if left <= right:  # Check if column still exists
            for row in range(bottom, top - 1, -1):
                result.append(matrix[row][left])
            left += 1
    
    return result</code></pre>
                </div>

                <div class="info-box">
                    <strong>Layer-by-Layer Visualization:</strong><br><br>
                    Start: → → → ↓<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;↓<br>
                    ↑ → → ↓&nbsp;&nbsp;&nbsp;↓<br>
                    ↑ ← ← ← ←<br><br>
                    
                    Process: Top row → Right column → Bottom row → Left column<br>
                    Then shrink boundaries and repeat for inner layer
                </div>
            </div>

            <!-- Interactive Demo: Spiral Traversal -->
            <div class="interactive-demo">
                <h3>Interactive: Spiral Matrix Traversal</h3>
                <p class="demo-desc">Watch how the spiral algorithm processes a matrix layer by layer!</p>
                
                <div class="demo-controls">
                    <label style="color: var(--text-muted);">Rows:</label>
                    <input type="number" id="spiral-rows" value="3" min="2" max="6" 
                           style="width: 70px; padding: 0.5rem; background: var(--code-bg); border: 1px solid var(--glass-border); color: white; border-radius: 6px;">
                    <label style="color: var(--text-muted);">Columns:</label>
                    <input type="number" id="spiral-cols" value="4" min="2" max="6" 
                           style="width: 70px; padding: 0.5rem; background: var(--code-bg); border: 1px solid var(--glass-border); color: white; border-radius: 6px;">
                    <button class="btn" onclick="spiralDemo.generate()">Generate Matrix</button>
                    <button class="btn" onclick="spiralDemo.animate()">Animate Spiral</button>
                </div>
                
                <div class="playground-canvas">
                    <div id="spiral-matrix" style="display: inline-block; margin-bottom: 20px;">
                        <!-- Populated by JS -->
                    </div>
                    <div id="spiral-output" style="padding: 15px; background: rgba(0,0,0,0.3); border-radius: 6px;">
                        <div style="color: var(--text-muted);">Spiral Order: <span id="spiral-result" style="color: var(--mclaren-orange); font-family: 'Courier New', monospace; font-weight: 600;">[]</span></div>
                        <div style="color: var(--text-muted); margin-top: 8px;">Current layer: <span id="spiral-layer" style="color: var(--meta-blue); font-weight: 600;">0</span></div>
                    </div>
                </div>
            </div>

        </article>

        <!-- SECTION 3: OPTIMIZATION PATTERNS -->
        <article id="section3" class="section">
            <div class="section-header">
                <h2 class="section-title">SECTION 3: OPTIMIZATION PATTERNS</h2>
            </div>

            <div class="feynman-dive">
                <h3>The "Make It Work, Then Make It Fast" Philosophy</h3>
                <p class="feynman-intro">
                    Premature optimization is the root of all evil (thanks, Knuth). But you know what's also evil? Writing O(n³) code when O(n) exists. This section is about the optimizations that ACTUALLY matter - the ones that turn "this takes 10 minutes" into "this takes 10 milliseconds." We're not talking about micro-optimizations like replacing i++ with ++i (spoiler: compilers handle that). We're talking about structural optimizations: fusing loops, exploiting cache locality, terminating early. The stuff that makes 10-100× performance differences in production.
                </p>

                <h4>The Profile-First Commandment</h4>
                <p>
                    Before you optimize ANYTHING, measure. Use a profiler. Find the actual bottleneck. Because 90% of your code's runtime is spent in 10% of your code (the 90-10 rule, sometimes 99-1). Optimizing the wrong loop is like rearranging deck chairs on the Titanic - technically an improvement, practically worthless. Find the hot loop, THEN optimize it. Everything else is guesswork and wasted effort.
                </p>

                <h4>Cache Locality: The Hidden Performance Killer</h4>
                <p>
                    Memory access patterns can make a 10-100× performance difference with ZERO algorithmic changes. Row-major vs column-major traversal, fused vs separate loops, sequential vs scattered access - this is where textbook O(n) meets real-world performance engineering. The CPU fetches memory in cache lines (64 bytes). If you access memory sequentially, you reuse the cache line - fast. If you jump around, you thrash the cache - slow. Same O(n) complexity, wildly different runtime. <strong>Algorithms textbooks don't teach this. Production experience does.</strong>
                </p>
            </div>

            <!-- Practical Approach -->
            <div class="practical-approach">
                <h3>Step-by-step practical approach</h3>
                <ul>
                    <li><strong>Profile first:</strong> Don't optimize until you measure - find the actual bottleneck</li>
                    <li><strong>Fusion vs clarity:</strong> Only fuse loops if the performance gain justifies reduced readability</li>
                    <li><strong>Early exit strategy:</strong> Place most-likely-to-fail conditions first</li>
                    <li><strong>Cache awareness:</strong> Access memory sequentially when possible - row-major for C/Python/Java</li>
                    <li><strong>Test both versions:</strong> Always benchmark optimized code against original to verify improvement</li>
                </ul>
            </div>

            <!-- Theoretical Dive -->
            <div class="theoretical-dive">
                <h3>🎓 Deep Theoretical Dive</h3>
                
                <div class="theory-section">
                    <h4>Loop Fusion & Cache Locality</h4>
                    <p><strong>Combining Multiple Passes Into One:</strong></p>
                    <ul>
                        <li><strong>Benefits of fusion:</strong>
                            <ul>
                                <li>✓ Reduced loop overhead (fewer condition checks, fewer jumps)</li>
                                <li>✓ Better cache utilization (data stays hot in cache)</li>
                                <li>✓ More compiler optimization opportunities</li>
                                <li>✓ Fewer memory bandwidth requirements</li>
                            </ul>
                        </li>
                        <li><strong>When fusion backfires:</strong>
                            <ul>
                                <li>✗ Fused body too large for instruction cache</li>
                                <li>✗ Operations have conflicting access patterns</li>
                                <li>✗ Early-exit opportunities are lost</li>
                                <li>✗ Code becomes unreadable/unmaintainable</li>
                            </ul>
                        </li>
                        <li><strong>The tradeoff:</strong> Memory bandwidth efficiency vs code complexity</li>
                    </ul>
                </div>

                <div class="theory-section">
                    <h4>Branch Prediction & Early Termination</h4>
                    <p><strong>CPU Pipeline Optimization:</strong></p>
                    <ul>
                        <li><strong>How branch prediction works:</strong>
                            <ul>
                                <li>CPU predicts branch outcomes to maintain pipeline flow</li>
                                <li>Predictable branches (loop counters, sorted data): ~0 cost</li>
                                <li>Unpredictable branches (data-dependent): 10-20 cycle penalty</li>
                            </ul>
                        </li>
                        <li><strong>Early termination strategy:</strong>
                            <ul>
                                <li>Place high-probability exit conditions first</li>
                                <li>Example: <code>if (x == null)</code> before expensive operations</li>
                                <li>Trade: One branch check vs avoiding expensive work</li>
                            </ul>
                        </li>
                        <li><strong>When to use:</strong>
                            <ul>
                                <li>Searching (exit when found)</li>
                                <li>Validation (exit on first error)</li>
                                <li>Pattern matching (exit on mismatch)</li>
                            </ul>
                        </li>
                    </ul>
                </div>

                <div class="theory-section">
                    <h4>Row-Major vs Column-Major Access</h4>
                    <p><strong>Cache Line Optimization:</strong></p>
                    <ul>
                        <li><strong>Cache line basics:</strong>
                            <ul>
                                <li>Typical cache line: 64 bytes</li>
                                <li>CPU loads entire cache line, not single elements</li>
                                <li>Adjacent elements = same cache line = free access</li>
                            </ul>
                        </li>
                        <li><strong>Row-major storage (C, Python, Java):</strong>
                            <ul>
                                <li>matrix[i][j] and matrix[i][j+1] are adjacent in memory</li>
                                <li>✓ Good: Iterate j in inner loop (sequential access)</li>
                                <li>✗ Bad: Iterate i in inner loop (scattered access)</li>
                            </ul>
                        </li>
                        <li><strong>Performance impact:</strong>
                            <ul>
                                <li>1000×1000 matrix example:</li>
                                <li>Row-by-row: ~10ms (cache hits)</li>
                                <li>Column-by-column: ~50-100ms (cache misses)</li>
                                <li><strong>5-10× difference from loop order alone!</strong></li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>

            <!-- PATTERN 12: Loop Fusion -->
            <div class="feynman-dive">
                <h3>The "Why Make Three Trips When One Will Do?" Optimization</h3>
                <p class="feynman-intro">
                    Imagine you need to get milk, eggs, and bread from the grocery store. You could make three separate trips - one for milk, one for eggs, one for bread - like some kind of efficiency-allergic lunatic. Or you could, I don't know, get all three in ONE trip? Loop fusion is exactly this, except instead of groceries, it's array operations, and instead of gas money, you're saving CPU cycles and cache misses. Spoiler: The fused version is usually 2-3× faster. Why? Because memory access is expensive and you just loaded that array element anyway, so use it for ALL your operations while it's hot in the cache.
                </p>

                <h4>The Cache Locality Jackpot</h4>
                <p>
                    When you access arr[i], the CPU doesn't just load that one element - it loads an entire cache line (usually 64 bytes, so like 8-16 elements depending on type). If you then immediately access arr[i] again for a different operation, it's already in cache - effectively free. But if you loop through the entire array three times, you're evicting and reloading cache lines repeatedly. It's like opening the fridge, grabbing milk, closing it, opening it again for eggs, closing it, opening it AGAIN for bread. Just get everything while the fridge is open, genius.
                </p>

                <h4>When Fusion Backfires</h4>
                <p>
                    Not every loop deserves to be fused. If one loop can exit early (found the element you're searching for) and another always runs to completion, fusing them means you're doing extra work. If the fused loop body becomes so complex that it no longer fits in the instruction cache, you've traded data locality for instruction cache misses. And if the fused logic is unreadable, you've optimized yourself into a maintenance nightmare. <strong>Profile first, optimize second, and never sacrifice clarity for hypothetical speed gains.</strong>
                </p>

                <h4>The Real Performance Win</h4>
                <p>
                    The speedup from fusion isn't just from fewer iterations - it's from better cache utilization, reduced loop overhead (fewer condition checks, fewer jumps), and giving the compiler more optimization opportunities. For tight loops over large arrays, fusion can be the difference between 50ms and 15ms. That might not sound like much, but when you're processing millions of items per second, it compounds. This is where textbook O(n) meets real-world performance engineering.
                </p>
            </div>

            <div class="content-block">
                <h4>PATTERN 12: Loop Fusion (Combining Loops)</h4>
                
                <p><strong>Before (Separate Loops):</strong></p>
                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    <pre><code># Loop 1: Find max
max_val = arr[0]
for i in range(len(arr)):
    if arr[i] > max_val:
        max_val = arr[i]

# Loop 2: Find min
min_val = arr[0]
for i in range(len(arr)):
    if arr[i] < min_val:
        min_val = arr[i]

# Loop 3: Calculate sum
total = 0
for i in range(len(arr)):
    total += arr[i]

# Problem: 3 passes through array = 3n operations</code></pre>
                </div>

                <p><strong>After (Fused Loop):</strong></p>
                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    <pre><code># Single loop does all three
max_val = min_val = arr[0]
total = 0

for i in range(len(arr)):
    if arr[i] > max_val:
        max_val = arr[i]
    if arr[i] < min_val:
        min_val = arr[i]
    total += arr[i]

# Benefit: 1 pass through array = n operations
# 3× faster for large arrays!
# Better cache utilization - each element loaded once</code></pre>
                </div>

                <div class="warning-box">
                    <strong>When to use Loop Fusion:</strong><br>
                    ✓ Multiple independent operations on same data<br>
                    ✓ Sequential loops with same range<br>
                    ✓ No dependencies between operations<br>
                    ✗ Don't fuse if logic becomes too complex<br>
                    ✗ Don't fuse if one loop might break early
                </div>
            </div>

            <!-- Interactive Demo: Loop Fusion -->
            <div class="interactive-demo">
                <h3>Interactive: Loop Fusion Performance Comparison</h3>
                <p class="demo-desc">See the performance difference between separate and fused loops!</p>
                
                <div class="demo-controls">
                    <label style="color: var(--text-muted);">Array size:</label>
                    <input type="number" id="fusion-size" value="1000" min="100" max="10000" step="100"
                           style="width: 100px; padding: 0.5rem; background: var(--code-bg); border: 1px solid var(--glass-border); color: white; border-radius: 6px;">
                    <button class="btn" onclick="fusionDemo.compare()">Compare Performance</button>
                </div>
                
                <div class="playground-canvas">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                        <div>
                            <h4 style="color: var(--redbull-red); margin-bottom: 10px;">Separate Loops</h4>
                            <div style="background: rgba(0,0,0,0.5); padding: 15px; border-radius: 6px; height: 150px; overflow-y: auto; font-family: 'Courier New', monospace; font-size: 13px;" id="fusion-separate">
                            </div>
                            <div style="margin-top: 10px; color: var(--redbull-red);">
                                Operations: <span id="fusion-separate-ops">0</span>
                            </div>
                        </div>
                        <div>
                            <h4 style="color: #3fb950; margin-bottom: 10px;">Fused Loop</h4>
                            <div style="background: rgba(0,0,0,0.5); padding: 15px; border-radius: 6px; height: 150px; overflow-y: auto; font-family: 'Courier New', monospace; font-size: 13px;" id="fusion-fused">
                            </div>
                            <div style="margin-top: 10px; color: #3fb950;">
                                Operations: <span id="fusion-fused-ops">0</span>
                            </div>
                        </div>
                    </div>
                    <div id="fusion-result" style="padding: 15px; background: rgba(255, 128, 0, 0.1); border: 1px solid var(--mclaren-orange); border-radius: 6px; text-align: center; color: var(--mclaren-orange); font-weight: 600;">
                        Click "Compare Performance" to see the difference
                    </div>
                </div>
            </div>

            <!-- PATTERN 14: Early Termination -->
            <div class="content-block">
                <h4>PATTERN 14: Early Termination with Multiple Conditions</h4>
                
                <p><strong>Pattern 1: OR Conditions (Any True → Stop)</strong></p>
                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    <pre><code>def check_any_condition(arr):
    """
    Return True if ANY element satisfies ANY condition
    """
    for element in arr:
        # Multiple conditions, any can trigger early exit
        if element < 0:
            return True  # Found negative
        if element > 1000:
            return True  # Found too large
        if element % 7 == 0:
            return True  # Found divisible by 7
    
    return False  # No condition met

# Optimization: Exits immediately when first condition met
# Best case: O(1) if first element matches
# Worst case: O(n) if no element matches</code></pre>
                </div>

                <p><strong>Pattern 2: Nested Early Termination with Flag</strong></p>
                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    <pre><code>def find_in_nested(matrix, target):
    """
    Find element in 2D matrix, exit both loops when found
    """
    found = False
    
    for i in range(len(matrix)):
        for j in range(len(matrix[0])):
            if matrix[i][j] == target:
                found = True
                break  # Exit inner loop
        if found:
            break  # Exit outer loop
    
    return found

# Alternative: Use return directly (exits function)
def find_in_nested_v2(matrix, target):
    for i in range(len(matrix)):
        for j in range(len(matrix[0])):
            if matrix[i][j] == target:
                return True  # Exits both loops AND function
    return False</code></pre>
                </div>
            </div>

            <!-- PATTERN 16: Cache-Aware Design -->
            <div class="content-block">
                <h4>PATTERN 16: Cache-Aware Loop Design</h4>
                
                <p><strong>Bad: Column-Major Access (Cache Misses)</strong></p>
                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    <pre><code>def sum_matrix_columns_first(matrix):
    """
    Access pattern: column by column
    BAD for row-major storage (most languages)
    """
    rows = len(matrix)
    cols = len(matrix[0])
    total = 0
    
    for j in range(cols):      # Column first
        for i in range(rows):  # Then row
            total += matrix[i][j]  # Jump around memory!
    
    return total

# Memory access pattern (for 3×3):
# [0][0], [1][0], [2][0],  ← Jump to new cache line
# [0][1], [1][1], [2][1],  ← Jump to new cache line
# [0][2], [1][2], [2][2]   ← Jump to new cache line
# Many cache misses!</code></pre>
                </div>

                <p><strong>Good: Row-Major Access (Cache Hits)</strong></p>
                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    <pre><code>def sum_matrix_rows_first(matrix):
    """
    Access pattern: row by row
    GOOD for row-major storage
    """
    rows = len(matrix)
    cols = len(matrix[0])
    total = 0
    
    for i in range(rows):      # Row first
        for j in range(cols):  # Then column
            total += matrix[i][j]  # Sequential memory!
    
    return total

# Memory access pattern (for 3×3):
# [0][0], [0][1], [0][2],  ← Sequential (same cache line)
# [1][0], [1][1], [1][2],  ← Sequential (same cache line)
# [2][0], [2][1], [2][2]   ← Sequential (same cache line)
# Excellent cache usage!

# Performance difference for 1000×1000 matrix:
# Column-first: ~50ms (many cache misses)
# Row-first: ~10ms (mostly cache hits)
# 5× faster just from loop order!</code></pre>
                </div>
            </div>

        </article>

        <!-- SECTION 4: MATHEMATICAL LOOP PATTERNS -->
        <article id="section4" class="section">
            <div class="section-header">
                <h2 class="section-title">SECTION 4: MATHEMATICAL LOOP PATTERNS</h2>
            </div>

            <div class="feynman-dive">
                <h3>The "Math Isn't Optional Anymore" Reality Check</h3>
                <p class="feynman-intro">
                    You can write basic loops without math. You can even write decent algorithms with minimal math. But you CANNOT write efficient number-theoretic algorithms without understanding the mathematics. Primes, exponentiation, GCD, Fibonacci - these aren't just "math problems," they're the foundation of cryptography, hashing, random number generation, and countless real-world systems. And the loops that implement them? They're mathematical proofs translated into code. You're not just iterating - you're executing mathematical theorems.
                </p>

                <h4>Why √n Changes Everything</h4>
                <p>
                    The single most important optimization in number theory algorithms: exploiting factor pairs. If n = a × b and a ≤ √n, then b ≥ √n. So you only check half the factors (the smaller ones), and you've found them all. This turns O(n) into O(√n) - for n=1,000,000, that's checking 1,000 numbers instead of 1,000,000. A 1000× speedup from one mathematical insight. This is why math matters: it reveals optimizations that would never occur to you from pure coding intuition.
                </p>

                <h4>Binary Thinking Is Logarithmic Thinking</h4>
                <p>
                    Powers of 2, binary exponentiation, binary search - they're all the same insight: <strong>doubling/halving gives you logarithmic complexity</strong>. And logarithmic is basically free. log₂(1,000,000) ≈ 20. log₂(1,000,000,000) ≈ 30. The numbers can grow to astronomical sizes, and you're still doing like 30-40 operations. This is the magic of exponential growth in reverse. Understanding this makes you see optimization opportunities everywhere.
                </p>

                <h4>Modular Arithmetic: The Overflow Killer</h4>
                <p>
                    Computing large exponentials without modular arithmetic? Good luck with that overflow. (2^1000) doesn't fit in any primitive type - it's a 302-digit number. But (2^1000) mod 13? That fits in an int. The trick is taking mod DURING the computation, not after. Each multiply-then-mod keeps numbers bounded. This is how cryptography works with 2048-bit exponents - by never letting intermediate results overflow. Math + loops = tractable computation of the mathematically enormous.
                </p>
            </div>

            <!-- Practical Approach -->
            <div class="practical-approach">
                <h3>Step-by-step practical approach</h3>
                <ul>
                    <li><strong>Prime checking:</strong> Only check divisibility up to √n - any factor larger than √n has a corresponding smaller factor</li>
                    <li><strong>Sieve optimization:</strong> Start marking from i² not 2i - smaller multiples already marked</li>
                    <li><strong>Fibonacci space:</strong> You only need the last 2 values, not the entire sequence</li>
                    <li><strong>Binary exponentiation:</strong> Halving the exponent each time gives O(log n) instead of O(n)</li>
                    <li><strong>Modular arithmetic:</strong> Take mod after each operation to prevent overflow</li>
                </ul>
            </div>

            <!-- Theoretical Dive -->
            <div class="theoretical-dive">
                <h3>🎓 Deep Theoretical Dive</h3>
                
                <div class="theory-section">
                    <h4>Sieve of Eratosthenes - Time Complexity Analysis</h4>
                    <p><strong>The Surprising O(n log log n) Complexity:</strong></p>
                    <ul>
                        <li><strong>Why it's not O(n²):</strong>
                            <ul>
                                <li>For each prime p, we mark n/p multiples</li>
                                <li>Total: n/2 + n/3 + n/5 + n/7 + ... (only primes)</li>
                                <li>This equals: n × (1/2 + 1/3 + 1/5 + 1/7 + ...)</li>
                            </ul>
                        </li>
                        <li><strong>The Prime Number Theorem connection:</strong>
                            <ul>
                                <li>Sum of reciprocals of primes ≈ log log n</li>
                                <li>Therefore: Total complexity = O(n log log n)</li>
                                <li>This is <em>almost linear</em> - incredibly fast!</li>
                            </ul>
                        </li>
                        <li><strong>Space complexity:</strong> O(n) for boolean array</li>
                        <li><strong>The i² optimization:</strong>
                            <ul>
                                <li>For prime p, multiples 2p, 3p, ..., (p-1)p already marked</li>
                                <li>By smaller primes: 2, 3, ..., p-1</li>
                                <li>Safe to start from p²</li>
                                <li>Significant speedup in practice!</li>
                            </ul>
                        </li>
                    </ul>
                </div>

                <div class="theory-section">
                    <h4>Fast Exponentiation & Binary Representation</h4>
                    <p><strong>Exponentiation by Squaring:</strong></p>
                    <ul>
                        <li><strong>The binary decomposition:</strong>
                            <ul>
                                <li>Any number n = Σ bᵢ·2^i (binary expansion)</li>
                                <li>Therefore: a^n = Π a^(bᵢ·2^i) for all bits bᵢ = 1</li>
                            </ul>
                        </li>
                        <li><strong>Building powers by squaring:</strong>
                            <ul>
                                <li>a^1 → (a^1)² = a^2</li>
                                <li>a^2 → (a^2)² = a^4</li>
                                <li>a^4 → (a^4)² = a^8</li>
                                <li>And so on... (logarithmic steps)</li>
                            </ul>
                        </li>
                        <li><strong>Example: 3^13 where 13 = 1101₂ = 8+4+1</strong>
                            <ul>
                                <li>3^13 = 3^8 · 3^4 · 3^1</li>
                                <li>Build: 3^1, 3^2, 3^4, 3^8 (3 squarings)</li>
                                <li>Multiply: 3^8 · 3^4 · 3^1 (2 multiplications)</li>
                                <li><strong>Total: 5 operations vs 12 naive multiplications!</strong></li>
                            </ul>
                        </li>
                    </ul>
                </div>

                <div class="theory-section">
                    <h4>Modular Exponentiation & Cryptography</h4>
                    <p><strong>Computing (a^b mod m) Without Overflow:</strong></p>
                    <ul>
                        <li><strong>The overflow problem:</strong>
                            <ul>
                                <li>Computing a^b first, then mod m → overflow for large b</li>
                                <li>Example: 2^1000 = 302-digit number (doesn't fit in any type!)</li>
                            </ul>
                        </li>
                        <li><strong>The modular arithmetic solution:</strong>
                            <ul>
                                <li>Property: (x·y) mod m = ((x mod m)·(y mod m)) mod m</li>
                                <li>Take mod after EACH multiplication</li>
                                <li>Numbers never exceed m² (stay bounded)</li>
                            </ul>
                        </li>
                        <li><strong>Combined with binary exponentiation:</strong>
                            <ul>
                                <li>Time: O(log b) iterations</li>
                                <li>Space: O(1) - no large number storage</li>
                                <li>Works for b = 10^9 and beyond!</li>
                            </ul>
                        </li>
                        <li><strong>Why RSA encryption is possible:</strong>
                            <ul>
                                <li>RSA uses 2048-bit numbers and exponents</li>
                                <li>Without this technique: computationally infeasible</li>
                                <li>With this technique: milliseconds</li>
                                <li><strong>This is why HTTPS doesn't take forever!</strong></li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>

            <!-- PATTERN 17: Prime Patterns -->
            <div class="feynman-dive">
                <h3>The "Primes Are Hard, But Loops Make Them Less Hard" Saga</h3>
                <p class="feynman-intro">
                    Prime numbers are the atoms of mathematics - every number breaks down into primes, making them fundamental to... well, everything. Number theory, cryptography, hash functions, random number generation - primes are everywhere. And finding them? That's where loops come in. But not just any loops - <em>smart</em> loops that exploit mathematical properties to avoid checking literally every number like some kind of brute-force barbarian.
                </p>

                <h4>The √n Optimization That Saves Your Life</h4>
                <p>
                    Why check divisors only up to √n? Because math, that's why. If n = a × b and a ≤ √n, then b ≥ √n. So factors come in pairs, and one of them is always ≤ √n. Checking beyond √n is redundant - you've already found all factor pairs. For n = 1,000,000, this means checking 1,000 numbers instead of 999,999. That's a 1000× speedup from one clever observation. This is the difference between "prime checking" and "still waiting for the result three hours later."
                </p>

                <h4>Sieve of Eratosthenes: The "Mark Your Territory" Algorithm</h4>
                <p>
                    Instead of checking each number individually (slow), we play a marking game: Start with 2, mark all its multiples as composite. Move to 3, mark all ITS multiples. Move to 5 (skip 4, already marked), mark ITS multiples. Continue until √n. Everything unmarked? That's prime. The genius? You're not checking divisibility - you're just crossing off multiples. Way faster. And starting from i² instead of 2i? That's because all smaller multiples were already marked by smaller primes. It's optimization on top of optimization.
                </p>

                <h4>The O(n log log n) Complexity No One Explains</h4>
                <p>
                    The sieve doesn't run in O(n²) like you'd expect from nested loops. It's O(n log log n), which is almost linear. Why? Because you're only marking multiples of primes, and there are roughly n/ln(n) primes up to n. The sum of (1/p) for all primes p converges to log log n (by the prime number theorem). This is one of those beautiful mathematical results where number theory and algorithm analysis collide. Translation: The sieve is FAST - way faster than it looks.
                </p>
            </div>

            <div class="content-block">
                <h4>PATTERN 17: Prime Number Patterns</h4>
                
                <p><strong>Pattern 1: Check if Prime</strong></p>
                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    <pre><code>def is_prime(n):
    """
    Check if number is prime
    
    Optimization: Only check up to √n
    """
    if n < 2:
        return False
    
    if n == 2:
        return True
    
    if n % 2 == 0:
        return False
    
    # Check odd divisors from 3 to √n
    i = 3
    while i * i <= n:
        if n % i == 0:
            return False
        i += 2  # Skip even numbers
    
    return True

# Why i*i <= n instead of i <= sqrt(n)?
# Avoid expensive sqrt computation!
# Mathematical equivalent: i ≤ √n ⟺ i² ≤ n</code></pre>
                </div>

                <p><strong>Pattern 2: Sieve of Eratosthenes</strong></p>
                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    <pre><code>def sieve_of_eratosthenes(n):
    """
    Find all primes up to n
    
    Algorithm: Mark multiples of each prime as composite
    """
    is_prime = [True] * (n + 1)
    is_prime[0] = is_prime[1] = False
    
    # Only need to check up to √n
    i = 2
    while i * i <= n:
        if is_prime[i]:
            # Mark all multiples of i as not prime
            # Optimization: Start from i²
            for j in range(i * i, n + 1, i):
                is_prime[j] = False
        i += 1
    
    return [i for i in range(n + 1) if is_prime[i]]

# Why start from i²?
# All multiples before i² are already marked!
# - 2p marked by 2 (if p > 2)
# - 3p marked by 3 (if p > 3)
# So we can start from p² safely</code></pre>
                </div>
            </div>

            <!-- Interactive Demo: Prime Sieve -->
            <div class="interactive-demo">
                <h3>Interactive: Sieve of Eratosthenes Visualizer</h3>
                <p class="demo-desc">Watch how the sieve marks composite numbers to find all primes!</p>
                
                <div class="demo-controls">
                    <label style="color: var(--text-muted);">Find primes up to:</label>
                    <input type="number" id="sieve-n" value="30" min="2" max="100" 
                           style="width: 100px; padding: 0.5rem; background: var(--code-bg); border: 1px solid var(--glass-border); color: white; border-radius: 6px;">
                    <button class="btn" onclick="sieveDemo.generate()">Generate Primes</button>
                    <button class="btn" onclick="sieveDemo.animate()">Animate Sieve</button>
                </div>
                
                <div class="playground-canvas">
                    <div id="sieve-grid" style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; margin-bottom: 20px;">
                        <!-- Populated by JS -->
                    </div>
                    <div id="sieve-result" style="padding: 15px; background: rgba(0,0,0,0.3); border-radius: 6px;">
                        <div style="color: var(--text-muted);">Primes found: <span id="sieve-primes" style="color: var(--mclaren-orange); font-family: 'Courier New', monospace; font-weight: 600;">[]</span></div>
                        <div style="color: var(--text-muted); margin-top: 8px;">Current prime: <span id="sieve-current" style="color: var(--meta-blue); font-weight: 600;">-</span></div>
                    </div>
                </div>
            </div>

            <!-- PATTERN 19: Fast Exponentiation -->
            <div class="feynman-dive">
                <h3>The "Squaring Is Faster Than Multiplying, Who Knew?" Revelation</h3>
                <p class="feynman-intro">
                    Computing 3^1000 by multiplying 3 by itself 999 times is technically correct, and also technically insane. You'd be sitting there like a human calculator doing multiplications until the heat death of the universe. Binary exponentiation says: "What if we squared repeatedly and only multiplied when necessary?" Result? Computing 3^1000 in about 10 operations instead of 999. This isn't just an optimization - it's the difference between "feasible" and "mathematically impossible." And it's all thanks to thinking in binary.
                </p>

                <h4>The Binary Decomposition Breakthrough</h4>
                <p>
                    Every number is a sum of powers of 2 (that's literally what binary representation means). So 13 = 8 + 4 + 1 = 2³ + 2² + 2⁰. Therefore, 3^13 = 3^8 × 3^4 × 3^1. Now here's the kicker: You can build 3^1, 3^2, 3^4, 3^8 by repeated squaring: 3¹ → (3¹)² = 3² → (3²)² = 3⁴ → (3⁴)² = 3⁸. That's 3 squaring operations to build all the powers you need, then multiply the ones corresponding to 1-bits in 13's binary. Total: way fewer than 13 multiplications.
                </p>

                <h4>Why This Makes Cryptography Possible</h4>
                <p>
                    RSA encryption requires computing (message^e) mod n where e might be 65537 and n is a 2048-bit number. Computing this naively? Literally impossible - you'd overflow after like 10 multiplications. Binary exponentiation + modular arithmetic? Doable in milliseconds. Each squaring is followed by mod to keep numbers bounded. The result: You can compute astronomical exponentiations on numbers with hundreds of digits in logarithmic time. This is why your HTTPS connection doesn't take an hour to establish.
                </p>

                <h4>The "Bit Manipulation Is Your Friend" Lesson</h4>
                <p>
                    The loop checks `if (exp % 2 == 1)` to see if the current bit is set. That's literally reading the binary representation bit by bit. Then `exp //= 2` shifts right (removes that bit). You're essentially scanning the exponent's binary representation from right to left, deciding "do I need this power?" for each bit. It's a perfect marriage of bit manipulation and exponentiation - two things that seem unrelated but work together beautifully.
                </p>
            </div>

            <div class="content-block">
                <h4>PATTERN 19: Fast Exponentiation (Binary Exponentiation)</h4>
                
                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    <pre><code>def fast_power(base, exp):
    """
    Calculate base^exp efficiently
    
    Instead of exp multiplications, use O(log exp)
    
    Key insight: 
    x^10 = (x^5)^2 = ((x^2)^2 * x)^2
    """
    result = 1
    
    while exp > 0:
        # If exp is odd, multiply result by base
        if exp % 2 == 1:
            result *= base
        
        # Square the base
        base *= base
        
        # Halve the exponent
        exp //= 2
    
    return result

# Trace for 3^13:
# Binary of 13: 1101
# 
# exp=13 (odd): result=1*3=3,    base=3²=9,    exp=6
# exp=6 (even): result=3,        base=9²=81,   exp=3
# exp=3 (odd):  result=3*81=243, base=81²=..., exp=1
# exp=1 (odd):  result=243*...,  ...
# 
# Only 4 iterations instead of 13 multiplications!</code></pre>
                </div>

                <div class="info-box">
                    <strong>Understanding Binary Exponentiation:</strong><br><br>
                    13 in binary: 1101<br>
                    Position: 3210<br><br>
                    13 = 1×2³ + 1×2² + 0×2¹ + 1×2⁰<br>
                    &nbsp;&nbsp;&nbsp;= 8 + 4 + 0 + 1<br><br>
                    So: 3^13 = 3^8 × 3^4 × 3^1<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= (3^1)^8 × (3^1)^4 × 3^1<br><br>
                    We build: 3^1 → 3^2 → 3^4 → 3^8<br>
                    By repeated squaring!
                </div>

                <p><strong>Modular Exponentiation:</strong></p>
                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    <pre><code>def mod_power(base, exp, mod):
    """
    Calculate (base^exp) % mod efficiently
    
    Prevents overflow by taking mod at each step
    """
    result = 1
    base = base % mod
    
    while exp > 0:
        if exp % 2 == 1:
            result = (result * base) % mod
        
        base = (base * base) % mod
        exp //= 2
    
    return result

# Example: Calculate (2^1000) % 13
# Without modular arithmetic: 2^1000 is HUGE (301 digits!)
# With modular arithmetic: Result fits in integer
#
# This is used in RSA encryption!</code></pre>
                </div>
            </div>

            <!-- Interactive Demo: Fast Power -->
            <div class="interactive-demo">
                <h3>Interactive: Fast Exponentiation Visualizer</h3>
                <p class="demo-desc">See how binary exponentiation computes powers in logarithmic time!</p>
                
                <div class="demo-controls">
                    <label style="color: var(--text-muted);">Base:</label>
                    <input type="number" id="power-base" value="3" min="2" max="10" 
                           style="width: 80px; padding: 0.5rem; background: var(--code-bg); border: 1px solid var(--glass-border); color: white; border-radius: 6px;">
                    <label style="color: var(--text-muted);">Exponent:</label>
                    <input type="number" id="power-exp" value="13" min="1" max="20" 
                           style="width: 80px; padding: 0.5rem; background: var(--code-bg); border: 1px solid var(--glass-border); color: white; border-radius: 6px;">
                    <button class="btn" onclick="powerDemo.calculate()">Calculate</button>
                    <button class="btn" onclick="powerDemo.stepThrough()">Step Through</button>
                </div>
                
                <div class="playground-canvas">
                    <div id="power-steps" style="font-family: 'Courier New', monospace; margin-bottom: 20px; min-height: 200px;">
                        <!-- Populated by JS -->
                    </div>
                    <div id="power-result" style="padding: 15px; background: rgba(255, 128, 0, 0.1); border: 1px solid var(--mclaren-orange); border-radius: 6px; text-align: center;">
                        <div style="color: var(--text-muted);">Result: <span id="power-answer" style="color: var(--mclaren-orange); font-weight: 600; font-size: 1.5rem;">-</span></div>
                        <div style="color: var(--text-muted); margin-top: 8px;">Iterations: <span id="power-iterations" style="color: var(--meta-blue); font-weight: 600;">0</span></div>
                    </div>
                </div>
            </div>

        </article>

        <!-- SECTION 5: STATE MACHINE PATTERNS -->
        <article id="section5" class="section">
            <div class="section-header">
                <h2 class="section-title">SECTION 5: STATE MACHINE PATTERNS</h2>
            </div>

            <div class="feynman-dive">
                <h3>The "Your Code Is Already A State Machine, You Just Don't Know It" Awakening</h3>
                <p class="feynman-intro">
                    Every "complex" loop is secretly a state machine. That tracking variable? State. Those if-conditions deciding what to do next? State transitions. The loop deciding when to continue? State validity check. Once you realize this, you stop writing tangled if-else spaghetti and start designing clean state-transition systems. This is how parsers work, how game AI works, how protocol handlers work - it's all state machines under the hood. And guess what implements state machines? Loops. You've been writing them all along without the formal framework. Now you get the framework.
                </p>

                <h4>Why State Machines Make Everything Clearer</h4>
                <p>
                    Without the state machine mental model, your code looks like: "if this then that, unless this other thing, but also check this edge case..." Nightmare. With the state machine mental model: "In state A, on input X, go to state B. In state B, on input Y, go to state C." Clean. Testable. Understandable. The state machine forces you to think declaratively: WHAT are the states? WHAT triggers transitions? This clarity eliminates bugs and makes your code maintainable.
                </p>

                <h4>The Stack Pattern: When Simple State Isn't Enough</h4>
                <p>
                    Some problems need nested state - you're not just "in state A," you're "in state A, having come from state B, which we'll return to." That's a stack. Opening brackets push state. Closing brackets pop state and verify match. Function calls push return addresses. Recursive descent parsers push grammar rules. The stack IS the state history - it's "how did I get here?" encoded as a data structure. Master this, and you can parse anything.
                </p>

                <h4>Sliding Window: The Dynamic State Pattern</h4>
                <p>
                    Sliding window problems maintain a CHANGING state (what's currently in the window) as the window moves. This is state machine thinking at its finest: state = window contents (usually a frequency map), transitions = expand/shrink, validity = constraint check. The loop manages state evolution automatically - you just define what "valid" means and let the expand-shrink logic handle the rest. This pattern turns exponentially hard substring problems into linear-time solutions. That's the power of good state management.
                </p>
            </div>

            <!-- Practical Approach -->
            <div class="practical-approach">
                <h3>Step-by-step practical approach</h3>
                <ul>
                    <li><strong>Define states:</strong> List all possible states the system can be in</li>
                    <li><strong>Map transitions:</strong> Draw state diagram showing how states connect</li>
                    <li><strong>Track explicitly:</strong> Use variables to track current state</li>
                    <li><strong>Update atomically:</strong> Change state based on current state + input</li>
                    <li><strong>Test edge cases:</strong> What happens at state boundaries? Empty input? Invalid transitions?</li>
                </ul>
            </div>

            <!-- Theoretical Dive -->
            <div class="theoretical-dive">
                <h3>🎓 Deep Theoretical Dive</h3>
                
                <div class="theory-section">
                    <h4>Finite State Machines & Automata Theory</h4>
                    <p><strong>Formal FSM Components:</strong></p>
                    <ul>
                        <li><strong>State set (S):</strong> All possible states the system can be in</li>
                        <li><strong>Initial state (s₀):</strong> Where the machine starts</li>
                        <li><strong>Accepting states (F):</strong> Valid end states</li>
                        <li><strong>Transition function (δ):</strong> δ: S × Σ → S
                            <ul>
                                <li>Maps: (current state, input) → next state</li>
                                <li>This IS your loop logic!</li>
                            </ul>
                        </li>
                        <li><strong>Language recognition:</strong>
                            <ul>
                                <li>Regular FSMs: recognize regular languages</li>
                                <li>Pushdown automata: FSM + stack (for nested structures)</li>
                                <li>Example: Balanced parentheses = pushdown automaton</li>
                            </ul>
                        </li>
                        <li><strong>Why this matters:</strong> Classifies problem complexity and solvability</li>
                    </ul>
                </div>

                <div class="theory-section">
                    <h4>Dynamic Programming & State Transitions</h4>
                    <p><strong>DP as State Machine:</strong></p>
                    <ul>
                        <li><strong>The connection:</strong>
                            <ul>
                                <li>DP recurrence: dp[i][state] = f(dp[i-1][prev_states])</li>
                                <li>This IS a state transition function!</li>
                            </ul>
                        </li>
                        <li><strong>Example: Stock buy/sell problem</strong>
                            <ul>
                                <li>States: {holding, sold, rest}</li>
                                <li>Actions: {buy, sell, hold}</li>
                                <li>Transitions determined by current state + action</li>
                            </ul>
                        </li>
                        <li><strong>Problem modeling framework:</strong>
                            <ul>
                                <li>States = "What position am I in?"</li>
                                <li>Transitions = "What can I do next?"</li>
                                <li>Optimization = "Which transition path is best?"</li>
                            </ul>
                        </li>
                    </ul>
                </div>

                <div class="theory-section">
                    <h4>Sliding Window as State Machine</h4>
                    <p><strong>Dynamic State Evolution:</strong></p>
                    <ul>
                        <li><strong>State definition:</strong>
                            <ul>
                                <li>State = window contents (usually frequency map)</li>
                                <li>Changes as window slides across data</li>
                            </ul>
                        </li>
                        <li><strong>State transitions:</strong>
                            <ul>
                                <li>Expand: Add right element to window (state += new element)</li>
                                <li>Shrink: Remove left element from window (state -= old element)</li>
                            </ul>
                        </li>
                        <li><strong>Validity checking:</strong>
                            <ul>
                                <li>Define constraint: "at most K distinct characters"</li>
                                <li>Check: Is current state valid?</li>
                                <li>Action: If invalid, shrink until valid</li>
                            </ul>
                        </li>
                        <li><strong>The systematic approach:</strong>
                            <ul>
                                <li>1. Define valid state</li>
                                <li>2. Expand until invalid</li>
                                <li>3. Shrink until valid</li>
                                <li>4. Track optimal state seen</li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>

            <!-- PATTERN 22: Parser Pattern -->
            <div class="feynman-dive">
                <h3>The "Your Loop Is Actually A State Machine, Change My Mind" Epiphany</h3>
                <p class="feynman-intro">
                    State machines sound scary and theoretical, like something from a formal CS course taught by someone who hasn't written production code since 1987. But guess what? That loop you wrote to validate parentheses? State machine. That loop tracking the longest substring? State machine. That parser checking JSON syntax? State machine. <strong>Most "complex" loops are just state machines in disguise.</strong> Once you recognize this, you stop writing spaghetti code and start designing clean state transitions.
                </p>

                <h4>Why Parentheses Validation Is The Perfect Example</h4>
                <p>
                    Checking if parentheses are balanced is conceptually simple: track depth. See '('? Go deeper (depth++). See ')'? Go shallower (depth--). Depth goes negative? Invalid (more closes than opens). End with depth != 0? Invalid (unclosed opens). This is a state machine with a single state variable (depth) and simple transitions. But it generalizes: Want to check multiple bracket types? Add a stack. Want to validate nested structures? Add more state variables. The pattern scales.
                </p>

                <h4>The Stack As State Pattern</h4>
                <p>
                    When simple counters aren't enough, the stack pattern dominates. Push when you enter a context (opening bracket, function call, nested structure). Pop when you exit. Match what you popped with what you're seeing - if they don't match, error. This pattern is EVERYWHERE: expression parsing, recursive descent parsers, HTML/XML validation, undo/redo systems. The stack IS the state - it represents "where am I in this nested structure?" at any point in the loop.
                </p>

                <h4>Why This Makes You A Better Programmer</h4>
                <p>
                    Once you start thinking in states and transitions, you write cleaner code. Instead of a rats nest of if-else statements, you have: "In state A, on input X, transition to state B." It's declarative, testable, and maintainable. This is the mental model used in: regex engines, compilers, protocol handlers, game AI, and pretty much any system that responds to inputs. Master state machine loops, and you've unlocked a superpower.
                </p>
            </div>

            <div class="content-block">
                <h4>PATTERN 22: Parser Pattern</h4>
                
                <p><strong>Example: Balanced Parentheses</strong></p>
                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    <pre><code>def is_valid_expression(s):
    """
    Check if parentheses are balanced
    
    States:
    - depth: Current nesting depth
    - Transition: '(' increases, ')' decreases
    """
    depth = 0
    
    for char in s:
        if char == '(':
            depth += 1
        elif char == ')':
            depth -= 1
            if depth < 0:
                return False  # More ')' than '('
    
    return depth == 0  # Must end at depth 0

# Trace for "((())())":
# char='(': depth=1
# char='(': depth=2
# char='(': depth=3
# char=')': depth=2
# char=')': depth=1
# char='(': depth=2
# char=')': depth=1
# char=')': depth=0
# Return True (balanced)</code></pre>
                </div>

                <p><strong>Advanced: Multiple Bracket Types</strong></p>
                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    <pre><code>def is_valid_brackets(s):
    """
    Check if brackets are balanced: (), [], {}
    """
    stack = []
    matching = {'(': ')', '[': ']', '{': '}'}
    
    for char in s:
        if char in matching:
            # Opening bracket: push to stack
            stack.append(char)
        elif char in matching.values():
            # Closing bracket: check if matches
            if not stack:
                return False
            
            last_open = stack.pop()
            if matching[last_open] != char:
                return False
    
    return len(stack) == 0

# This is a state machine using stack!</code></pre>
                </div>
            </div>

            <!-- Interactive Demo: Bracket Validator -->
            <div class="interactive-demo">
                <h3>Interactive: Bracket Balance Validator</h3>
                <p class="demo-desc">Watch the state machine validate bracket sequences step by step!</p>
                
                <div class="demo-controls">
                    <label style="color: var(--text-muted);">Expression:</label>
                    <input type="text" id="bracket-expr" value="((())())" 
                           style="width: 200px; padding: 0.5rem; background: var(--code-bg); border: 1px solid var(--glass-border); color: white; border-radius: 6px; font-family: 'Courier New', monospace;">
                    <button class="btn" onclick="bracketDemo.validate()">Validate</button>
                    <button class="btn" onclick="bracketDemo.stepThrough()">Step Through</button>
                </div>
                
                <div class="playground-canvas">
                    <div id="bracket-visualization" style="margin-bottom: 20px; min-height: 150px;">
                        <!-- Populated by JS -->
                    </div>
                    <div id="bracket-result" style="padding: 15px; border-radius: 6px; text-align: center; font-weight: 600; font-size: 1.2rem;">
                        Enter an expression and click Validate
                    </div>
                </div>
            </div>

            <!-- PATTERN 23: Run-Length Encoding -->
            <div class="feynman-dive">
                <h3>The "Count Before You Change" Compression Hack</h3>
                <p class="feynman-intro">
                    Run-length encoding is what happens when you realize that "aaaaaaa" (7 bytes) can be represented as "a7" (2 bytes). Mind-blowing compression ratio, right? This is how old-school image formats (BMP, PCX) compressed data, how fax machines encoded documents, and how you'd solve the LeetCode problem "compress this string" without overthinking it. The loop pattern? Track the current character, count consecutive occurrences, emit the count when you hit a different character. Simple, effective, and a gateway drug to state machine thinking.
                </p>

                <h4>The State Transition Is The Algorithm</h4>
                <p>
                    State = (current character, count). Transition rule: "Same character? Increment count. Different character? Emit current, reset state." This is pure state machine logic. The beauty is in its simplicity - there's no complex condition chains, no nested ifs. Just: "am I still seeing the same thing?" If yes, count++. If no, output and switch context. This pattern generalizes to ANY "process until change" problem: stock price streaks, game state transitions, anything with runs of identical values.
                </p>

                <h4>The "Don't Forget The Last Group" Bug</h4>
                <p>
                    Classic RLE bug: You process all character transitions in the loop, but the LAST group never triggers a transition (there's no "next different character"). So after the loop, you have to emit the final group manually. Forget this, and your encoding is incomplete. Test case that catches this? Strings with only one character type ("aaaaa"). The loop never executes a transition, so the result would be empty without the final emit. This is why edge case testing matters.
                </p>
            </div>

            <div class="content-block">
                <h4>PATTERN 23: Run-Length Encoding Pattern</h4>
                
                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    <pre><code>def run_length_encode(s):
    """
    Encode consecutive repeated characters
    
    Example: "aaabbcccc" → "a3b2c4"
    """
    if not s:
        return ""
    
    result = []
    current_char = s[0]
    count = 1
    
    for i in range(1, len(s)):
        if s[i] == current_char:
            count += 1
        else:
            # State transition: different character
            result.append(current_char + str(count))
            current_char = s[i]
            count = 1
    
    # Don't forget last group!
    result.append(current_char + str(count))
    
    return ''.join(result)

# Trace for "aaabbcccc":
# i=1: 'a'=='a', count=2
# i=2: 'a'=='a', count=3
# i=3: 'b'!='a', append 'a3', current='b', count=1
# i=4: 'b'=='b', count=2
# i=5: 'c'!='b', append 'b2', current='c', count=1
# i=6: 'c'=='c', count=2
# i=7: 'c'=='c', count=3
# i=8: 'c'=='c', count=4
# End: append 'c4'
# Result: "a3b2c4"</code></pre>
                </div>
            </div>

            <!-- Interactive Demo: RLE -->
            <div class="interactive-demo">
                <h3>Interactive: Run-Length Encoding</h3>
                <p class="demo-desc">See how consecutive characters are compressed!</p>
                
                <div class="demo-controls">
                    <label style="color: var(--text-muted);">String to encode:</label>
                    <input type="text" id="rle-input" value="aaabbcccc" 
                           style="width: 200px; padding: 0.5rem; background: var(--code-bg); border: 1px solid var(--glass-border); color: white; border-radius: 6px; font-family: 'Courier New', monospace;">
                    <button class="btn" onclick="rleDemo.encode()">Encode</button>
                    <button class="btn" onclick="rleDemo.animate()">Animate</button>
                </div>
                
                <div class="playground-canvas">
                    <div id="rle-steps" style="margin-bottom: 20px; font-family: 'Courier New', monospace; min-height: 150px;">
                        <!-- Populated by JS -->
                    </div>
                    <div id="rle-result" style="padding: 15px; background: rgba(0, 129, 251, 0.1); border: 1px solid var(--meta-blue); border-radius: 6px;">
                        <div style="color: var(--text-muted);">Original: <span id="rle-original" style="color: white; font-family: 'Courier New', monospace;">-</span></div>
                        <div style="color: var(--text-muted); margin-top: 8px;">Encoded: <span id="rle-encoded" style="color: var(--meta-blue); font-family: 'Courier New', monospace; font-weight: 600;">-</span></div>
                        <div style="color: var(--text-muted); margin-top: 8px;">Compression: <span id="rle-compression" style="color: #3fb950; font-weight: 600;">-</span></div>
                    </div>
                </div>
            </div>

            <!-- PATTERN 24: Sliding Window with State -->
            <div class="feynman-dive">
                <h3>The "Two Pointers Playing Tag With A HashMap" Pattern</h3>
                <p class="feynman-intro">
                    Sliding window with state is peak algorithmic elegance. You've got a window (substring, subarray, whatever) that slides across your data. The window expands when you're greedy for more, shrinks when you violate constraints. The state (usually a frequency map or counter) tracks what's IN the window at any moment. Result? You solve in O(n) what would take O(n²) with brute force. This pattern turns "check every substring" problems into "smartly slide a window while tracking state" problems. The difference? Interviews vs unemployment.
                </p>

                <h4>The Expand-Shrink Philosophy</h4>
                <p>
                    The loop always moves right (expanding the window's right boundary). But the left boundary? That moves conditionally - only when the window violates constraints. This asymmetry is KEY. Right pointer: greedy, always advancing. Left pointer: defensive, only moves when forced. The result is a single pass through the data (O(n)) where each element is added once and removed at most once (amortized O(1) per operation). This is why sliding window beats nested loops - you're not rechecking from scratch, you're maintaining state incrementally.
                </p>

                <h4>The HashMap State Trick</h4>
                <p>
                    Using a frequency map to track "what's in the window" is genius because: (1) Adding is O(1) - just increment count. (2) Removing is O(1) - just decrement count. (3) Checking validity is O(1) - just check map.size() or some aggregate property. You're maintaining complex state (character frequencies) with constant-time operations. Without the map, you'd need to scan the window every time - O(window_size) per step, making the whole algorithm O(n²). The map is what makes it O(n).
                </p>

                <h4>Why "At Most K Distinct" Is The Template Problem</h4>
                <p>
                    "Longest substring with at most K distinct characters" is the canonical sliding window + state problem because it teaches you: (1) How to expand (add to state), (2) How to shrink (remove from state), (3) When to shrink (violates constraint), (4) What to track (max length seen). Master this, and you can solve: longest substring without repeating characters, minimum window substring, substring with all characters, subarray with sum ≤ K, etc. It's a template. The state changes, the constraint changes, but the expand-shrink loop stays the same.
                </p>
            </div>

            <div class="content-block">
                <h4>PATTERN 24: Sliding Window with State</h4>
                
                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    <pre><code>def longest_substring_k_distinct(s, k):
    """
    Find longest substring with at most k distinct characters
    
    State: Character frequency map
    """
    char_count = {}
    left = 0
    max_length = 0
    
    for right in range(len(s)):
        # Expand window: add character
        char = s[right]
        char_count[char] = char_count.get(char, 0) + 1
        
        # Shrink window: too many distinct characters
        while len(char_count) > k:
            left_char = s[left]
            char_count[left_char] -= 1
            if char_count[left_char] == 0:
                del char_count[left_char]
            left += 1
        
        # Update max length
        max_length = max(max_length, right - left + 1)
    
    return max_length

# Trace for s="eceba", k=2:
# right=0: char='e', count={'e':1}, len=1, max=1
# right=1: char='c', count={'e':1,'c':1}, len=2, max=2
# right=2: char='e', count={'e':2,'c':1}, len=3, max=3
# right=3: char='b', count={'e':2,'c':1,'b':1}, len>2!
#   Shrink: left=0, remove 'e', count={'e':1,'c':1,'b':1}
#   Still len>2, left=1, remove 'c', count={'e':1,'b':1}
#   Now len=2, window="eb", length=2
# right=4: char='a', count={'e':1,'b':1,'a':1}, len>2!
#   Shrink until len=2
# max_length = 3</code></pre>
                </div>
            </div>

            <!-- Interactive Demo: Sliding Window -->
            <div class="interactive-demo">
                <h3>Interactive: Sliding Window Visualizer</h3>
                <p class="demo-desc">Watch the window expand and shrink to maintain valid state!</p>
                
                <div class="demo-controls">
                    <label style="color: var(--text-muted);">String:</label>
                    <input type="text" id="window-string" value="eceba" 
                           style="width: 150px; padding: 0.5rem; background: var(--code-bg); border: 1px solid var(--glass-border); color: white; border-radius: 6px; font-family: 'Courier New', monospace;">
                    <label style="color: var(--text-muted);">Max distinct (k):</label>
                    <input type="number" id="window-k" value="2" min="1" max="5" 
                           style="width: 70px; padding: 0.5rem; background: var(--code-bg); border: 1px solid var(--glass-border); color: white; border-radius: 6px;">
                    <button class="btn" onclick="windowDemo.animate()">Animate</button>
                </div>
                
                <div class="playground-canvas">
                    <div id="window-visual" style="margin-bottom: 20px; min-height: 200px;">
                        <!-- Populated by JS -->
                    </div>
                    <div id="window-state" style="padding: 15px; background: rgba(0,0,0,0.3); border-radius: 6px;">
                        <div style="color: var(--text-muted);">Window: <span id="window-current" style="color: var(--mclaren-orange); font-family: 'Courier New', monospace; font-weight: 600;">-</span></div>
                        <div style="color: var(--text-muted); margin-top: 8px;">Distinct chars: <span id="window-distinct" style="color: var(--meta-blue); font-weight: 600;">0</span></div>
                        <div style="color: var(--text-muted); margin-top: 8px;">Max length: <span id="window-max" style="color: #3fb950; font-weight: 600;">0</span></div>
                    </div>
                </div>
            </div>

        </article>

        <!-- Summary Section -->
        <article class="section">
            <div class="section-header">
                <h2 class="section-title">✅ ADVANCED LOOP MASTERY COMPLETE</h2>
            </div>

            <div class="content-block" style="border: 2px solid var(--mclaren-orange);">
                <h3 style="color: var(--mclaren-orange); text-align: center; margin-bottom: var(--spacing-lg);">The Complete Pattern Library</h3>
                
                <p>You now have <strong>24 advanced patterns</strong>:</p>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-top: 30px;">
                    <div>
                        <h4 style="color: var(--meta-blue); margin-bottom: 15px;">Single Loop Patterns:</h4>
                        <ul style="list-style: none; padding: 0;">
                            <li style="padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">✅ Powers of Two Iteration</li>
                            <li style="padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">✅ Digit-by-Digit Processing</li>
                            <li style="padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">✅ GCD/Euclidean Algorithm</li>
                            <li style="padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">✅ Conditional Skip Patterns</li>
                            <li style="padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">✅ Multiple Pointers</li>
                            <li style="padding: 8px 0;">✅ State Tracking</li>
                        </ul>
                    </div>

                    <div>
                        <h4 style="color: var(--mclaren-orange); margin-bottom: 15px;">Nested Loop Patterns:</h4>
                        <ul style="list-style: none; padding: 0;">
                            <li style="padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">✅ Triangle Patterns</li>
                            <li style="padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">✅ Diamond/Pyramid</li>
                            <li style="padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">✅ Spiral Traversal</li>
                            <li style="padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">✅ Diagonal Traversal</li>
                            <li style="padding: 8px 0;">✅ Layer-by-Layer</li>
                        </ul>
                    </div>

                    <div>
                        <h4 style="color: var(--redbull-red); margin-bottom: 15px;">Optimization Patterns:</h4>
                        <ul style="list-style: none; padding: 0;">
                            <li style="padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">✅ Loop Fusion</li>
                            <li style="padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">✅ Loop Fission</li>
                            <li style="padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">✅ Early Termination</li>
                            <li style="padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">✅ Amortized Techniques</li>
                            <li style="padding: 8px 0;">✅ Cache-Aware Design</li>
                        </ul>
                    </div>

                    <div>
                        <h4 style="color: #3fb950; margin-bottom: 15px;">Mathematical Patterns:</h4>
                        <ul style="list-style: none; padding: 0;">
                            <li style="padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">✅ Prime Number Patterns</li>
                            <li style="padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">✅ Fibonacci Variants</li>
                            <li style="padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">✅ Fast Exponentiation</li>
                            <li style="padding: 8px 0;">✅ Modular Arithmetic</li>
                        </ul>
                    </div>

                    <div>
                        <h4 style="color: var(--meta-light); margin-bottom: 15px;">State Machine Patterns:</h4>
                        <ul style="list-style: none; padding: 0;">
                            <li style="padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">✅ Multi-State Tracking</li>
                            <li style="padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">✅ Parser Patterns</li>
                            <li style="padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">✅ Run-Length Encoding</li>
                            <li style="padding: 8px 0;">✅ Sliding Window with State</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="content-block" style="background: linear-gradient(135deg, rgba(255, 128, 0, 0.1), rgba(0, 129, 251, 0.1)); border: 2px solid var(--meta-blue); margin-top: 30px;">
                <h3 style="color: var(--meta-blue); text-align: center; margin-bottom: 20px;">Pattern Selection Framework</h3>
                
                <div style="background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px; font-family: 'Courier New', monospace; line-height: 2;">
                    <strong style="color: var(--mclaren-orange);">1. What am I processing?</strong><br>
                    &nbsp;&nbsp;- Numbers → Digit/Math patterns<br>
                    &nbsp;&nbsp;- Arrays → Traversal patterns<br>
                    &nbsp;&nbsp;- Matrices → Nested patterns<br>
                    &nbsp;&nbsp;- Strings → Parser/State patterns<br><br>

                    <strong style="color: var(--mclaren-orange);">2. What's the goal?</strong><br>
                    &nbsp;&nbsp;- Find something → Early termination<br>
                    &nbsp;&nbsp;- Process all → Full traversal<br>
                    &nbsp;&nbsp;- Build something → Accumulation patterns<br>
                    &nbsp;&nbsp;- Transform → State machine<br><br>

                    <strong style="color: var(--mclaren-orange);">3. What constraints?</strong><br>
                    &nbsp;&nbsp;- Speed critical → Optimize (fusion, cache-aware)<br>
                    &nbsp;&nbsp;- Space critical → In-place patterns<br>
                    &nbsp;&nbsp;- Both → Amortized patterns<br><br>

                    <strong style="color: var(--mclaren-orange);">4. What structure?</strong><br>
                    &nbsp;&nbsp;- Sequential → Single loop<br>
                    &nbsp;&nbsp;- Pairs → Nested loop<br>
                    &nbsp;&nbsp;- Complex → State machine
                </div>
            </div>

            <div class="content-block" style="margin-top: 30px;">
                <h3 style="text-align: center; color: var(--mclaren-orange);">Practice Challenges</h3>
                <p style="text-align: center; margin-bottom: 20px;">Apply these advanced patterns:</p>
                
                <ol style="line-height: 2;">
                    <li><strong>Spiral Matrix Generation</strong> - Create n×n matrix filled 1 to n² in spiral order</li>
                    <li><strong>Longest Zigzag Subsequence</strong> - State machine with alternating direction</li>
                    <li><strong>Matrix Layer Rotation</strong> - Rotate each layer independently</li>
                    <li><strong>Prime Factorization with Loop</strong> - Find all prime factors</li>
                    <li><strong>Nested Parentheses Validator</strong> - Multi-level state tracking</li>
                </ol>
            </div>
        </article>

    </main>

    <!-- Footer -->
    <footer style="text-align: center; padding: var(--spacing-xl) 0; margin-top: var(--spacing-2xl); border-top: 1px solid var(--glass-border); color: var(--text-dim);">
        <div class="container">
            <p>&copy; 2025 ROVER. Master Advanced Looping Techniques.</p>
        </div>
    </footer>

    <!-- JavaScript for Interactivity -->
    <script>
        // Reading Progress Bar
        window.addEventListener('scroll', () => {
            const windowHeight = window.innerHeight;
            const documentHeight = document.documentElement.scrollHeight - windowHeight;
            const scrolled = window.scrollY;
            const progress = (scrolled / documentHeight) * 100;
            document.getElementById('reading-progress').style.width = progress + '%';
        });

        // Hamburger Menu
        function initHamburgerMenu() {
            const hamburger = document.getElementById('hamburger');
            const navLinks = document.getElementById('navLinks');
            const mobileOverlay = document.getElementById('mobileOverlay');
            const navLinkItems = document.querySelectorAll('.nav-link');

            if (!hamburger || !navLinks || !mobileOverlay) return;

            hamburger.addEventListener('click', (e) => {
                e.stopPropagation();
                hamburger.classList.toggle('active');
                navLinks.classList.toggle('active');
                mobileOverlay.classList.toggle('active');
                document.body.style.overflow = navLinks.classList.contains('active') ? 'hidden' : '';
            });

            mobileOverlay.addEventListener('click', () => {
                hamburger.classList.remove('active');
                navLinks.classList.remove('active');
                mobileOverlay.classList.remove('active');
                document.body.style.overflow = '';
            });

            navLinkItems.forEach(link => {
                link.addEventListener('click', () => {
                    if (window.innerWidth <= 768) {
                        hamburger.classList.remove('active');
                        navLinks.classList.remove('active');
                        mobileOverlay.classList.remove('active');
                        document.body.style.overflow = '';
                    }
                });
            });

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && navLinks.classList.contains('active')) {
                    hamburger.classList.remove('active');
                    navLinks.classList.remove('active');
                    mobileOverlay.classList.remove('active');
                    document.body.style.overflow = '';
                }
            });
        }

        // Initialize hamburger menu separately
        document.addEventListener('DOMContentLoaded', initHamburgerMenu);

        // Active Navigation
        window.addEventListener('scroll', () => {
            let current = '';
            const sections = document.querySelectorAll('.section');
            
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                if (window.scrollY >= sectionTop - 200) {
                    current = section.getAttribute('id');
                }
            });

            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        });

        // Syntax Highlighting for Code Blocks
        function highlightCode(code) {
            // Store protected elements
            const protectedStrings = [];
            const protectedComments = [];
            
            let result = code;
            
            // 1. Protect and highlight strings first
            result = result.replace(/(['"`])(?:(?=(\\?))\2.)*?\1/g, (match) => {
                const placeholder = `___STRING_${protectedStrings.length}___`;
                protectedStrings.push(`<span class="string">${match}</span>`);
                return placeholder;
            });
            
            // 2. Protect and highlight comments
            result = result.replace(/(#[^\n]*)/g, (match) => {
                const placeholder = `___COMMENT_${protectedComments.length}___`;
                protectedComments.push(`<span class="comment">${match}</span>`);
                return placeholder;
            });
            
            // 3. Highlight keywords (now safe from strings and comments)
            result = result.replace(/\b(def|class|if|elif|else|for|while|return|import|from|as|in|and|or|not|is|True|False|None|break|continue|pass|try|except|finally|with|yield|lambda|async|await)\b/g, '<span class="keyword">$1</span>');
            
            // 4. Highlight numbers
            result = result.replace(/\b(\d+\.?\d*)\b/g, '<span class="number">$1</span>');
            
            // 5. Highlight function names (after def)
            result = result.replace(/(<span class="keyword">def<\/span>\s+)(\w+)/g, '$1<span class="function">$2</span>');
            
            // 6. Restore protected elements
            protectedComments.forEach((comment, i) => {
                result = result.replace(`___COMMENT_${i}___`, comment);
            });
            
            protectedStrings.forEach((str, i) => {
                result = result.replace(`___STRING_${i}___`, str);
            });
            
            return result;
        }

        // Apply syntax highlighting to all code blocks
        function applySyntaxHighlighting() {
            document.querySelectorAll('.code-block pre code').forEach(block => {
                // Skip if already highlighted
                if (block.dataset.highlighted === 'true') return;
                
                const originalText = block.textContent;
                const highlighted = highlightCode(originalText);
                block.innerHTML = highlighted;
                block.dataset.highlighted = 'true';
            });
        }

        // Copy Code
        function copyCode(button) {
            const codeBlock = button.nextElementSibling;
            const code = codeBlock.textContent;
            
            navigator.clipboard.writeText(code).then(() => {
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.style.background = 'var(--meta-blue)';
                button.style.borderColor = 'var(--meta-blue)';
                button.style.color = 'white';
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = '';
                    button.style.borderColor = 'rgba(255, 128, 0, 0.4)';
                    button.style.color = 'var(--mclaren-orange)';
                }, 2000);
            });
        }

        // ==================== INTERACTIVE DEMOS ====================

        // Powers of Two Demo
        const powersDemo = {
            visualize() {
                const n = parseInt(document.getElementById('powers-n').value) || 100;
                const visual = document.getElementById('powers-visual');
                const output = document.getElementById('powers-output');
                
                const powers = [];
                let i = 1;
                while (i <= n) {
                    powers.push(i);
                    i *= 2;
                }
                
                visual.innerHTML = powers.map(p => `
                    <div class="iteration-box" style="width: ${Math.min(100 + p/10, 150)}px; height: 80px;">
                        <div class="iteration-label">Power of 2</div>
                        <div class="iteration-value">${p}</div>
                    </div>
                `).join('');
                
                output.innerHTML = `
                    <div style="color: var(--mclaren-orange); font-weight: 600; margin-bottom: 10px;">
                        Powers of 2 up to ${n}: ${powers.join(', ')}
                    </div>
                    <div style="color: var(--text-muted);">
                        Only <strong>${powers.length}</strong> iterations needed (O(log₂ ${n}) ≈ ${Math.log2(n).toFixed(2)})
                    </div>
                    <div style="color: var(--text-muted); margin-top: 8px;">
                        Compare to: Linear iteration would need ${n} iterations!
                    </div>
                `;
            },

            async animate() {
                const n = parseInt(document.getElementById('powers-n').value) || 100;
                const visual = document.getElementById('powers-visual');
                const output = document.getElementById('powers-output');
                
                visual.innerHTML = '';
                output.innerHTML = 'Animating...';
                
                let i = 1;
                let count = 0;
                while (i <= n) {
                    count++;
                    const box = document.createElement('div');
                    box.className = 'iteration-box active';
                    box.style.width = `${Math.min(100 + i/10, 150)}px`;
                    box.style.height = '80px';
                    box.innerHTML = `
                        <div class="iteration-label">Iteration ${count}</div>
                        <div class="iteration-value">${i}</div>
                    `;
                    visual.appendChild(box);
                    
                    output.innerHTML = `
                        <div style="color: var(--mclaren-orange);">
                            Current value: <strong>${i}</strong> (i *= 2)
                        </div>
                        <div style="color: var(--text-muted); margin-top: 8px;">
                            Iteration: ${count}
                        </div>
                    `;
                    
                    await new Promise(resolve => setTimeout(resolve, 800));
                    box.classList.remove('active');
                    box.classList.add('completed');
                    
                    i *= 2;
                }
                
                output.innerHTML += `
                    <div style="color: #3fb950; font-weight: 600; margin-top: 15px;">
                        Complete! Only ${count} iterations for n=${n}
                    </div>
                `;
            }
        };

        // Digit Processing Demo
        const digitDemo = {
            start() {
                const num = parseInt(document.getElementById('digit-num').value) || 12345;
                const stepsDiv = document.getElementById('digit-steps');
                const resultDiv = document.getElementById('digit-result');
                
                let n = num;
                let steps = '';
                let iteration = 0;
                
                while (n > 0) {
                    const digit = n % 10;
                    iteration++;
                    steps += `<div style="margin-bottom: 10px; padding: 10px; background: rgba(0, 129, 251, 0.1); border-left: 3px solid var(--meta-blue); border-radius: 4px;">
                        <strong>Iteration ${iteration}:</strong><br>
                        num = ${n}<br>
                        digit = ${n} % 10 = <span style="color: var(--mclaren-orange); font-weight: 600;">${digit}</span><br>
                        num = ${n} // 10 = ${Math.floor(n / 10)}
                    </div>`;
                    n = Math.floor(n / 10);
                }
                
                stepsDiv.innerHTML = steps;
                resultDiv.innerHTML = `Extracted ${iteration} digits from ${num}`;
                resultDiv.style.background = 'rgba(59, 185, 80, 0.1)';
                resultDiv.style.borderColor = '#3fb950';
                resultDiv.style.color = '#3fb950';
            },

            reverse() {
                const num = parseInt(document.getElementById('digit-num').value) || 12345;
                const stepsDiv = document.getElementById('digit-steps');
                const resultDiv = document.getElementById('digit-result');
                
                let n = num;
                let reversed = 0;
                let steps = `<div style="margin-bottom: 15px; font-weight: 600; color: var(--meta-blue);">Reversing ${num}...</div>`;
                
                while (n > 0) {
                    const digit = n % 10;
                    const oldReversed = reversed;
                    reversed = reversed * 10 + digit;
                    steps += `<div style="margin-bottom: 10px; padding: 10px; background: rgba(255, 128, 0, 0.1); border-left: 3px solid var(--mclaren-orange); border-radius: 4px;">
                        digit = ${n} % 10 = ${digit}<br>
                        reversed = ${oldReversed} * 10 + ${digit} = <span style="color: var(--mclaren-orange); font-weight: 600;">${reversed}</span><br>
                        num = ${n} // 10 = ${Math.floor(n / 10)}
                    </div>`;
                    n = Math.floor(n / 10);
                }
                
                stepsDiv.innerHTML = steps;
                resultDiv.innerHTML = `${num} reversed = <span style="font-size: 1.5rem;">${reversed}</span>`;
                resultDiv.style.background = 'rgba(255, 128, 0, 0.1)';
                resultDiv.style.borderColor = 'var(--mclaren-orange)';
                resultDiv.style.color = 'var(--mclaren-orange)';
            },

            sumDigits() {
                const num = parseInt(document.getElementById('digit-num').value) || 12345;
                const stepsDiv = document.getElementById('digit-steps');
                const resultDiv = document.getElementById('digit-result');
                
                let n = num;
                let sum = 0;
                let steps = `<div style="margin-bottom: 15px; font-weight: 600; color: var(--meta-blue);">Summing digits of ${num}...</div>`;
                
                while (n > 0) {
                    const digit = n % 10;
                    const oldSum = sum;
                    sum += digit;
                    steps += `<div style="margin-bottom: 10px; padding: 10px; background: rgba(59, 185, 80, 0.1); border-left: 3px solid #3fb950; border-radius: 4px;">
                        digit = ${n} % 10 = ${digit}<br>
                        sum = ${oldSum} + ${digit} = <span style="color: #3fb950; font-weight: 600;">${sum}</span><br>
                        num = ${n} // 10 = ${Math.floor(n / 10)}
                    </div>`;
                    n = Math.floor(n / 10);
                }
                
                stepsDiv.innerHTML = steps;
                resultDiv.innerHTML = `Sum of digits of ${num} = <span style="font-size: 1.5rem;">${sum}</span>`;
                resultDiv.style.background = 'rgba(59, 185, 80, 0.1)';
                resultDiv.style.borderColor = '#3fb950';
                resultDiv.style.color = '#3fb950';
            }
        };

        // GCD Demo
        const gcdDemo = {
            calculate() {
                let a = parseInt(document.getElementById('gcd-a').value) || 48;
                let b = parseInt(document.getElementById('gcd-b').value) || 18;
                const vizDiv = document.getElementById('gcd-visualization');
                const resultDiv = document.getElementById('gcd-result');
                
                const originalA = a, originalB = b;
                let steps = '';
                let iteration = 0;
                
                while (b !== 0) {
                    iteration++;
                    const temp = b;
                    const mod = a % b;
                    steps += `<div style="margin-bottom: 12px; padding: 12px; background: rgba(0, 129, 251, 0.1); border-left: 3px solid var(--meta-blue); border-radius: 4px;">
                        <strong>Iteration ${iteration}:</strong><br>
                        a = ${a}, b = ${temp}<br>
                        temp = b = ${temp}<br>
                        b = ${a} % ${temp} = <span style="color: var(--mclaren-orange); font-weight: 600;">${mod}</span><br>
                        a = temp = ${temp}
                    </div>`;
                    a = temp;
                    b = mod;
                }
                
                vizDiv.innerHTML = steps;
                resultDiv.innerHTML = `
                    <div style="font-size: 1.3rem; font-weight: 600; color: var(--meta-blue);">
                        gcd(${originalA}, ${originalB}) = ${a}
                    </div>
                    <div style="color: var(--text-muted); margin-top: 10px;">
                        Found in ${iteration} iterations (O(log min(a,b)))
                    </div>
                `;
            },

            async stepThrough() {
                let a = parseInt(document.getElementById('gcd-a').value) || 48;
                let b = parseInt(document.getElementById('gcd-b').value) || 18;
                const vizDiv = document.getElementById('gcd-visualization');
                const resultDiv = document.getElementById('gcd-result');
                
                const originalA = a, originalB = b;
                vizDiv.innerHTML = '';
                resultDiv.innerHTML = 'Stepping through...';
                
                let iteration = 0;
                while (b !== 0) {
                    iteration++;
                    const temp = b;
                    const mod = a % b;
                    
                    const stepDiv = document.createElement('div');
                    stepDiv.style.cssText = 'margin-bottom: 12px; padding: 12px; background: rgba(255, 128, 0, 0.2); border-left: 3px solid var(--mclaren-orange); border-radius: 4px; animation: fadeIn 0.5s;';
                    stepDiv.innerHTML = `
                        <strong style="color: var(--mclaren-orange);">Step ${iteration}:</strong><br>
                        a = ${a}, b = ${temp}<br>
                        b = ${a} % ${temp} = <span style="color: var(--mclaren-orange); font-weight: 600;">${mod}</span><br>
                        a = ${temp}
                    `;
                    vizDiv.appendChild(stepDiv);
                    
                    resultDiv.innerHTML = `
                        <div style="color: var(--mclaren-orange);">
                            Current: gcd(${a}, ${temp})
                        </div>
                    `;
                    
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    a = temp;
                    b = mod;
                }
                
                resultDiv.innerHTML = `
                    <div style="font-size: 1.3rem; font-weight: 600; color: #3fb950;">
                        gcd(${originalA}, ${originalB}) = ${a}
                    </div>
                    <div style="color: var(--text-muted); margin-top: 10px;">
                        Complete in ${iteration} steps!
                    </div>
                `;
            }
        };

        // Merge Arrays Demo
        const mergeDemo = {
            async animate() {
                const arr1 = document.getElementById('merge-arr1').value.split(',').map(x => parseInt(x.trim()));
                const arr2 = document.getElementById('merge-arr2').value.split(',').map(x => parseInt(x.trim()));
                const vizDiv = document.getElementById('merge-visual');
                const outputDiv = document.getElementById('merge-output');
                
                let i = 0, j = 0;
                const result = [];
                
                vizDiv.innerHTML = `
                    <div style="margin-bottom: 20px;">
                        <div style="color: var(--meta-blue); margin-bottom: 10px;">Array 1: ${arr1.join(', ')}</div>
                        <div style="color: var(--mclaren-orange); margin-bottom: 10px;">Array 2: ${arr2.join(', ')}</div>
                    </div>
                    <div id="merge-steps"></div>
                `;
                
                const stepsDiv = vizDiv.querySelector('#merge-steps');
                
                while (i < arr1.length && j < arr2.length) {
                    const stepDiv = document.createElement('div');
                    stepDiv.style.cssText = 'padding: 10px; margin-bottom: 10px; background: rgba(0,0,0,0.3); border-radius: 6px;';
                    
                    if (arr1[i] <= arr2[j]) {
                        result.push(arr1[i]);
                        stepDiv.innerHTML = `
                            <span style="color: var(--meta-blue);">arr1[${i}] = ${arr1[i]}</span> ≤ 
                            <span style="color: var(--mclaren-orange);">arr2[${j}] = ${arr2[j]}</span><br>
                            Add ${arr1[i]} to result
                        `;
                        i++;
                    } else {
                        result.push(arr2[j]);
                        stepDiv.innerHTML = `
                            <span style="color: var(--meta-blue);">arr1[${i}] = ${arr1[i]}</span> > 
                            <span style="color: var(--mclaren-orange);">arr2[${j}] = ${arr2[j]}</span><br>
                            Add ${arr2[j]} to result
                        `;
                        j++;
                    }
                    
                    stepsDiv.appendChild(stepDiv);
                    outputDiv.innerHTML = `Current result: [${result.join(', ')}]`;
                    
                    await new Promise(resolve => setTimeout(resolve, 800));
                }
                
                while (i < arr1.length) {
                    result.push(arr1[i]);
                    const stepDiv = document.createElement('div');
                    stepDiv.style.cssText = 'padding: 10px; margin-bottom: 10px; background: rgba(0,0,0,0.3); border-radius: 6px;';
                    stepDiv.innerHTML = `Add remaining arr1[${i}] = ${arr1[i]}`;
                    stepsDiv.appendChild(stepDiv);
                    outputDiv.innerHTML = `Current result: [${result.join(', ')}]`;
                    i++;
                    await new Promise(resolve => setTimeout(resolve, 600));
                }
                
                while (j < arr2.length) {
                    result.push(arr2[j]);
                    const stepDiv = document.createElement('div');
                    stepDiv.style.cssText = 'padding: 10px; margin-bottom: 10px; background: rgba(0,0,0,0.3); border-radius: 6px;';
                    stepDiv.innerHTML = `Add remaining arr2[${j}] = ${arr2[j]}`;
                    stepsDiv.appendChild(stepDiv);
                    outputDiv.innerHTML = `Current result: [${result.join(', ')}]`;
                    j++;
                    await new Promise(resolve => setTimeout(resolve, 600));
                }
                
                outputDiv.innerHTML = `<span style="color: #3fb950; font-weight: 600;">Final result: [${result.join(', ')}]</span>`;
                outputDiv.style.background = 'rgba(59, 185, 80, 0.2)';
            }
        };

        // Triangle Pattern Demo
        const triangleDemo = {
            generate() {
                const type = document.getElementById('triangle-type').value;
                const size = parseInt(document.getElementById('triangle-size').value) || 5;
                const patternDiv = document.getElementById('triangle-pattern');
                const formulaDiv = document.getElementById('triangle-formula');
                
                let pattern = '';
                let formula = '';
                
                if (type === 'left') {
                    for (let i = 1; i <= size; i++) {
                        pattern += '*'.repeat(i) + '\n';
                    }
                    formula = `For row i: print i stars<br>Total stars: 1+2+3+...+${size} = ${size * (size + 1) / 2}`;
                } else if (type === 'right') {
                    for (let i = 1; i <= size; i++) {
                        pattern += ' '.repeat(size - i) + '*'.repeat(i) + '\n';
                    }
                    formula = `For row i: print (${size}-i) spaces, then i stars`;
                } else if (type === 'inverted') {
                    for (let i = size; i >= 1; i--) {
                        pattern += '*'.repeat(i) + '\n';
                    }
                    formula = `For row i from ${size} to 1: print i stars`;
                } else if (type === 'number') {
                    for (let i = 1; i <= size; i++) {
                        pattern += Array.from({length: i}, (_, j) => j + 1).join(' ') + '\n';
                    }
                    formula = `For row i: print numbers 1 to i`;
                }
                
                patternDiv.textContent = pattern;
                formulaDiv.innerHTML = formula;
            }
        };

        // Diamond Pattern Demo
        const diamondDemo = {
            generate() {
                const type = document.getElementById('diamond-type').value;
                const size = parseInt(document.getElementById('diamond-size').value) || 4;
                const patternDiv = document.getElementById('diamond-pattern');
                
                let pattern = '';
                
                if (type === 'diamond') {
                    // Upper half
                    for (let i = 0; i < size; i++) {
                        pattern += ' '.repeat(size - i - 1) + '*'.repeat(2 * i + 1) + '\n';
                    }
                    // Lower half
                    for (let i = size - 2; i >= 0; i--) {
                        pattern += ' '.repeat(size - i - 1) + '*'.repeat(2 * i + 1) + '\n';
                    }
                } else if (type === 'pyramid') {
                    for (let i = 0; i < size; i++) {
                        pattern += ' '.repeat(size - i - 1) + '*'.repeat(2 * i + 1) + '\n';
                    }
                } else if (type === 'number-diamond') {
                    for (let i = 1; i <= size; i++) {
                        pattern += ' '.repeat(size - i);
                        for (let j = 1; j <= i; j++) pattern += j;
                        for (let j = i - 1; j >= 1; j--) pattern += j;
                        pattern += '\n';
                    }
                    for (let i = size - 1; i >= 1; i--) {
                        pattern += ' '.repeat(size - i);
                        for (let j = 1; j <= i; j++) pattern += j;
                        for (let j = i - 1; j >= 1; j--) pattern += j;
                        pattern += '\n';
                    }
                } else if (type === 'hollow-diamond') {
                    for (let i = 0; i < size; i++) {
                        pattern += ' '.repeat(size - i - 1);
                        if (i === 0) {
                            pattern += '*';
                        } else {
                            pattern += '*' + ' '.repeat(2 * i - 1) + '*';
                        }
                        pattern += '\n';
                    }
                    for (let i = size - 2; i >= 0; i--) {
                        pattern += ' '.repeat(size - i - 1);
                        if (i === 0) {
                            pattern += '*';
                        } else {
                            pattern += '*' + ' '.repeat(2 * i - 1) + '*';
                        }
                        pattern += '\n';
                    }
                }
                
                patternDiv.textContent = pattern;
            }
        };

        // Spiral Matrix Demo
        const spiralDemo = {
            generate() {
                const rows = parseInt(document.getElementById('spiral-rows').value) || 3;
                const cols = parseInt(document.getElementById('spiral-cols').value) || 4;
                const matrixDiv = document.getElementById('spiral-matrix');
                
                let num = 1;
                const matrix = Array(rows).fill(0).map(() => Array(cols).fill(0));
                
                let top = 0, bottom = rows - 1, left = 0, right = cols - 1;
                
                while (top <= bottom && left <= right) {
                    for (let col = left; col <= right; col++) matrix[top][col] = num++;
                    top++;
                    
                    for (let row = top; row <= bottom; row++) matrix[row][right] = num++;
                    right--;
                    
                    if (top <= bottom) {
                        for (let col = right; col >= left; col--) matrix[bottom][col] = num++;
                        bottom--;
                    }
                    
                    if (left <= right) {
                        for (let row = bottom; row >= top; row--) matrix[row][left] = num++;
                        left++;
                    }
                }
                
                matrixDiv.innerHTML = `
                    <table style="border-collapse: collapse; margin: 0 auto;">
                        ${matrix.map(row => `
                            <tr>
                                ${row.map(val => `
                                    <td style="padding: 12px; border: 1px solid var(--glass-border); text-align: center; min-width: 40px; background: rgba(0, 129, 251, 0.1); color: var(--meta-blue); font-weight: 600;">
                                        ${val}
                                    </td>
                                `).join('')}
                            </tr>
                        `).join('')}
                    </table>
                `;
                
                document.getElementById('spiral-result').textContent = `[${matrix.flat().join(', ')}]`;
            },

            async animate() {
                const rows = parseInt(document.getElementById('spiral-rows').value) || 3;
                const cols = parseInt(document.getElementById('spiral-cols').value) || 4;
                const matrixDiv = document.getElementById('spiral-matrix');
                const resultSpan = document.getElementById('spiral-result');
                const layerSpan = document.getElementById('spiral-layer');
                
                const matrix = Array(rows).fill(0).map(() => Array(cols).fill(0));
                const visited = Array(rows).fill(0).map(() => Array(cols).fill(false));
                
                let num = 1;
                let top = 0, bottom = rows - 1, left = 0, right = cols - 1;
                let layer = 0;
                const result = [];
                
                const renderMatrix = (highlightRow = -1, highlightCol = -1) => {
                    matrixDiv.innerHTML = `
                        <table style="border-collapse: collapse; margin: 0 auto;">
                            ${matrix.map((row, i) => `
                                <tr>
                                    ${row.map((val, j) => `
                                        <td style="padding: 12px; border: 1px solid var(--glass-border); text-align: center; min-width: 40px; 
                                            background: ${i === highlightRow && j === highlightCol ? 'rgba(255, 128, 0, 0.3)' : visited[i][j] ? 'rgba(59, 185, 80, 0.1)' : 'rgba(0, 129, 251, 0.05)'}; 
                                            color: ${i === highlightRow && j === highlightCol ? 'var(--mclaren-orange)' : visited[i][j] ? '#3fb950' : 'var(--text-dim)'}; 
                                            font-weight: 600;">
                                            ${val || '-'}
                                        </td>
                                    `).join('')}
                                </tr>
                            `).join('')}
                        </table>
                    `;
                };
                
                renderMatrix();
                
                while (top <= bottom && left <= right) {
                    layer++;
                    layerSpan.textContent = layer;
                    
                    for (let col = left; col <= right; col++) {
                        matrix[top][col] = num++;
                        visited[top][col] = true;
                        result.push(matrix[top][col]);
                        renderMatrix(top, col);
                        resultSpan.textContent = `[${result.join(', ')}]`;
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }
                    top++;
                    
                    for (let row = top; row <= bottom; row++) {
                        matrix[row][right] = num++;
                        visited[row][right] = true;
                        result.push(matrix[row][right]);
                        renderMatrix(row, right);
                        resultSpan.textContent = `[${result.join(', ')}]`;
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }
                    right--;
                    
                    if (top <= bottom) {
                        for (let col = right; col >= left; col--) {
                            matrix[bottom][col] = num++;
                            visited[bottom][col] = true;
                            result.push(matrix[bottom][col]);
                            renderMatrix(bottom, col);
                            resultSpan.textContent = `[${result.join(', ')}]`;
                            await new Promise(resolve => setTimeout(resolve, 300));
                        }
                        bottom--;
                    }
                    
                    if (left <= right) {
                        for (let row = bottom; row >= top; row--) {
                            matrix[row][left] = num++;
                            visited[row][left] = true;
                            result.push(matrix[row][left]);
                            renderMatrix(row, left);
                            resultSpan.textContent = `[${result.join(', ')}]`;
                            await new Promise(resolve => setTimeout(resolve, 300));
                        }
                        left++;
                    }
                }
            }
        };

        // Loop Fusion Demo
        const fusionDemo = {
            compare() {
                const size = parseInt(document.getElementById('fusion-size').value) || 1000;
                const arr = Array.from({length: size}, () => Math.floor(Math.random() * 100));
                
                const separateDiv = document.getElementById('fusion-separate');
                const fusedDiv = document.getElementById('fusion-fused');
                const resultDiv = document.getElementById('fusion-result');
                
                // Separate loops
                let separateOps = 0;
                let max1 = arr[0], min1 = arr[0], sum1 = 0;
                
                for (let i = 0; i < arr.length; i++) {
                    if (arr[i] > max1) max1 = arr[i];
                    separateOps++;
                }
                for (let i = 0; i < arr.length; i++) {
                    if (arr[i] < min1) min1 = arr[i];
                    separateOps++;
                }
                for (let i = 0; i < arr.length; i++) {
                    sum1 += arr[i];
                    separateOps++;
                }
                
                // Fused loop
                let fusedOps = 0;
                let max2 = arr[0], min2 = arr[0], sum2 = 0;
                
                for (let i = 0; i < arr.length; i++) {
                    if (arr[i] > max2) max2 = arr[i];
                    if (arr[i] < min2) min2 = arr[i];
                    sum2 += arr[i];
                    fusedOps++;
                }
                
                separateDiv.innerHTML = `
                    <div style="color: var(--text-muted); margin-bottom: 10px;">// Loop 1: Find max</div>
                    <div>for i in range(${size}):</div>
                    <div>&nbsp;&nbsp;if arr[i] > max_val: ...</div>
                    <div style="margin-top: 10px; color: var(--text-muted);">// Loop 2: Find min</div>
                    <div>for i in range(${size}):</div>
                    <div>&nbsp;&nbsp;if arr[i] < min_val: ...</div>
                    <div style="margin-top: 10px; color: var(--text-muted);">// Loop 3: Calculate sum</div>
                    <div>for i in range(${size}):</div>
                    <div>&nbsp;&nbsp;total += arr[i]</div>
                `;
                document.getElementById('fusion-separate-ops').textContent = separateOps;
                
                fusedDiv.innerHTML = `
                    <div style="color: var(--text-muted); margin-bottom: 10px;">// Single fused loop</div>
                    <div>for i in range(${size}):</div>
                    <div>&nbsp;&nbsp;if arr[i] > max_val: ...</div>
                    <div>&nbsp;&nbsp;if arr[i] < min_val: ...</div>
                    <div>&nbsp;&nbsp;total += arr[i]</div>
                    <div style="margin-top: 10px; color: #3fb950;">// All operations in one pass!</div>
                `;
                document.getElementById('fusion-fused-ops').textContent = fusedOps;
                
                const improvement = ((separateOps - fusedOps) / separateOps * 100).toFixed(1);
                resultDiv.innerHTML = `
                    <div style="font-size: 1.2rem;">Fused loop is <strong>${improvement}%</strong> more efficient!</div>
                    <div style="margin-top: 10px; color: var(--text-muted);">
                        Separate: ${separateOps} operations vs Fused: ${fusedOps} operations
                    </div>
                `;
            }
        };

        // Sieve Demo
        const sieveDemo = {
            generate() {
                const n = parseInt(document.getElementById('sieve-n').value) || 30;
                const gridDiv = document.getElementById('sieve-grid');
                const primesSpan = document.getElementById('sieve-primes');
                
                const isPrime = Array(n + 1).fill(true);
                isPrime[0] = isPrime[1] = false;
                
                let i = 2;
                while (i * i <= n) {
                    if (isPrime[i]) {
                        for (let j = i * i; j <= n; j += i) {
                            isPrime[j] = false;
                        }
                    }
                    i++;
                }
                
                const primes = [];
                gridDiv.innerHTML = '';
                for (let i = 0; i <= n; i++) {
                    const box = document.createElement('div');
                    box.style.cssText = `
                        width: 50px; height: 50px;
                        display: flex; align-items: center; justify-content: center;
                        border-radius: 8px; font-weight: 600;
                        background: ${isPrime[i] ? 'linear-gradient(135deg, #3fb950, #2ea043)' : 'rgba(220, 0, 0, 0.2)'};
                        color: ${isPrime[i] ? 'white' : 'var(--text-dim)'};
                        border: 1px solid ${isPrime[i] ? '#3fb950' : 'var(--redbull-red)'};
                    `;
                    box.textContent = i;
                    gridDiv.appendChild(box);
                    
                    if (isPrime[i]) primes.push(i);
                }
                
                primesSpan.textContent = `[${primes.join(', ')}]`;
                document.getElementById('sieve-current').textContent = `Found ${primes.length} primes`;
            },

            async animate() {
                const n = parseInt(document.getElementById('sieve-n').value) || 30;
                const gridDiv = document.getElementById('sieve-grid');
                const primesSpan = document.getElementById('sieve-primes');
                const currentSpan = document.getElementById('sieve-current');
                
                const isPrime = Array(n + 1).fill(true);
                isPrime[0] = isPrime[1] = false;
                
                const boxes = [];
                gridDiv.innerHTML = '';
                for (let i = 0; i <= n; i++) {
                    const box = document.createElement('div');
                    box.style.cssText = `
                        width: 50px; height: 50px;
                        display: flex; align-items: center; justify-content: center;
                        border-radius: 8px; font-weight: 600;
                        background: rgba(0, 129, 251, 0.1);
                        color: var(--text-primary);
                        border: 1px solid var(--glass-border);
                        transition: all 0.3s ease;
                    `;
                    box.textContent = i;
                    gridDiv.appendChild(box);
                    boxes.push(box);
                }
                
                boxes[0].style.background = 'rgba(220, 0, 0, 0.2)';
                boxes[0].style.borderColor = 'var(--redbull-red)';
                boxes[1].style.background = 'rgba(220, 0, 0, 0.2)';
                boxes[1].style.borderColor = 'var(--redbull-red)';
                
                let i = 2;
                const primes = [];
                
                while (i * i <= n) {
                    if (isPrime[i]) {
                        primes.push(i);
                        currentSpan.textContent = i;
                        boxes[i].style.background = 'linear-gradient(135deg, var(--mclaren-orange), var(--mclaren-dark))';
                        boxes[i].style.borderColor = 'var(--mclaren-orange)';
                        boxes[i].style.transform = 'scale(1.15)';
                        
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        for (let j = i * i; j <= n; j += i) {
                            if (isPrime[j]) {
                                isPrime[j] = false;
                                boxes[j].style.background = 'rgba(220, 0, 0, 0.2)';
                                boxes[j].style.borderColor = 'var(--redbull-red)';
                                boxes[j].style.color = 'var(--text-dim)';
                                await new Promise(resolve => setTimeout(resolve, 100));
                            }
                        }
                        
                        boxes[i].style.background = 'linear-gradient(135deg, #3fb950, #2ea043)';
                        boxes[i].style.borderColor = '#3fb950';
                        boxes[i].style.transform = 'scale(1)';
                    }
                    i++;
                }
                
                for (let i = Math.floor(Math.sqrt(n)) + 1; i <= n; i++) {
                    if (isPrime[i]) {
                        primes.push(i);
                        boxes[i].style.background = 'linear-gradient(135deg, #3fb950, #2ea043)';
                        boxes[i].style.borderColor = '#3fb950';
                    }
                }
                
                primesSpan.textContent = `[${primes.join(', ')}]`;
                currentSpan.textContent = `Complete! Found ${primes.length} primes`;
            }
        };

        // Fast Power Demo
        const powerDemo = {
            calculate() {
                const base = parseInt(document.getElementById('power-base').value) || 3;
                const exp = parseInt(document.getElementById('power-exp').value) || 13;
                const stepsDiv = document.getElementById('power-steps');
                const answerSpan = document.getElementById('power-answer');
                const iterSpan = document.getElementById('power-iterations');
                
                let result = 1;
                let b = base;
                let e = exp;
                let steps = `<div style="color: var(--meta-blue); font-weight: 600; margin-bottom: 15px;">
                    Computing ${base}^${exp} using binary exponentiation
                </div>`;
                steps += `<div style="margin-bottom: 15px; padding: 12px; background: rgba(0, 129, 251, 0.1); border-radius: 6px;">
                    Binary of ${exp}: ${exp.toString(2)}<br>
                    We'll process each bit from right to left
                </div>`;
                
                let iteration = 0;
                while (e > 0) {
                    iteration++;
                    const isOdd = e % 2 === 1;
                    const oldResult = result;
                    const oldBase = b;
                    
                    if (isOdd) result *= b;
                    
                    steps += `<div style="margin-bottom: 12px; padding: 12px; background: ${isOdd ? 'rgba(255, 128, 0, 0.1)' : 'rgba(0,0,0,0.3)'}; border-left: 3px solid ${isOdd ? 'var(--mclaren-orange)' : 'var(--glass-border)'}; border-radius: 4px;">
                        <strong>Iteration ${iteration}:</strong> exp=${e} (${e.toString(2)}₂) is ${isOdd ? 'odd' : 'even'}<br>
                        ${isOdd ? `result = ${oldResult} × ${oldBase} = <span style="color: var(--mclaren-orange); font-weight: 600;">${result}</span><br>` : `result = ${result} (no change)<br>`}
                        base = ${oldBase}² = ${b * b}<br>
                        exp = ${e} // 2 = ${Math.floor(e / 2)}
                    </div>`;
                    
                    b *= b;
                    e = Math.floor(e / 2);
                }
                
                stepsDiv.innerHTML = steps;
                answerSpan.textContent = result;
                iterSpan.textContent = iteration;
            },

            async stepThrough() {
                const base = parseInt(document.getElementById('power-base').value) || 3;
                const exp = parseInt(document.getElementById('power-exp').value) || 13;
                const stepsDiv = document.getElementById('power-steps');
                const answerSpan = document.getElementById('power-answer');
                const iterSpan = document.getElementById('power-iterations');
                
                let result = 1;
                let b = base;
                let e = exp;
                
                stepsDiv.innerHTML = `<div style="color: var(--meta-blue); font-weight: 600; margin-bottom: 15px;">
                    Computing ${base}^${exp} step by step...
                </div>`;
                
                let iteration = 0;
                while (e > 0) {
                    iteration++;
                    const isOdd = e % 2 === 1;
                    const oldResult = result;
                    const oldBase = b;
                    
                    if (isOdd) result *= b;
                    
                    const stepDiv = document.createElement('div');
                    stepDiv.style.cssText = `margin-bottom: 12px; padding: 12px; background: rgba(255, 128, 0, 0.2); border-left: 3px solid var(--mclaren-orange); border-radius: 4px; animation: fadeIn 0.5s;`;
                    stepDiv.innerHTML = `
                        <strong style="color: var(--mclaren-orange);">Step ${iteration}:</strong> exp=${e} (${e.toString(2)}₂)<br>
                        ${isOdd ? `Odd! result = ${oldResult} × ${oldBase} = <strong>${result}</strong><br>` : 'Even, skip multiplication<br>'}
                        base = ${oldBase}² = ${b * b}, exp = ${Math.floor(e / 2)}
                    `;
                    stepsDiv.appendChild(stepDiv);
                    
                    answerSpan.textContent = result;
                    iterSpan.textContent = iteration;
                    
                    await new Promise(resolve => setTimeout(resolve, 1200));
                    
                    b *= b;
                    e = Math.floor(e / 2);
                }
                
                answerSpan.style.color = '#3fb950';
            }
        };

        // Bracket Validator Demo
        const bracketDemo = {
            validate() {
                const expr = document.getElementById('bracket-expr').value;
                const vizDiv = document.getElementById('bracket-visualization');
                const resultDiv = document.getElementById('bracket-result');
                
                let depth = 0;
                let steps = '';
                let isValid = true;
                
                for (let i = 0; i < expr.length; i++) {
                    const char = expr[i];
                    const oldDepth = depth;
                    
                    if (char === '(') {
                        depth++;
                        steps += `<div style="padding: 10px; margin-bottom: 8px; background: rgba(0, 129, 251, 0.1); border-left: 3px solid var(--meta-blue); border-radius: 4px;">
                            char[${i}] = '(' → depth: ${oldDepth} → <span style="color: var(--meta-blue); font-weight: 600;">${depth}</span>
                        </div>`;
                    } else if (char === ')') {
                        depth--;
                        if (depth < 0) {
                            isValid = false;
                            steps += `<div style="padding: 10px; margin-bottom: 8px; background: rgba(220, 0, 0, 0.2); border-left: 3px solid var(--redbull-red); border-radius: 4px;">
                                char[${i}] = ')' → depth: ${oldDepth} → <span style="color: var(--redbull-red); font-weight: 600;">${depth}</span><br>
                                <strong>ERROR: More ')' than '('</strong>
                            </div>`;
                            break;
                        }
                        steps += `<div style="padding: 10px; margin-bottom: 8px; background: rgba(255, 128, 0, 0.1); border-left: 3px solid var(--mclaren-orange); border-radius: 4px;">
                            char[${i}] = ')' → depth: ${oldDepth} → <span style="color: var(--mclaren-orange); font-weight: 600;">${depth}</span>
                        </div>`;
                    }
                }
                
                vizDiv.innerHTML = steps;
                
                if (!isValid || depth !== 0) {
                    resultDiv.innerHTML = '❌ INVALID';
                    resultDiv.style.background = 'rgba(220, 0, 0, 0.2)';
                    resultDiv.style.border = '1px solid var(--redbull-red)';
                    resultDiv.style.color = 'var(--redbull-red)';
                } else {
                    resultDiv.innerHTML = '✓ VALID';
                    resultDiv.style.background = 'rgba(59, 185, 80, 0.2)';
                    resultDiv.style.border = '1px solid #3fb950';
                    resultDiv.style.color = '#3fb950';
                }
            },

            async stepThrough() {
                const expr = document.getElementById('bracket-expr').value;
                const vizDiv = document.getElementById('bracket-visualization');
                const resultDiv = document.getElementById('bracket-result');
                
                vizDiv.innerHTML = '';
                resultDiv.innerHTML = 'Processing...';
                resultDiv.style.background = 'rgba(0, 129, 251, 0.1)';
                resultDiv.style.border = '1px solid var(--meta-blue)';
                resultDiv.style.color = 'var(--meta-blue)';
                
                let depth = 0;
                let isValid = true;
                
                for (let i = 0; i < expr.length; i++) {
                    const char = expr[i];
                    const oldDepth = depth;
                    
                    if (char === '(' || char === ')') {
                        if (char === '(') depth++;
                        else depth--;
                        
                        if (depth < 0) {
                            isValid = false;
                        }
                        
                        const stepDiv = document.createElement('div');
                        stepDiv.style.cssText = `padding: 10px; margin-bottom: 8px; background: rgba(255, 128, 0, 0.2); border-left: 3px solid var(--mclaren-orange); border-radius: 4px; animation: fadeIn 0.5s;`;
                        stepDiv.innerHTML = `
                            char[${i}] = '${char}' → depth: ${oldDepth} → <strong style="color: var(--mclaren-orange);">${depth}</strong>
                            ${depth < 0 ? '<br><span style="color: var(--redbull-red);">ERROR!</span>' : ''}
                        `;
                        vizDiv.appendChild(stepDiv);
                        
                        await new Promise(resolve => setTimeout(resolve, 600));
                        
                        if (!isValid) break;
                    }
                }
                
                if (!isValid || depth !== 0) {
                    resultDiv.innerHTML = '❌ INVALID' + (depth !== 0 ? ` (final depth: ${depth})` : '');
                    resultDiv.style.background = 'rgba(220, 0, 0, 0.2)';
                    resultDiv.style.border = '1px solid var(--redbull-red)';
                    resultDiv.style.color = 'var(--redbull-red)';
                } else {
                    resultDiv.innerHTML = '✓ VALID (depth = 0)';
                    resultDiv.style.background = 'rgba(59, 185, 80, 0.2)';
                    resultDiv.style.border = '1px solid #3fb950';
                    resultDiv.style.color = '#3fb950';
                }
            }
        };

        // RLE Demo
        const rleDemo = {
            encode() {
                const input = document.getElementById('rle-input').value;
                const stepsDiv = document.getElementById('rle-steps');
                const originalSpan = document.getElementById('rle-original');
                const encodedSpan = document.getElementById('rle-encoded');
                const compressionSpan = document.getElementById('rle-compression');
                
                if (!input) return;
                
                const result = [];
                let currentChar = input[0];
                let count = 1;
                let steps = `<div style="margin-bottom: 15px; color: var(--meta-blue); font-weight: 600;">
                    Encoding "${input}"...
                </div>`;
                
                for (let i = 1; i < input.length; i++) {
                    if (input[i] === currentChar) {
                        count++;
                        steps += `<div style="padding: 8px; margin-bottom: 6px; background: rgba(0,0,0,0.3); border-left: 2px solid var(--glass-border); border-radius: 4px;">
                            i=${i}: '${input[i]}' == '${currentChar}' → count = ${count}
                        </div>`;
                    } else {
                        const encoded = currentChar + count;
                        result.push(encoded);
                        steps += `<div style="padding: 8px; margin-bottom: 6px; background: rgba(255, 128, 0, 0.1); border-left: 3px solid var(--mclaren-orange); border-radius: 4px;">
                            i=${i}: '${input[i]}' != '${currentChar}' → append <span style="color: var(--mclaren-orange); font-weight: 600;">'${encoded}'</span><br>
                            Reset: current='${input[i]}', count=1
                        </div>`;
                        currentChar = input[i];
                        count = 1;
                    }
                }
                
                const lastEncoded = currentChar + count;
                result.push(lastEncoded);
                steps += `<div style="padding: 8px; margin-bottom: 6px; background: rgba(59, 185, 80, 0.1); border-left: 3px solid #3fb950; border-radius: 4px;">
                    End: append final group <span style="color: #3fb950; font-weight: 600;">'${lastEncoded}'</span>
                </div>`;
                
                const encoded = result.join('');
                stepsDiv.innerHTML = steps;
                originalSpan.textContent = input;
                encodedSpan.textContent = encoded;
                
                const ratio = ((1 - encoded.length / input.length) * 100).toFixed(1);
                compressionSpan.textContent = `${ratio}% (${input.length} → ${encoded.length} chars)`;
            },

            async animate() {
                const input = document.getElementById('rle-input').value;
                const stepsDiv = document.getElementById('rle-steps');
                const originalSpan = document.getElementById('rle-original');
                const encodedSpan = document.getElementById('rle-encoded');
                const compressionSpan = document.getElementById('rle-compression');
                
                if (!input) return;
                
                stepsDiv.innerHTML = '<div style="color: var(--meta-blue); font-weight: 600; margin-bottom: 15px;">Animating...</div>';
                
                const result = [];
                let currentChar = input[0];
                let count = 1;
                
                for (let i = 1; i < input.length; i++) {
                    if (input[i] === currentChar) {
                        count++;
                        const stepDiv = document.createElement('div');
                        stepDiv.style.cssText = 'padding: 8px; margin-bottom: 6px; background: rgba(0, 129, 251, 0.1); border-left: 2px solid var(--meta-blue); border-radius: 4px; animation: fadeIn 0.5s;';
                        stepDiv.innerHTML = `'${input[i]}' == '${currentChar}' → count = <strong>${count}</strong>`;
                        stepsDiv.appendChild(stepDiv);
                    } else {
                        const encoded = currentChar + count;
                        result.push(encoded);
                        const stepDiv = document.createElement('div');
                        stepDiv.style.cssText = 'padding: 8px; margin-bottom: 6px; background: rgba(255, 128, 0, 0.2); border-left: 3px solid var(--mclaren-orange); border-radius: 4px; animation: fadeIn 0.5s;';
                        stepDiv.innerHTML = `'${input[i]}' != '${currentChar}' → append <strong style="color: var(--mclaren-orange);">'${encoded}'</strong>`;
                        stepsDiv.appendChild(stepDiv);
                        encodedSpan.textContent = result.join('');
                        currentChar = input[i];
                        count = 1;
                    }
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
                const lastEncoded = currentChar + count;
                result.push(lastEncoded);
                const stepDiv = document.createElement('div');
                stepDiv.style.cssText = 'padding: 8px; background: rgba(59, 185, 80, 0.2); border-left: 3px solid #3fb950; border-radius: 4px; animation: fadeIn 0.5s;';
                stepDiv.innerHTML = `End → append <strong style="color: #3fb950;">'${lastEncoded}'</strong>`;
                stepsDiv.appendChild(stepDiv);
                
                const encoded = result.join('');
                originalSpan.textContent = input;
                encodedSpan.textContent = encoded;
                
                const ratio = ((1 - encoded.length / input.length) * 100).toFixed(1);
                compressionSpan.textContent = `${ratio}% (${input.length} → ${encoded.length} chars)`;
            }
        };

        // Sliding Window Demo
        const windowDemo = {
            async animate() {
                const s = document.getElementById('window-string').value;
                const k = parseInt(document.getElementById('window-k').value) || 2;
                const vizDiv = document.getElementById('window-visual');
                const currentSpan = document.getElementById('window-current');
                const distinctSpan = document.getElementById('window-distinct');
                const maxSpan = document.getElementById('window-max');
                
                const charCount = {};
                let left = 0;
                let maxLength = 0;
                
                vizDiv.innerHTML = `<div style="font-family: 'Courier New', monospace; font-size: 18px; margin-bottom: 20px; text-align: center;">
                    ${s.split('').map((c, i) => `<span id="char-${i}" style="display: inline-block; padding: 8px; margin: 2px; border-radius: 4px; background: rgba(255,255,255,0.05);">${c}</span>`).join('')}
                </div>
                <div id="window-steps" style="max-height: 200px; overflow-y: auto;"></div>`;
                
                const stepsDiv = document.getElementById('window-steps');
                
                for (let right = 0; right < s.length; right++) {
                    const char = s[right];
                    charCount[char] = (charCount[char] || 0) + 1;
                    
                    // Highlight current window
                    for (let i = 0; i < s.length; i++) {
                        const elem = document.getElementById(`char-${i}`);
                        if (i >= left && i <= right) {
                            elem.style.background = i === right ? 'rgba(255, 128, 0, 0.3)' : 'rgba(0, 129, 251, 0.2)';
                            elem.style.borderLeft = i === left ? '3px solid var(--meta-blue)' : '';
                            elem.style.borderRight = i === right ? '3px solid var(--mclaren-orange)' : '';
                        } else {
                            elem.style.background = 'rgba(255,255,255,0.05)';
                            elem.style.borderLeft = '';
                            elem.style.borderRight = '';
                        }
                    }
                    
                    currentSpan.textContent = s.substring(left, right + 1);
                    distinctSpan.textContent = Object.keys(charCount).length;
                    
                    const stepDiv = document.createElement('div');
                    stepDiv.style.cssText = 'padding: 8px; margin-bottom: 6px; background: rgba(0, 129, 251, 0.1); border-left: 2px solid var(--meta-blue); border-radius: 4px;';
                    stepDiv.innerHTML = `Expand right=${right}, char='${char}', distinct=${Object.keys(charCount).length}`;
                    stepsDiv.appendChild(stepDiv);
                    
                    await new Promise(resolve => setTimeout(resolve, 800));
                    
                    while (Object.keys(charCount).length > k) {
                        const leftChar = s[left];
                        charCount[leftChar]--;
                        if (charCount[leftChar] === 0) delete charCount[leftChar];
                        
                        const shrinkDiv = document.createElement('div');
                        shrinkDiv.style.cssText = 'padding: 8px; margin-bottom: 6px; background: rgba(220, 0, 0, 0.1); border-left: 2px solid var(--redbull-red); border-radius: 4px;';
                        shrinkDiv.innerHTML = `Shrink left=${left}, remove '${leftChar}', distinct=${Object.keys(charCount).length}`;
                        stepsDiv.appendChild(shrinkDiv);
                        
                        left++;
                        currentSpan.textContent = s.substring(left, right + 1);
                        distinctSpan.textContent = Object.keys(charCount).length;
                        
                        // Update highlight
                        for (let i = 0; i < s.length; i++) {
                            const elem = document.getElementById(`char-${i}`);
                            if (i >= left && i <= right) {
                                elem.style.background = i === right ? 'rgba(255, 128, 0, 0.3)' : 'rgba(0, 129, 251, 0.2)';
                                elem.style.borderLeft = i === left ? '3px solid var(--meta-blue)' : '';
                            } else {
                                elem.style.background = 'rgba(255,255,255,0.05)';
                                elem.style.borderLeft = '';
                            }
                        }
                        
                        await new Promise(resolve => setTimeout(resolve, 600));
                    }
                    
                    const currentLength = right - left + 1;
                    if (currentLength > maxLength) {
                        maxLength = currentLength;
                        maxSpan.textContent = maxLength;
                    }
                    
                    stepsDiv.scrollTop = stepsDiv.scrollHeight;
                }
                
                const finalDiv = document.createElement('div');
                finalDiv.style.cssText = 'padding: 12px; margin-top: 10px; background: rgba(59, 185, 80, 0.2); border-left: 3px solid #3fb950; border-radius: 4px; font-weight: 600;';
                finalDiv.innerHTML = `Complete! Max length: ${maxLength}`;
                stepsDiv.appendChild(finalDiv);
            }
        };

        // Initialize animations
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeIn {
                from { opacity: 0; transform: translateY(20px); }
                to { opacity: 1; transform: translateY(0); }
            }
            @keyframes fadeInUp {
                from { opacity: 0; transform: translateY(30px); }
                to { opacity: 1; transform: translateY(0); }
            }
        `;
        document.head.appendChild(style);

        // Initialize everything on page load
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Initializing page...');
            
            // Apply syntax highlighting
            setTimeout(() => {
                applySyntaxHighlighting();
                console.log('Syntax highlighting applied');
            }, 100);
            
            // Make all sections visible immediately for better UX
            setTimeout(() => {
                document.querySelectorAll('.section').forEach(section => {
                    section.classList.add('visible');
                });
                console.log('All sections made visible');
            }, 200);
        });
    </script>
</body>
</html>