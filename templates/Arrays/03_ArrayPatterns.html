BASIC MANIPULATION - GUIDED PRACTICE WITH DEEP THEORY
=========================================================

 SESSION STRUCTURE

    \[0-25 min\] Core Operations Mastery (5 problems)
    \[25-50 min\] Two Pointer Fundamentals (5 problems)
    \[50-75 min\] Array Transformations (6 problems)
    \[75-90 min\] Frequency & Counting Patterns (4 problems)

  

\[MINUTE 0-25\] CORE OPERATIONS MASTERY
-------------------------------------------

 THEORETICAL FOUNDATION: Why We Start Here

Before solving complex problems, you must master the atomic operations - the building blocks. Every advanced algorithm uses these primitives.

The 5 Core Operations:

1.  Reverse - Foundation for rotation, palindrome checks
2.  Find Max/Min - Basis for optimization problems
3.  Linear Search - Understanding sequential access
4.  Insert - In-place modification patterns
5.  Delete - Memory compaction understanding

  

 PROBLEM 1: REVERSE ARRAY IN-PLACE

 Problem Statement:

    Given an array, reverse it in-place (without using extra array).
    
    Input: [1, 2, 3, 4, 5]
    Output: [5, 4, 3, 2, 1]
    
    Constraint: O(1) extra space
    

 DEEP THEORETICAL ANALYSIS

Why "In-Place" Matters:

Arrays in memory are contiguous. When you create a new array, you're:

1.  Asking OS for new memory block
2.  Copying all elements (O(n) time)
3.  Using O(n) extra space
4.  Creating garbage (old array must be collected)

In-place reversal avoids all this.

The Insight - Symmetry:

    Original: [1, 2, 3, 4, 5]
               ↓           ↓
    Target:   [5, 4, 3, 2, 1]
    
    Notice: 
    - arr[0] should become arr[4]
    - arr[1] should become arr[3]
    - arr[2] stays at arr[2] (middle element)
    - arr[3] should become arr[1]
    - arr[4] should become arr[0]
    
    Pattern: arr[i] ↔ arr[n-1-i]
    
    We can swap pairs from outside toward center!
    

Visual Representation:

    Step 0: [1, 2, 3, 4, 5]
             ↑           ↑
            left       right
    
    Step 1: Swap arr[0] ↔ arr[4]
            [5, 2, 3, 4, 1]
                ↑     ↑
               left  right
    
    Step 2: Swap arr[1] ↔ arr[3]
            [5, 4, 3, 2, 1]
                   ↑
              left=right (stop)
    
    Total swaps: n/2 = O(n) time
    

  

 METHOD 1: Two Pointers (Opposite Ends)

The Template:

    def reversetwopointers(arr):
        left = 0
        right = len(arr) - 1
        
        while left < right:
             Swap elements at left and right
            arr[left], arr[right] = arr[right], arr[left]
            
             Move pointers toward center
            left += 1
            right -= 1
    

Complete Trace:

    arr = [1, 2, 3, 4, 5]
    
    Iteration 1:
      left=0, right=4
      Swap arr[0]=1 with arr[4]=5
      arr = [5, 2, 3, 4, 1]
      left=1, right=3
    
    Iteration 2:
      left=1, right=3
      Swap arr[1]=2 with arr[3]=4
      arr = [5, 4, 3, 2, 1]
      left=2, right=2
    
    Iteration 3:
      left=2, right=2
      left NOT < right, STOP
    
    Final: [5, 4, 3, 2, 1] ✓
    

Why This Works:

   Each iteration swaps one pair of symmetric elements
   Pointers converge, covering all pairs exactly once
   Stops at middle (no redundant swaps)

Edge Cases:

     Empty array
    arr = []
     left=0, right=-1
     left NOT < right immediately, no swaps
     Result: [] ✓
    
     Single element
    arr = [1]
     left=0, right=0
     left NOT < right, no swaps
     Result: [1] ✓
    
     Two elements
    arr = [1, 2]
     left=0, right=1
     Swap: [2, 1]
     left=1, right=0, stop
     Result: [2, 1] ✓
    
     Even length
    arr = [1, 2, 3, 4]
     Swaps: (0,3), (1,2)
     Result: [4, 3, 2, 1] ✓
    
     Odd length
    arr = [1, 2, 3, 4, 5]
     Swaps: (0,4), (1,3)
     Middle element (2) untouched
     Result: [5, 4, 3, 2, 1] ✓
    

Time Complexity: O(n/2) = O(n)  
Space Complexity: O(1)

  

 METHOD 2: Using Index Formula

Alternative approach:

    def reverseindexformula(arr):
        n = len(arr)
        
         Only need to swap first half
        for i in range(n // 2):
             Calculate symmetric index
            j = n - 1 - i
            
             Swap
            arr[i], arr[j] = arr[j], arr[i]
    

Why n // 2?

    For n=5: range(2) → i = 0, 1
      i=0: swap arr[0] ↔ arr[4]
      i=1: swap arr[1] ↔ arr[3]
      i=2 would swap arr[2] ↔ arr[2] (redundant!)
    
    For n=6: range(3) → i = 0, 1, 2
      i=0: swap arr[0] ↔ arr[5]
      i=1: swap arr[1] ↔ arr[4]
      i=2: swap arr[2] ↔ arr[3]
      All pairs covered exactly once!
    

  

 METHOD 3: Pythonic Slicing (NOT In-Place!)

    def reverseslicing(arr):
        return arr[::-1]   Creates NEW array!
    
     This is O(n) space, violates constraint
     But useful to know for when space doesn't matter
    

What [::-1] Actually Does:

    Step 1: Python creates new array of same size
    Step 2: Iterates backward through original
    Step 3: Copies each element to new array
    
    arr = [1, 2, 3, 4, 5]
    
    newarr[0] = arr[4]  → 5
    newarr[1] = arr[3]  → 4
    newarr[2] = arr[2]  → 3
    newarr[3] = arr[1]  → 2
    newarr[4] = arr[0]  → 1
    
    Returns newarr = [5, 4, 3, 2, 1]
    
    Original arr unchanged!
    

  

 Common Mistakes:

Mistake 1: Swapping All Elements

     WRONG!
    def reversewrong(arr):
        n = len(arr)
        for i in range(n):   Should be n//2!
            arr[i], arr[n-1-i] = arr[n-1-i], arr[i]
    
     What happens:
     arr = [1, 2, 3]
     i=0: swap arr[0]↔arr[2] → [3, 2, 1]
     i=1: arr[1]↔arr[1] → [3, 2, 1] (no change)
     i=2: swap arr[2]↔arr[0] → [1, 2, 3] (reverses back!)
     Result: [1, 2, 3] (unchanged!)
    

Mistake 2: Off-by-One Errors

     WRONG!
    def reversewrong2(arr):
        left = 0
        right = len(arr)   Should be len(arr) - 1!
        
        while left < right:
            arr[left], arr[right] = arr[right], arr[left]
             IndexError: arr[right] out of bounds!
    

  

 PRACTICE PROBLEM 1A: Reverse Subarray

Problem:

    Reverse elements from index left to right (inclusive).
    
    Input: arr = [1, 2, 3, 4, 5], left = 1, right = 3
    Output: [1, 4, 3, 2, 5]
           (only [2,3,4] reversed to [4,3,2])
    

Solution:

    def reversesubarray(arr, left, right):
        while left < right:
            arr[left], arr[right] = arr[right], arr[left]
            left += 1
            right -= 1
    
     Same logic, different boundaries!
    

  

 PROBLEM 2: FIND MAXIMUM AND MINIMUM

 THEORETICAL FOUNDATION

The Fundamental Question: How do you find the largest/smallest element?

Naive Thought: "Check every possible pair and compare."

   This would be O(n²)!

Key Insight: You only need ONE pass!

Why?

    Think about how YOU find the tallest person in a room:
    1. Remember the first person's height
    2. Compare each next person with your memory
    3. Update memory if you find someone taller
    
    This is exactly what the algorithm does!
    

The Invariant (Mathematical Guarantee):

    After processing i elements:
    maxsofar = maximum of arr[0...i]
    
    Proof by induction:
    Base case: After 1 element, maxsofar = arr[0] ✓
    Inductive step: If maxsofar is max of arr[0...i],
                    then max(maxsofar, arr[i+1]) is max of arr[0...i+1] ✓
    
    Therefore: After n elements, maxsofar = maximum of entire array ✓
    

  

 SOLUTION 1: Sequential Scan

    def findmaxmin(arr):
        if not arr:
            return None, None
        
        maxval = arr[0]   Assume first is largest
        minval = arr[0]   Assume first is smallest
        
         Check all other elements
        for i in range(1, len(arr)):
            if arr[i] > maxval:
                maxval = arr[i]
            if arr[i] < minval:
                minval = arr[i]
        
        return maxval, minval
    

Detailed Trace:

    arr = [3, 7, 1, 9, 2]
    
    Initial: maxval=3, minval=3
    
    i=1: arr[1]=7
      7 > 3? YES → maxval=7
      7 < 3? NO → minval=3
      State: max=7, min=3
    
    i=2: arr[2]=1
      1 > 7? NO → maxval=7
      1 < 3? YES → minval=1
      State: max=7, min=1
    
    i=3: arr[3]=9
      9 > 7? YES → maxval=9
      9 < 1? NO → minval=1
      State: max=9, min=1
    
    i=4: arr[4]=2
      2 > 9? NO → maxval=9
      2 < 1? NO → minval=1
      State: max=9, min=1
    
    Return: (9, 1) ✓
    

Comparison Count:

   n-1 elements checked
   2 comparisons per element
   Total: 2(n-1) comparisons

  

 SOLUTION 2: Optimized (Pairwise Comparison)

Theoretical Insight:

Instead of comparing each element with both max and min separately, we can:

1.  Compare pairs of elements with each other
2.  Compare smaller one with min, larger one with max
3.  Reduces comparisons from 2n to 1.5n!

    def findmaxminoptimized(arr):
        if not arr:
            return None, None
        
        n = len(arr)
        
         Initialize based on first element(s)
        if n % 2 == 0:
             Even: compare first two
            if arr[0] > arr[1]:
                maxval = arr[0]
                minval = arr[1]
            else:
                maxval = arr[1]
                minval = arr[0]
            start = 2
        else:
             Odd: first element is both max and min initially
            maxval = minval = arr[0]
            start = 1
        
         Process remaining pairs
        for i in range(start, n-1, 2):
             Compare pair elements first
            if arr[i] > arr[i+1]:
                small = arr[i+1]
                large = arr[i]
            else:
                small = arr[i]
                large = arr[i+1]
            
             Update max and min
            if large > maxval:
                maxval = large
            if small < minval:
                minval = small
        
        return maxval, minval
    

Comparison Count:

    For n=8 (even):
    - Initial comparison: 1
    - Pairs: (8-2)/2 = 3 pairs
    - Per pair: 3 comparisons (pair + max + min)
    - Total: 1 + 3×3 = 10 comparisons
    
    Naive method: 2×7 = 14 comparisons
    Savings: 28.5%!
    

Why This is Better:

    Naive approach for arr[i]:
      Compare with max: 1 comparison
      Compare with min: 1 comparison
      Total: 2 comparisons per element
    
    Pairwise approach for arr[i] and arr[i+1]:
      Compare arr[i] with arr[i+1]: 1 comparison
      Compare larger with max: 1 comparison
      Compare smaller with min: 1 comparison
      Total: 3 comparisons for 2 elements = 1.5 per element
    

  

 Edge Cases:

     Empty array
    findmaxmin([])   Returns (None, None)
    
     Single element
    findmaxmin([5])   Returns (5, 5)
    
     All same elements
    findmaxmin([3, 3, 3, 3])   Returns (3, 3)
    
     Two elements
    findmaxmin([1, 2])   Returns (2, 1)
    findmaxmin([2, 1])   Returns (2, 1)
    
     Negative numbers
    findmaxmin([-5, -1, -10])   Returns (-1, -10)
    
     Mixed positive/negative
    findmaxmin([-5, 3, -1, 7])   Returns (7, -5)
    

  

 PROBLEM 3: LINEAR SEARCH WITH ALL EDGE CASES

 THEORETICAL FOUNDATION

Linear search is the most basic search algorithm. Understanding it deeply teaches you:

1.  Sequential access patterns
2.  Early termination optimization
3.  Multiple-result handling
4.  Edge case management

The Algorithm:

    For each element in array:
        If element matches target:
            Found!
        Continue to next
    If loop completes:
        Not found
    

Time Complexity Analysis:

    Best Case: O(1)
      Target is first element
      arr = [5, 2, 8, 1], target = 5
      Check arr[0]: 5 == 5 → Found immediately!
    
    Worst Case: O(n)
      Target is last element OR not in array
      arr = [5, 2, 8, 1], target = 1
      Check all n elements
    
    Average Case: O(n/2) = O(n)
      On average, target is in the middle
      Expected comparisons: n/2
    

  

 VERSION 1: Find First Occurrence

    def linearsearch(arr, target):
        """
        Returns index of first occurrence of target.
        Returns -1 if not found.
        """
        for i in range(len(arr)):
            if arr[i] == target:
                return i   Early termination!
        return -1
    

Trace:

    arr = [3, 7, 1, 7, 2], target = 7
    
    i=0: arr[0]=3, 3==7? NO
    i=1: arr[1]=7, 7==7? YES → return 1
    
    Note: arr[3] is also 7, but we stop at first occurrence
    

  

 VERSION 2: Find All Occurrences

Theoretical Change:

Can't use early termination! Must check ALL elements.

    def linearsearchall(arr, target):
        """
        Returns list of ALL indices where target appears.
        Returns empty list if not found.
        """
        indices = []
        
        for i in range(len(arr)):
            if arr[i] == target:
                indices.append(i)   Collect, don't return!
        
        return indices
    

Trace:

    arr = [3, 7, 1, 7, 2], target = 7
    
    i=0: arr[0]=3, 3==7? NO
    i=1: arr[1]=7, 7==7? YES → indices=[1]
    i=2: arr[2]=1, 1==7? NO
    i=3: arr[3]=7, 7==7? YES → indices=[1, 3]
    i=4: arr[4]=2, 2==7? NO
    
    Return: [1, 3]
    

Time Complexity: Always O(n) (must check all elements)

  

 VERSION 3: Count Occurrences

    def countoccurrences(arr, target):
        """
        Returns count of how many times target appears.
        """
        count = 0
        
        for num in arr:
            if num == target:
                count += 1
        
        return count
    

Optimization Insight:

     If array is SORTED, we can optimize!
    def countoccurrencessorted(arr, target):
        """
        For sorted array, use binary search to find range.
        """
        def findfirst(arr, target):
             Binary search for first occurrence
            left, right = 0, len(arr) - 1
            result = -1
            
            while left <= right:
                mid = (left + right) // 2
                if arr[mid] == target:
                    result = mid
                    right = mid - 1   Keep searching left
                elif arr[mid] < target:
                    left = mid + 1
                else:
                    right = mid - 1
            
            return result
        
        def findlast(arr, target):
             Binary search for last occurrence
            left, right = 0, len(arr) - 1
            result = -1
            
            while left <= right:
                mid = (left + right) // 2
                if arr[mid] == target:
                    result = mid
                    left = mid + 1   Keep searching right
                elif arr[mid] < target:
                    left = mid + 1
                else:
                    right = mid - 1
            
            return result
        
        first = findfirst(arr, target)
        if first == -1:
            return 0
        
        last = findlast(arr, target)
        return last - first + 1
    
     Time: O(log n) instead of O(n)!
    

  

 Edge Cases to Handle:

     1. Empty array
    linearsearch([], 5)   Returns -1
    
     2. Target not in array
    linearsearch([1, 2, 3], 5)   Returns -1
    
     3. Single element (match)
    linearsearch([5], 5)   Returns 0
    
     4. Single element (no match)
    linearsearch([3], 5)   Returns -1
    
     5. All elements same
    linearsearch([7, 7, 7], 7)   Returns 0 (first)
    linearsearchall([7, 7, 7], 7)   Returns [0, 1, 2]
    
     6. Duplicates
    linearsearch([1, 2, 2, 3], 2)   Returns 1 (first)
    linearsearchall([1, 2, 2, 3], 2)   Returns [1, 2]
    
     7. None/null values (if language supports)
    linearsearch([1, None, 3], None)   Returns 1
    

  

 PROBLEM 4: INSERT ELEMENT AT POSITION

 DEEP THEORETICAL ANALYSIS

The Fundamental Challenge:

Arrays are contiguous. There are no gaps. When you insert at position i, elements at i, i+1, i+2, ... must all shift RIGHT.

Memory Visualization:

    Before insert at index 2:
    Address: 1000  1004  1008  100C  1010
    Value:   [10]  [20]  [30]  [40]  [50]
    Index:    0     1     2     3     4
    
    After inserting 99 at index 2:
    Address: 1000  1004  1008  100C  1010  1014
    Value:   [10]  [20]  [99]  [30]  [40]  [50]
    Index:    0     1     2     3     4     5
    
    Elements 30, 40, 50 had to MOVE to new addresses!
    

The Shift Process:

    Step 1: Ensure capacity (may need to resize array)
    
    Step 2: Shift elements backward (MUST go from end to start!)
    
    Why backward?
    If we go forward:
      arr[2] = arr[3]  → [10, 20, 40, 40, 50]  (30 lost!)
      arr[3] = arr[4]  → [10, 20, 40, 50, 50]  (40 overwritten!)
      
    If we go backward:
      arr[5] = arr[4]  → [10, 20, 30, 40, 50, 50]
      arr[4] = arr[3]  → [10, 20, 30, 40, 40, 50]
      arr[3] = arr[2]  → [10, 20, 30, 30, 40, 50]
      arr[2] = 99      → [10, 20, 99, 30, 40, 50] ✓
    
    Step 3: Insert new element at position
    
    Step 4: Update size
    

  

 IMPLEMENTATION:

    class DynamicArray:
        def init(self):
            self.capacity = 4
            self.size = 0
            self.arr = [None]  self.capacity
        
        def insert(self, index, value):
             Validation
            if index < 0 or index > self.size:
                raise IndexError(f"Index {index} out of bounds for size {self.size}")
            
             Resize if needed
            if self.size == self.capacity:
                self.resize()
            
             Shift elements RIGHT (backward iteration!)
            for i in range(self.size, index, -1):
                self.arr[i] = self.arr[i - 1]
            
             Insert new element
            self.arr[index] = value
            
             Update size
            self.size += 1
        
        def resize(self):
            self.capacity = 2
            newarr = [None]  self.capacity
            
            for i in range(self.size):
                newarr[i] = self.arr[i]
            
            self.arr = newarr
    

Complete Trace:

    da = DynamicArray()
    da.insert(0, 10)   Insert at beginning of empty array
    da.insert(1, 20)   Append
    da.insert(2, 30)   Append
    da.insert(1, 15)   Insert in middle
    
    Trace for da.insert(1, 15):
    
    Before:
      size=3, capacity=4
      arr = [10, 20, 30, None]
      Inserting 15 at index 1
    
    Step 1: Check capacity
      size (3) < capacity (4) ✓ No resize needed
    
    Step 2: Shift elements
      Loop: for i in range(3, 1, -1):   i = 3, 2
      
      i=3: arr[3] = arr[2]
        arr = [10, 20, 30, 30]
      
      i=2: arr[2] = arr[1]
        arr = [10, 20, 20, 30]
    
    Step 3: Insert
      arr[1] = 15
      arr = [10, 15, 20, 30]
    
    Step 4: Update size
      size = 4
    
    Final: arr = [10, 15, 20, 30]
    

  

 Time Complexity Analysis:

    Best Case: Insert at END
      index = size
      No elements to shift
      Time: O(1) (excluding resize)
    
    Worst Case: Insert at BEGINNING
      index = 0
      Shift all n elements
      Time: O(n)
    
    Average Case: Insert at MIDDLE
      index = n/2
      Shift n/2 elements
      Time: O(n)
    
    With Resizing:
      Occasional insert triggers O(n) resize
      But amortized still O(1) for append
      For arbitrary position: Still O(n) overall
    

  

 Common Mistakes:

Mistake 1: Forward Shifting

     WRONG!
    for i in range(index, self.size):
        self.arr[i + 1] = self.arr[i]   Overwrites data!
    
     Example: [10, 20, 30], insert at 1
     i=1: arr[2] = arr[1] → [10, 20, 20] (30 lost!)
     i=2: arr[3] = arr[2] → [10, 20, 20, 20] (wrong!)
    

Mistake 2: Not Checking Bounds

     WRONG!
    def insert(self, index, value):
         What if index > size?
        self.arr[index] = value   Might create gaps!
    
     Example: size=3, insert at index 5
     arr = [10, 20, 30, None, None, 99]
     Gap at indices 3-4! Not a valid array!
    

Mistake 3: Forgetting to Update Size

     WRONG!
    def insert(self, index, value):
         ... shifting code ...
        self.arr[index] = value
         Forgot: self.size += 1
    
     Result: Next insert overwrites data!
    

  

 PROBLEM 5: DELETE ELEMENT AT POSITION

 THEORETICAL FOUNDATION

Deletion is the inverse of insertion. Instead of creating a gap and filling it, we:

1.  Remove element (creating a gap)
2.  Close the gap by shifting LEFT

Memory Visualization:

    Before delete at index 2:
    Address: 1000  1004  1008  100C  1010
    Value:   [10]  [20]  [30]  [40]  [50]
    Index:    0     1     2     3     4
    
    After deleting at index 2:
    Address: 1000  1004  1008  100C
    Value:   [10]  [20]  [40]  [50]
    Index:    0     1     2     3
    
    Elements 40, 50 moved LEFT to close gap!
    

The Shift Process:

    Step 1: Validate index
    
    Step 2: Shift elements LEFT (forward iteration!)
    
    Why forward this time?
      Start from deleted position, copy next element
    
      arr[2] = arr[3]  → [10, 20, 40, 40, 50]
      arr[3] = arr[4]  → [10, 20, 40, 50, 50]
    
    Step 3: Update size (last element becomes "garbage")
    
    Step 4: Optionally resize down if array too empty
    

  

 IMPLEMENTATION:

    class DynamicArray:
         ... previous code ...
        
        def delete(self, index):
             Validation
            if index < 0 or index >= self.size:
                raise IndexError(f"Index {index} out of bounds for size {self.size}")
            
             Shift elements LEFT (forward iteration!)
            for i in range(index, self.size - 1):
                self.arr[i] = self.arr[i + 1]
            
             Clear last element (optional, helps GC)
            self.arr[self.size - 1] = None
            
             Update size
            self.size -= 1
            
             Optional: shrink if too empty
            if self.size > 0 and self.size == self.capacity // 4:
                self.shrink()
        
        def shrink(self):
            self.capacity //= 2
            newarr = [None]  self.capacity
            
            for i in range(self.size):
                newarr[i] = self.arr[i]
            
            self.arr = newarr
    

Complete Trace:

    da = DynamicArray()
    da.arr = [10, 20, 30, 40, 50, None, None, None]
    da.size = 5
    da.capacity = 8
    
    da.delete(2)   Delete element at index 2 (value 30)
    
    Step 1: Validate
      index=2, size=5
      0 <= 2 < 5 ✓
    
    Step 2: Shift LEFT
      Loop: for i in range(2, 4):   i = 2, 3
      
      i=2: arr[2] = arr[3]
        arr = [10, 20, 40, 40, 50, None, None, None]
      
      i=3: arr[3] = arr[4]
        arr = [10, 20, 40, 50, 50, None, None, None]
    
    Step 3: Clear last valid position
      arr[4] = None
      arr = [10, 20, 40, 50, None, None, None, None]
    
    Step 4: Update size
      size = 4
    
    Logical array: [10, 20, 40, 50]
    Physical array: [10, 20, 40, 50, None, None, None, None]
    

  

 Time Complexity:

    Best Case: Delete LAST element
      index = size - 1
      No shifting needed
      Time: O(1)
    
    Worst Case: Delete FIRST element
      index = 0
      Shift all remaining n-1 elements
      Time: O(n)
    
    Average Case: Delete MIDDLE
      index = n/2
      Shift n/2 elements
      Time: O(n)
    

  

\[MINUTE 25-50\] TWO POINTER FUNDAMENTALS
---------------------------------------------

 DEEP THEORETICAL FOUNDATION

What Are Two Pointers?

Two pointers is a pattern, not just a technique. It's a way of thinking about problems where you:

1.  Maintain two positions in an array
2.  Move them based on certain conditions
3.  Use their relationship to solve the problem

Why Two Pointers Work:

The key insight: One pointer alone can only tell you about ONE position. Two pointers can tell you about RELATIONSHIPS.

Categories:

    1. Opposite Ends (left → ← right)
       - Exploit symmetry
       - Used for: palindromes, pairs with target sum
       - Movement: Usually both move inward
    
    2. Same Direction (slow → fast →)
       - fast explores, slow consolidates
       - Used for: removing duplicates, partitioning
       - Movement: fast always advances, slow conditionally
    
    3. Fixed Distance (i → ... → j where j-i=k)
       - Maintain window of size k
       - Used for: sliding window problems
       - Movement: both move together
    
    4. Variable Distance (expand/shrink)
       - Window size changes
       - Used for: longest/shortest subarray with condition
       - Movement: right expands, left shrinks
    

  

 PROBLEM 6: REMOVE DUPLICATES FROM SORTED ARRAY

 THEORETICAL ANALYSIS

The Setup:

    Given: SORTED array with duplicates
    Goal: Remove duplicates IN-PLACE
    Return: New length
    
    Input: [1, 1, 2, 2, 2, 3, 4, 4]
    Output: 4, array becomes [1, 2, 3, 4, , , , ]
    

Key Observations:

1.  Array is SORTED → Duplicates are adjacent!
    
        [1, 1, 2] → Duplicates next to each other
        NOT [1, 2, 1] → Would be harder!
        
    
2.  In-place → Can't create new array
    
3.  Don't need to delete → Just need unique elements at beginning
    

The Insight:

    We need to COMPRESS the array:
    Before: [1, 1, 2, 2, 2, 3, 4, 4]
    After:  [1, 2, 3, 4, , , , ]
    
    How? Keep a "write position" for unique elements!
    

Visual Evolution:

    Initial: [1, 1, 2, 2, 2, 3, 4, 4]
              ↑  ↑
            slow fast
    
    slow = where to write next unique
    fast = scanning for next unique
    
    Step 1: fast=1, arr[1]=1 same as arr[0]=1 → skip
      slow=1, fast=2
    
    Step 2: fast=2, arr[2]=2 different from arr[1]=1 → write!
      arr[slow] = arr[fast]
      arr = [1, 2, 2, 2, 2, 3, 4, 4]
      slow=2, fast=3
    
    Step 3: fast=3, arr[3]=2 same as arr[2]=2 → skip
      slow=2, fast=4
    
    Step 4: fast=4, arr[4]=2 same as arr[3]=2 → skip
      slow=2, fast=5
    
    Step 5: fast=5, arr[5]=3 different from arr[4]=2 → write!
      arr[slow] = arr[fast]
      arr = [1, 2, 3, 2, 2, 3, 4, 4]
      slow=3, fast=6
    
    ... continue ...
    
    Final: [1, 2, 3, 4, , , , ]
           slow=4 (new length)
    

  

 IMPLEMENTATION:

    def removeduplicates(arr):
        """
        Remove duplicates from sorted array in-place.
        Returns new length.
        """
         Edge case: empty array
        if not arr:
            return 0
        
         slow = position to write next unique element
         Start at 1 because arr[0] is always unique
        slow = 1
        
         fast = scanning for unique elements
        for fast in range(1, len(arr)):
             If current element different from previous
            if arr[fast] != arr[fast - 1]:
                 Write it at slow position
                arr[slow] = arr[fast]
                slow += 1
        
        return slow
    

Why Compare with arr\[fast - 1\]?

    Alternative: Compare with arr[slow - 1]
    
    if arr[fast] != arr[slow - 1]:
        arr[slow] = arr[fast]
        slow += 1
    
    This also works! Both are equivalent because:
    - We only increment slow when we find unique
    - So arr[slow-1] contains the last unique we wrote
    - Which is the same as arr[fast-1] when fast moves
    

Complete Trace:

    arr = [1, 1, 2, 2, 3]
    
    Initial: slow=1, fast=1
    
    fast=1: arr[1]=1, arr[0]=1 → same, skip
      slow=1
    
    fast=2: arr[2]=2, arr[1]=1 → different!
      arr[1] = 2
      arr = [1, 2, 2, 2, 3]
      slow=2
    
    fast=3: arr[3]=2, arr[2]=2 → same, skip
      slow=2
    
    fast=4: arr[4]=3, arr[3]=2 → different!
      arr[2] = 3
      arr = [1, 2, 3, 2, 3]
      slow=3
    
    Return slow=3
    Final array (first 3 elements): [1, 2, 3]
    

  

 Edge Cases:

     Empty array
    removeduplicates([])   Returns 0
    
     Single element
    removeduplicates([1])   Returns 1, array=[1]
    
     No duplicates
    removeduplicates([1, 2, 3])   Returns 3, array=[1,2,3]
    
     All duplicates
    removeduplicates([5, 5, 5, 5])   Returns 1, array=[5,,,]
    
     Two elements (same)
    removeduplicates([1, 1])   Returns 1, array=[1,]
    
     Two elements (different)
    removeduplicates([1, 2])   Returns 2, array=[1,2]
    

  

 COMPLEXITY:

    Time: O(n) - single pass with fast pointer
    Space: O(1) - only two integer variables
    
    Why O(1) space?
    - We modify input array (allowed by problem)
    - slow and fast are just integers
    - No additional data structures
    

  

 PROBLEM 7: MOVE ZEROS TO END

 THEORETICAL FOUNDATION

Problem:

    Move all 0s to end while maintaining relative order of non-zeros.
    
    Input: [0, 1, 0, 3, 12]
    Output: [1, 3, 12, 0, 0]
    

Key Constraints:

1.  In-place - No extra array
2.  Maintain relative order - Non-zeros stay in same order
3.  Zeros at end - All zeros grouped at end

The Insight:

This is similar to remove duplicates, but instead of removing, we're partitioning:

   Left part: all non-zeros (in original order)
   Right part: all zeros

Two Approaches:

  

 APPROACH 1: Two-Pointer Swap

Strategy:

   slow = position for next non-zero
   fast = scanning all elements
   When fast finds non-zero, swap with slow position

    def movezerosswap(arr):
        slow = 0   Position for next non-zero
        
        for fast in range(len(arr)):
            if arr[fast] != 0:
                 Swap non-zero to slow position
                arr[slow], arr[fast] = arr[fast], arr[slow]
                slow += 1
    

Trace:

    arr = [0, 1, 0, 3, 12]
    
    Initial: slow=0
    
    fast=0: arr[0]=0 → skip
      slow=0
    
    fast=1: arr[1]=1 → non-zero!
      Swap arr[0] ↔ arr[1]
      arr = [1, 0, 0, 3, 12]
      slow=1
    
    fast=2: arr[2]=0 → skip
      slow=1
    
    fast=3: arr[3]=3 → non-zero!
      Swap arr[1] ↔ arr[3]
      arr = [1, 3, 0, 0, 12]
      slow=2
    
    fast=4: arr[4]=12 → non-zero!
      Swap arr[2] ↔ arr[4]
      arr = [1, 3, 12, 0, 0]
      slow=3
    
    Final: [1, 3, 12, 0, 0] ✓
    

Why Swap Works:

    Invariant after processing index i:
    - arr[0...slow-1] contains all non-zeros seen so far
    - arr[slow...i] contains all zeros seen so far
    - arr[i+1...n-1] not yet processed
    
    When we find non-zero at position fast:
    - Swap it with arr[slow] (which is 0 or already processed)
    - Maintains invariant!
    

  

 APPROACH 2: Two-Pass (More Intuitive)

Strategy:

1.  First pass: Move all non-zeros to beginning
2.  Second pass: Fill rest with zeros

    def movezerostwopass(arr):
         First pass: collect all non-zeros
        slow = 0
        for num in arr:
            if num != 0:
                arr[slow] = num
                slow += 1
        
         Second pass: fill rest with zeros
        for i in range(slow, len(arr)):
            arr[i] = 0
    

Trace:

    arr = [0, 1, 0, 3, 12]
    
    First pass:
      num=0: skip, slow=0
      num=1: arr[0]=1, slow=1
      num=0: skip, slow=1
      num=3: arr[1]=3, slow=2
      num=12: arr[2]=12, slow=3
      
      After first pass: [1, 3, 12, 3, 12], slow=3
    
    Second pass:
      Fill arr[3...4] with 0
      Final: [1, 3, 12, 0, 0] ✓
    

  

 Comparison:

                        Swap Method         Two-Pass Method
    =================================================================
    Time                O(n)                O(n)
    Space               O(1)                O(1)
    Passes              1                   2
    Intuitive?          Medium              Very
    Min swaps           Yes                 N/A
    Interview favorite  Yes                 Also good
    

When to use which:

   Swap: When minimizing writes matters (flash memory, databases)
   Two-pass: When clarity matters, easier to explain

  

 YOUR TURN - PRACTICE PROBLEMS:

Problem 7A: Remove Element

    Remove all instances of value in-place.
    Input: arr = [3,2,2,3], val = 3
    Output: 2, arr = [2,2,,]
    
    Hint: Same pattern as move zeros, but remove specific value
    

Problem 7B: Segregate Even and Odd

    Move all even numbers to left, odd to right.
    Input: [12, 34, 45, 9, 8, 90, 3]
    Output: [12, 34, 8, 90, 45, 9, 3] (any order within even/odd groups)
    
    Hint: Partition pattern, similar to move zeros