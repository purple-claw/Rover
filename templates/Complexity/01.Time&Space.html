<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-2RQWYRT51K"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-2RQWYRT51K');
    </script>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Rover - Time & Space Complexity Analysis</title>
    <style>
        /* ==================== FONT IMPORT ==================== */
        @import url('https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400;500;600;700&display=swap');

        /* ==================== GLASSMORPHISM THEME ==================== */
        :root {
            /* Pure Black Base */
            --bg-primary: #000000;
            --bg-secondary: #0a0a0a;
            
            /* Glass Effect Colors */
            --glass-white: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-highlight: rgba(255, 255, 255, 0.15);
            
            /* McLaren Orange */
            --mclaren-orange: #FF8000;
            --mclaren-glow: rgba(255, 128, 0, 0.3);
            --mclaren-light: #FFA040;
            --mclaren-dark: #CC6600;
            
            /* RedBull Red */
            --redbull-red: #DC0000;
            --redbull-blue: #1E41FF;
            --redbull-glow: rgba(220, 0, 0, 0.3);
            --redbull-light: #FF3333;
            
            /* Meta Blue */
            --meta-blue: #0081FB;
            --meta-glow: rgba(0, 129, 251, 0.3);
            --meta-light: #33A3FF;
            --meta-dark: #0066CC;
            
            /* Text Colors - Ultra White */
            --text-primary: #FFFFFF;
            --text-secondary: #FFFFFF;
            --text-muted: rgba(255, 255, 255, 0.9);
            --text-dim: rgba(255, 255, 255, 0.7);
            
            /* Code Syntax */
            --code-bg: rgba(20, 20, 20, 0.6);
            --code-keyword: #FF8000;
            --code-function: #0081FB;
            --code-string: #3fb950;
            --code-comment: rgba(255, 255, 255, 0.4);
            --code-number: #DC0000;
            --code-variable: #FFA040;
            
            /* Complexity Badges Colors */
            --o1-color: #3fb950;
            --ologn-color: #0081FB;
            --on-color: #FFA040;
            --onlogn-color: #FF8000;
            --on2-color: #DC0000;
            --o2n-color: #bc8cff;
            
            /* Layout */
            --container-width: 1100px;
            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 2.5rem;
            --spacing-2xl: 3rem;
            
            /* Border Radius */
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-xl: 24px;
            
            /* Animations */
            --transition-fast: 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-normal: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            overflow-x: hidden;
            width: 100%;
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Quicksand', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #000000;
            color: #FFFFFF;
            line-height: 1.7;
            overflow-x: hidden;
            position: relative;
            font-size: 16px;
            font-weight: 400;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            width: 100%;
            max-width: 100vw;
            /* Prevent horizontal scroll on mobile */
            -webkit-overflow-scrolling: touch;
        }

        h1, h2, h3, h4 {
            font-family: 'Quicksand', sans-serif;
            font-weight: 600;
            letter-spacing: -0.03em;
        }

        code, pre {
            font-family: 'Courier New', monospace;
            font-weight: 400;
        }

        /* Progress Bar */
        #reading-progress {
            position: fixed;
            top: 0;
            left: 0;
            width: 0%;
            height: 3px;
            background: linear-gradient(90deg, var(--mclaren-orange), var(--mclaren-light));
            box-shadow: 0 0 10px var(--mclaren-glow);
            z-index: 9999;
            transition: width 0.1s ease;
        }

        /* Container */
        .container {
            max-width: var(--container-width);
            margin: 0 auto;
            padding: 0 var(--spacing-lg);
            position: relative;
            z-index: 1;
        }

        /* Navigation */
        nav {
            position: sticky;
            top: 0;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(24px) saturate(180%);
            -webkit-backdrop-filter: blur(24px) saturate(180%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.12);
            padding: 0.75rem 0;
            box-shadow: 
                0 1px 3px rgba(0, 0, 0, 0.5),
                0 1px 20px rgba(255, 128, 0, 0.1),
                inset 0 -1px 0 rgba(255, 255, 255, 0.05);
        }

        nav::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, 
                transparent,
                rgba(255, 128, 0, 0.3) 20%,
                rgba(255, 128, 0, 0.5) 50%,
                rgba(255, 128, 0, 0.3) 80%,
                transparent
            );
            opacity: 0.8;
        }

        .nav-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 2rem;
            padding: 0 var(--spacing-lg);
            max-width: var(--container-width);
            margin: 0 auto;
        }

        .nav-logo {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--mclaren-orange);
            text-decoration: none;
            letter-spacing: 0.1em;
        }

        .nav-links {
            display: flex;
            gap: 2rem;
            list-style: none;
        }

        .nav-link {
            color: rgba(255, 255, 255, 0.8);
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            transition: all var(--transition-fast);
            position: relative;
            padding: 0.5rem 0;
        }

        .nav-link:hover {
            color: var(--mclaren-orange);
            text-shadow: 0 0 20px var(--mclaren-glow);
        }

        .nav-link.active::after {
            content: '';
            position: absolute;
            bottom: -3px;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--mclaren-orange);
            box-shadow: 0 0 10px var(--mclaren-glow);
        }

        /* Hero Section */
        .hero {
            padding: var(--spacing-2xl) 0;
            text-align: center;
            position: relative;
            margin-bottom: var(--spacing-xl);
            z-index: 1;
        }

        .hero h1 {
            font-size: 3.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: var(--mclaren-orange);
            background: linear-gradient(135deg, 
                var(--mclaren-orange) 0%, 
                var(--mclaren-light) 50%, 
                var(--mclaren-orange) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: glow 3s ease-in-out infinite;
        }

        @supports not (background-clip: text) {
            .hero h1 {
                color: var(--mclaren-orange) !important;
                -webkit-text-fill-color: var(--mclaren-orange) !important;
            }
        }

        @keyframes glow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }

        .hero p {
            font-size: 1.2rem;
            color: var(--text-muted);
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.8;
        }

        /* Sections */
        .section {
            margin-bottom: var(--spacing-2xl);
            opacity: 0;
            transform: translateY(30px);
            transition: all 0.8s ease;
        }

        .section.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .section-header {
            border-bottom: 1px solid var(--glass-border);
            padding-bottom: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
        }

        .section-title {
            font-size: 2.2rem;
            color: var(--text-primary);
            margin-bottom: 0.75rem;
            font-weight: 700;
        }

        .section-subtitle {
            color: var(--text-muted);
            font-size: 1.1rem;
        }

        /* Content Block */
        .content-block {
            background: var(--glass-white);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            padding: var(--spacing-lg);
            margin: var(--spacing-md) 0;
        }

        .content-block h3 {
            font-size: 1.7rem;
            margin-bottom: var(--spacing-md);
            color: var(--text-primary);
            font-weight: 600;
        }

        .content-block h4 {
            font-size: 1.35rem;
            margin: var(--spacing-md) 0 var(--spacing-sm) 0;
            color: var(--mclaren-light);
            font-weight: 600;
        }

        .content-block p {
            margin: var(--spacing-sm) 0;
            line-height: 1.8;
            font-size: 1.05rem;
        }

        .content-block ul, .content-block ol {
            margin-left: var(--spacing-lg);
            margin-top: var(--spacing-sm);
            margin-bottom: var(--spacing-sm);
        }

        .content-block li {
            margin: 0.5rem 0;
            line-height: 1.8;
        }

        /* Code Blocks */
        .code-block {
            background: linear-gradient(135deg, rgba(20, 20, 20, 0.8), rgba(10, 10, 10, 0.9));
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            padding: var(--spacing-md);
            margin: var(--spacing-md) 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            position: relative;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: all var(--transition-normal);
        }

        .code-block:hover {
            border-color: rgba(255, 128, 0, 0.3);
            box-shadow: 0 6px 20px rgba(255, 128, 0, 0.15);
        }

        .code-block pre {
            margin: 0;
            white-space: pre;
        }

        .code-block code {
            color: var(--text-primary);
        }

        /* Syntax Highlighting */
        .keyword {
            color: var(--code-keyword);
            font-weight: 600;
        }

        .function {
            color: var(--code-function);
        }

        .string {
            color: var(--code-string);
        }

        .comment {
            color: var(--code-comment);
            font-style: italic;
        }

        .number {
            color: var(--code-number);
        }

        .variable {
            color: var(--code-variable);
        }

        /* Complexity Badges */
        .complexity-badge {
            display: inline-block;
            padding: 0.35rem 0.8rem;
            border-radius: var(--radius-sm);
            font-size: 0.85rem;
            font-weight: 700;
            margin: 0.25rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            transition: all var(--transition-fast);
        }

        .complexity-badge:hover {
            transform: scale(1.05);
        }

        .o-1 {
            background: var(--o1-color);
            color: white;
            box-shadow: 0 0 10px rgba(63, 185, 80, 0.5);
        }

        .o-log-n {
            background: var(--ologn-color);
            color: white;
            box-shadow: 0 0 10px rgba(0, 129, 251, 0.5);
        }

        .o-n {
            background: var(--on-color);
            color: var(--bg-primary);
            box-shadow: 0 0 10px rgba(255, 160, 64, 0.5);
        }

        .o-n-log-n {
            background: var(--onlogn-color);
            color: white;
            box-shadow: 0 0 10px rgba(255, 128, 0, 0.5);
        }

        .o-n2 {
            background: var(--on2-color);
            color: white;
            box-shadow: 0 0 10px rgba(220, 0, 0, 0.5);
        }

        .o-2n {
            background: var(--o2n-color);
            color: white;
            box-shadow: 0 0 10px rgba(188, 140, 255, 0.5);
        }

        /* Callout Boxes */
        .callout {
            border-left: 4px solid var(--mclaren-orange);
            background: rgba(255, 128, 0, 0.1);
            padding: var(--spacing-md);
            margin: var(--spacing-md) 0;
            border-radius: var(--radius-sm);
        }

        .callout-title {
            font-weight: 700;
            color: var(--mclaren-orange);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }

        .callout.warning {
            border-left-color: var(--redbull-red);
            background: rgba(220, 0, 0, 0.1);
        }

        .callout.warning .callout-title {
            color: var(--redbull-red);
        }

        .callout.success {
            border-left-color: var(--o1-color);
            background: rgba(63, 185, 80, 0.1);
        }

        .callout.success .callout-title {
            color: var(--o1-color);
        }

        /* Interactive Examples */
        .interactive-example {
            background: var(--glass-white);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            padding: var(--spacing-lg);
            margin: var(--spacing-md) 0;
        }

        .example-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: var(--spacing-md);
            flex-wrap: wrap;
            align-items: center;
        }

        .control-button {
            background: linear-gradient(135deg, var(--mclaren-orange), var(--mclaren-light));
            color: white;
            border: none;
            padding: 0.5rem 1.25rem;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: 0.95rem;
            font-family: 'Quicksand', sans-serif;
            font-weight: 600;
            transition: all var(--transition-fast);
            box-shadow: 0 4px 12px var(--mclaren-glow);
        }

        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px var(--mclaren-glow);
        }

        .control-button:disabled {
            background: var(--glass-white);
            color: var(--text-dim);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .example-output {
            background: var(--code-bg);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-sm);
            padding: var(--spacing-md);
            margin-top: var(--spacing-md);
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            max-height: 400px;
            overflow-y: auto;
        }

        input[type="number"], input[type="text"], select {
            padding: 0.5rem;
            background: var(--code-bg);
            border: 1px solid var(--glass-border);
            color: white;
            border-radius: var(--radius-sm);
            font-family: 'Quicksand', sans-serif;
        }

        /* Step Trace Animation Styles */
        .step-trace {
            background: var(--code-bg);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-sm);
            padding: var(--spacing-md);
            margin-top: var(--spacing-md);
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            min-height: 300px;
        }

        .trace-step {
            padding: 0.5rem;
            margin: 0.25rem 0;
            border-radius: 4px;
            transition: all 0.3s ease;
            opacity: 0.3;
        }

        .trace-step.active {
            background: rgba(255, 128, 0, 0.2);
            border-left: 3px solid var(--mclaren-orange);
            opacity: 1;
        }

        .trace-step.completed {
            opacity: 0.6;
            border-left: 3px solid var(--o1-color);
        }

        .variable-state {
            background: rgba(0, 129, 251, 0.1);
            padding: 0.5rem;
            border-radius: 4px;
            margin: 0.5rem 0;
            font-size: 0.9rem;
        }

        .array-visualization {
            display: flex;
            gap: 0.5rem;
            margin: 1rem 0;
            flex-wrap: wrap;
        }

        .array-element {
            background: var(--glass-white);
            border: 2px solid var(--glass-border);
            padding: 0.75rem;
            min-width: 50px;
            text-align: center;
            border-radius: 6px;
            transition: all 0.3s ease;
            position: relative;
        }

        .array-element.active {
            background: rgba(255, 128, 0, 0.3);
            border-color: var(--mclaren-orange);
            transform: scale(1.1);
        }

        .array-element.compared {
            background: rgba(0, 129, 251, 0.3);
            border-color: var(--meta-blue);
        }

        .array-element.found {
            background: rgba(63, 185, 80, 0.3);
            border-color: var(--o1-color);
        }

        .array-element .index {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7rem;
            color: var(--text-dim);
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: var(--spacing-md) 0;
        }

        th, td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid var(--glass-border);
        }

        th {
            background: var(--glass-white);
            font-weight: 700;
            color: var(--mclaren-orange);
        }

        tr:hover {
            background: var(--glass-white);
        }

        /* Memory Visualization */
        .memory-block {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 2px solid var(--glass-border);
            background: var(--glass-white);
            margin: 2px;
            text-align: center;
            line-height: 36px;
            font-size: 0.8rem;
            border-radius: 4px;
            transition: all var(--transition-fast);
            font-weight: 600;
        }

        .memory-block:hover {
            background: var(--mclaren-orange);
            border-color: var(--mclaren-orange);
            color: white;
            transform: scale(1.1);
        }

        .memory-block.active {
            background: var(--o1-color);
            border-color: var(--o1-color);
            color: white;
        }

        /* Chart Container */
        .chart-container {
            position: relative;
            width: 100%;
            height: 350px;
            background: var(--code-bg);
            border-radius: var(--radius-md);
            overflow: hidden;
            margin: var(--spacing-md) 0;
            border: 1px solid var(--glass-border);
        }

        /* Footer */
        footer {
            background: var(--glass-white);
            padding: var(--spacing-xl) 0;
            margin-top: var(--spacing-2xl);
            text-align: center;
            color: var(--text-muted);
            border-top: 1px solid var(--glass-border);
        }

        /* Deep Dive Section Styles */
        .deep-dive {
            background: rgba(0, 129, 251, 0.05);
            border: 1px solid rgba(0, 129, 251, 0.2);
            border-radius: var(--radius-md);
            padding: var(--spacing-lg);
            margin: var(--spacing-lg) 0;
        }

        .deep-dive h4 {
            color: var(--meta-blue);
            margin-bottom: var(--spacing-md);
        }

        /* Hamburger Menu Styles */
        .hamburger-menu {
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 0.5rem;
            z-index: 1002;
            transition: all var(--transition-fast);
        }

        .hamburger-line {
            display: block;
            width: 25px;
            height: 2px;
            background: var(--mclaren-orange);
            margin: 3px 0;
            transition: all 0.3s ease;
            border-radius: 2px;
        }

        .hamburger-menu.active .hamburger-line:nth-child(1) {
            transform: translateY(8px) rotate(45deg);
        }

        .hamburger-menu.active .hamburger-line:nth-child(2) {
            opacity: 0;
        }

        .hamburger-menu.active .hamburger-line:nth-child(3) {
            transform: translateY(-8px) rotate(-45deg);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .hero h1 {
                font-size: 2.5rem;
            }
            
            .section-title {
                font-size: 1.8rem;
            }
            
            .hamburger-menu {
                display: flex;
            }

            .nav-links {
                display: none;
                position: fixed;
                top: 60px;
                left: 0;
                right: 0;
                background: rgba(0, 0, 0, 0.98);
                backdrop-filter: blur(20px);
                -webkit-backdrop-filter: blur(20px);
                flex-direction: column;
                padding: 1rem;
                border-bottom: 1px solid var(--glass-border);
                max-height: calc(100vh - 60px);
                overflow-y: auto;
                z-index: 1001;
            }

            .nav-links.active {
                display: flex;
            }

            .nav-links li {
                width: 100%;
            }

            .nav-link {
                display: block;
                padding: 0.75rem 1rem;
                width: 100%;
                text-align: center;
                border-radius: var(--radius-sm);
            }

            .nav-link:hover {
                background: rgba(255, 128, 0, 0.1);
            }
            
            .content-block {
                padding: var(--spacing-md);
            }
            
            .example-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            /* Fix visibility issue on mobile - ensure sections are visible */
            .section {
                opacity: 1 !important;
                transform: translateY(0) !important;
            }
            
            /* Ensure container has proper width on mobile */
            .container {
                width: 100%;
                max-width: 100%;
                padding: 0 var(--spacing-md);
            }
            
            /* Fix hero padding on mobile */
            .hero {
                padding: var(--spacing-lg) 0;
            }
        }
    </style>
</head>
<body>
    <!-- Progress Bar -->
    <div id="reading-progress"></div>
    
    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="#" class="nav-logo">ROVER</a>
            <ul class="nav-links" id="navLinks">
                <li><a href="#introduction" class="nav-link active">Introduction</a></li>
                <li><a href="#time-complexity" class="nav-link">Time Complexity</a></li>
                <li><a href="#space-complexity" class="nav-link">Space Complexity</a></li>
                <li><a href="#examples" class="nav-link">Examples</a></li>
                <li><a href="#practice" class="nav-link">Practice</a></li>
            </ul>
            <button class="hamburger-menu" id="hamburgerMenu" aria-label="Toggle navigation menu">
                <span class="hamburger-line"></span>
                <span class="hamburger-line"></span>
                <span class="hamburger-line"></span>
            </button>
        </div>
    </nav>
    
    <!-- Hero Section -->
    <section class="hero">
        <div class="container">
            <h1>Time & Space Complexity Analysis</h1>
            <p>Master the art of algorithm analysis with interactive examples and visualizations. Learn to evaluate performance, optimize solutions, and make informed decisions about algorithm efficiency.</p>
        </div>
    </section>
    
    <main class="container">
        <!-- Introduction Section -->
        <article id="introduction" class="section">
            <div class="section-header">
                <h2 class="section-title">What is Complexity Analysis?</h2>
                <p class="section-subtitle">Understanding the foundations of algorithm efficiency</p>
            </div>
            
            <div class="content-block">
                <h3>The Library Analogy - A Comprehensive Understanding</h3>
                <p>Imagine you're standing at the entrance of a massive library containing exactly 1,000 books. Your task is to find one specific book - let's say "Advanced Algorithms" by Thomas Cormen. How you approach this problem fundamentally determines how long it will take you to complete the task.</p>
                
                <p>This seemingly simple scenario perfectly encapsulates the essence of algorithm complexity. The library represents your data set, the book you're searching for is your target element, and your search strategy is your algorithm. The efficiency of your approach directly correlates to the time complexity of algorithms we use in computer science.</p>

                <div class="deep-dive">
                    <h4>Deep Dive: Why Search Efficiency Matters</h4>
                    <p>In the real world, the difference between efficient and inefficient algorithms isn't just academic - it has profound practical implications. Consider a database with 1 billion user records. If checking each record takes just 1 microsecond:</p>
                    <ul>
                        <li>Linear search worst case: 1 billion microseconds = 16.67 minutes</li>
                        <li>Binary search worst case: 30 microseconds = 0.00003 seconds</li>
                        <li>That's a difference of over 33 million times!</li>
                    </ul>
                    <p>This dramatic difference is why companies like Google, Facebook, and Amazon invest heavily in algorithm optimization. A poorly chosen algorithm can mean the difference between a responsive application and one that's completely unusable.</p>
                </div>
                
                <div class="interactive-example">
                    <h4>Interactive Search Comparison with Step-by-Step Trace</h4>
                    <div class="example-controls">
                        <button class="control-button" onclick="startLinearSearchAnimation()">Linear Search with Trace</button>
                        <button class="control-button" onclick="startBinarySearchAnimation()">Binary Search with Trace</button>
                        <button class="control-button" onclick="resetSearchAnimation()">Reset</button>
                        <label style="margin-left: 1rem;">
                            Speed: 
                            <input type="range" id="animation-speed" min="100" max="2000" value="500" style="width: 150px;">
                        </label>
                    </div>
                    <div class="array-visualization" id="search-array">
                        <!-- Array elements will be generated here -->
                    </div>
                    <div class="step-trace" id="search-trace">
                        <div>Select an algorithm to see step-by-step execution trace</div>
                    </div>
                    <div class="example-output" id="search-output">
                        <div><strong>Algorithm Comparison Overview</strong></div>
                        <div>• Linear Search: Checks elements sequentially from start to end</div>
                        <div>• Binary Search: Divides search space in half with each comparison</div>
                        <div>• Binary Search requires sorted data but is exponentially faster</div>
                    </div>
                </div>
            </div>
            
            <div class="content-block">
                <h3>What Exactly is an Algorithm? - A Detailed Exploration</h3>
                <p>An algorithm is a precise, unambiguous, step-by-step procedure for solving a problem or accomplishing a task. Think of it as a recipe that takes inputs (ingredients) and produces outputs (the finished dish) through a series of well-defined transformations.</p>
                
                <div class="deep-dive">
                    <h4>Deep Dive: The Five Essential Properties of Algorithms</h4>
                    <ol>
                        <li><strong>Finiteness:</strong> An algorithm must terminate after a finite number of steps. This prevents infinite loops and ensures we get results.</li>
                        <li><strong>Definiteness:</strong> Each step must be precisely defined. There should be no ambiguity about what action to take.</li>
                        <li><strong>Input:</strong> An algorithm has zero or more inputs, taken from a specified set of objects.</li>
                        <li><strong>Output:</strong> An algorithm produces one or more outputs, which have a specified relation to the inputs.</li>
                        <li><strong>Effectiveness:</strong> All operations must be sufficiently basic that they can be done exactly and in finite time.</li>
                    </ol>
                </div>
                
                <div class="code-block">
                    <pre><code><span class="comment"># Real-World Algorithm: Making the Perfect Cup of Tea</span>
<span class="comment"># This everyday process demonstrates algorithmic thinking</span>

<span class="keyword">def</span> <span class="function">make_perfect_tea</span>(water_amount_ml, tea_type, sugar_spoons):
    <span class="comment"># Step 1: Input validation (Definiteness)</span>
    <span class="keyword">if</span> water_amount_ml <= <span class="number">0</span>:
        <span class="keyword">return</span> <span class="string">"Error: Invalid water amount"</span>
    
    <span class="comment"># Step 2: Heat water to optimal temperature</span>
    temperature = <span class="function">heat_water</span>(water_amount_ml, tea_type)
    
    <span class="comment"># Step 3: Steep tea for optimal duration</span>
    <span class="keyword">if</span> tea_type == <span class="string">"green"</span>:
        steep_time = <span class="number">120</span>  <span class="comment"># 2 minutes for green tea</span>
    <span class="keyword">elif</span> tea_type == <span class="string">"black"</span>:
        steep_time = <span class="number">240</span>  <span class="comment"># 4 minutes for black tea</span>
    <span class="keyword">else</span>:
        steep_time = <span class="number">180</span>  <span class="comment"># 3 minutes default</span>
    
    <span class="comment"># Step 4: Add sugar if requested</span>
    sweetness_level = sugar_spoons * <span class="number">5</span>  <span class="comment"># Each spoon adds 5 units of sweetness</span>
    
    <span class="comment"># Step 5: Return the finished product (Output)</span>
    <span class="keyword">return</span> {
        <span class="string">"temperature"</span>: temperature,
        <span class="string">"steep_time"</span>: steep_time,
        <span class="string">"sweetness"</span>: sweetness_level,
        <span class="string">"status"</span>: <span class="string">"Perfect tea ready!"</span>
    }</code></pre>
                </div>
                
                <div class="code-block">
                    <pre><code><span class="comment"># Computer Science Algorithm: Finding Maximum with Detailed Analysis</span>
<span class="keyword">def</span> <span class="function">find_maximum_detailed</span>(numbers):
    <span class="comment">"""
    Finds the maximum value in a list of numbers.
    
    Time Complexity: O(n) - We must check every element once
    Space Complexity: O(1) - We only use a constant amount of extra space
    
    This algorithm demonstrates the fundamental principle of linear search:
    we cannot determine the maximum without examining every element.
    """</span>
    
    <span class="comment"># Edge case handling - demonstrates definiteness</span>
    <span class="keyword">if</span> <span class="keyword">not</span> numbers:
        <span class="keyword">raise</span> <span class="function">ValueError</span>(<span class="string">"Cannot find maximum of empty list"</span>)
    
    <span class="comment"># Initialize with first element - our initial hypothesis</span>
    <span class="variable">max_value</span> = numbers[<span class="number">0</span>]
    <span class="variable">max_index</span> = <span class="number">0</span>
    <span class="variable">comparisons</span> = <span class="number">0</span>
    
    <span class="comment"># Iterate through remaining elements</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(<span class="number">1</span>, <span class="function">len</span>(numbers)):
        <span class="variable">comparisons</span> += <span class="number">1</span>
        
        <span class="comment"># Update maximum if we find a larger value</span>
        <span class="keyword">if</span> numbers[i] > <span class="variable">max_value</span>:
            <span class="variable">max_value</span> = numbers[i]
            <span class="variable">max_index</span> = i
    
    <span class="comment"># Return comprehensive results</span>
    <span class="keyword">return</span> {
        <span class="string">"max_value"</span>: <span class="variable">max_value</span>,
        <span class="string">"max_index"</span>: <span class="variable">max_index</span>,
        <span class="string">"total_comparisons"</span>: <span class="variable">comparisons</span>,
        <span class="string">"array_size"</span>: <span class="function">len</span>(numbers)
    }</code></pre>
                </div>
            </div>
            
            <div class="content-block">
                <h3>Why Do We Measure Algorithm Performance? - Critical Real-World Impact</h3>
                
                <div class="deep-dive">
                    <h4>Deep Dive: The Knight Capital Group Disaster</h4>
                    <p>On August 1, 2012, Knight Capital Group, a major American financial services firm, lost $440 million in just 45 minutes due to a faulty algorithm deployment. Here's what happened:</p>
                    <ul>
                        <li>A new trading algorithm was deployed with a critical bug</li>
                        <li>The algorithm began buying high and selling low at enormous volumes</li>
                        <li>In 45 minutes, it executed 4 million trades in 154 stocks</li>
                        <li>The company lost $10 million per minute</li>
                        <li>Knight Capital's stock lost 75% of its value in two days</li>
                    </ul>
                    <p>This catastrophe demonstrates that algorithm efficiency isn't just about speed - it's about correctness, robustness, and understanding the full implications of our code. Every millisecond and every operation matters when systems operate at scale.</p>
                </div>
                
                <p>Beyond dramatic failures, algorithm efficiency impacts our daily lives in countless ways:</p>
                <ul>
                    <li><strong>Search Engines:</strong> Google processes over 8.5 billion searches per day. Inefficient algorithms would make this impossible.</li>
                    <li><strong>Social Media:</strong> Facebook's news feed algorithm must rank content for 2.9 billion users in real-time.</li>
                    <li><strong>Navigation:</strong> GPS routing algorithms must find optimal paths through millions of possible routes instantly.</li>
                    <li><strong>E-commerce:</strong> Amazon's recommendation engine analyzes billions of transactions to suggest products.</li>
                    <li><strong>Healthcare:</strong> Medical imaging algorithms must process scans quickly enough for emergency diagnoses.</li>
                </ul>
                
                <div class="interactive-example">
                    <h4>Prime Number Algorithm Comparison with Step Trace</h4>
                    <p>Let's examine two different approaches to checking if a number is prime. This example demonstrates how mathematical insights can dramatically improve algorithm efficiency.</p>
                    
                    <div class="example-controls">
                        <input type="number" id="prime-input" value="97" min="2" max="1000">
                        <button class="control-button" onclick="tracePrimeAlgorithms()">Run Both Algorithms with Trace</button>
                        <button class="control-button" onclick="resetPrimeTrace()">Reset</button>
                    </div>
                    
                    <div class="step-trace" id="prime-trace">
                        <div>Enter a number and click "Run Both Algorithms" to see detailed execution trace</div>
                    </div>
                    
                    <div class="example-output" id="prime-output">
                        <div>Prime checking algorithms demonstrate the power of mathematical optimization</div>
                    </div>
                </div>
                
                <div class="code-block">
                    <pre><code><span class="comment"># Naive Approach - Check All Numbers</span>
<span class="keyword">def</span> <span class="function">is_prime_naive</span>(n):
    <span class="comment">"""
    Time Complexity: O(n)
    This approach checks every number from 2 to n-1.
    For large numbers, this becomes prohibitively slow.
    """</span>
    <span class="keyword">if</span> n < <span class="number">2</span>:
        <span class="keyword">return</span> <span class="keyword">False</span>
    
    <span class="keyword">for</span> divisor <span class="keyword">in</span> <span class="function">range</span>(<span class="number">2</span>, n):
        <span class="keyword">if</span> n % divisor == <span class="number">0</span>:
            <span class="keyword">return</span> <span class="keyword">False</span>  <span class="comment"># Found a divisor, not prime</span>
    
    <span class="keyword">return</span> <span class="keyword">True</span>  <span class="comment"># No divisors found, is prime</span></code></pre>
                </div>
                
                <div class="code-block">
                    <pre><code><span class="comment"># Optimized Approach - Mathematical Insight</span>
<span class="keyword">def</span> <span class="function">is_prime_optimized</span>(n):
    <span class="comment">"""
    Time Complexity: O(√n)
    
    Key Insight: If n has a divisor greater than √n, 
    it must also have a corresponding divisor less than √n.
    Therefore, we only need to check up to √n.
    
    Additional optimizations:
    1. Check if even (except 2)
    2. Only check odd divisors after 2
    """</span>
    <span class="keyword">if</span> n < <span class="number">2</span>:
        <span class="keyword">return</span> <span class="keyword">False</span>
    <span class="keyword">if</span> n == <span class="number">2</span>:
        <span class="keyword">return</span> <span class="keyword">True</span>
    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:
        <span class="keyword">return</span> <span class="keyword">False</span>  <span class="comment"># Even numbers > 2 are not prime</span>
    
    <span class="comment"># Check only odd divisors up to √n</span>
    <span class="keyword">import</span> math
    <span class="variable">limit</span> = <span class="function">int</span>(math.<span class="function">sqrt</span>(n))
    
    <span class="keyword">for</span> divisor <span class="keyword">in</span> <span class="function">range</span>(<span class="number">3</span>, <span class="variable">limit</span> + <span class="number">1</span>, <span class="number">2</span>):
        <span class="keyword">if</span> n % divisor == <span class="number">0</span>:
            <span class="keyword">return</span> <span class="keyword">False</span>
    
    <span class="keyword">return</span> <span class="keyword">True</span></code></pre>
                </div>
            </div>
        </article>
        
        <!-- Time Complexity Section -->
        <article id="time-complexity" class="section">
            <div class="section-header">
                <h2 class="section-title">Time Complexity - Understanding Deeply</h2>
                <p class="section-subtitle">How we measure and analyze algorithm efficiency</p>
            </div>
            
            <div class="content-block">
                <h3>What Does "Time" Mean in Time Complexity?</h3>
                
                <p>When we talk about time complexity, we're not measuring wall-clock time in seconds or minutes. Instead, we're counting the number of fundamental operations an algorithm performs as a function of its input size. This abstraction allows us to compare algorithms independent of hardware, programming language, or implementation details.</p>
                
                <div class="deep-dive">
                    <h4>Deep Dive: Why Abstract Operations Instead of Real Time?</h4>
                    <p>Consider these factors that affect real execution time:</p>
                    <ul>
                        <li><strong>Hardware differences:</strong> A supercomputer vs. a smartphone</li>
                        <li><strong>Programming language:</strong> C++ vs. Python vs. JavaScript</li>
                        <li><strong>Compiler optimizations:</strong> -O0 vs. -O3 optimization levels</li>
                        <li><strong>System load:</strong> Running alone vs. with other processes</li>
                        <li><strong>Cache effects:</strong> Data in L1 cache vs. main memory</li>
                    </ul>
                    <p>By counting operations instead of measuring time, we get a hardware-independent metric that reveals the algorithm's fundamental behavior. This is why an O(n log n) algorithm will always eventually outperform an O(n²) algorithm for large enough inputs, regardless of the hardware it runs on.</p>
                </div>
                
                <h4>Fundamental Operations We Count</h4>
                <ul>
                    <li><strong>Arithmetic operations:</strong> Addition, subtraction, multiplication, division, modulo</li>
                    <li><strong>Comparison operations:</strong> Less than, greater than, equality checks</li>
                    <li><strong>Assignment operations:</strong> Storing a value in a variable</li>
                    <li><strong>Array/List access:</strong> Reading or writing array[i]</li>
                    <li><strong>Function calls:</strong> Invoking a function (not counting operations inside it)</li>
                    <li><strong>Logical operations:</strong> AND, OR, NOT</li>
                </ul>
                
                <div class="interactive-example">
                    <h4>Operation Counter - Step-by-Step Analysis</h4>
                    <p>Watch how operations accumulate as an algorithm executes. This visualization shows exactly what we count when analyzing time complexity.</p>
                    
                    <div class="example-controls">
                        <label>Array size: </label>
                        <input type="number" id="operation-n" value="5" min="1" max="20">
                        <button class="control-button" onclick="startOperationTrace()">Trace Operations</button>
                        <button class="control-button" onclick="resetOperationTrace()">Reset</button>
                    </div>
                    
                    <div class="step-trace" id="operation-trace">
                        <div>Click "Trace Operations" to see step-by-step execution</div>
                    </div>
                    
                    <div class="example-output" id="operation-output">
                        <div>This example will count every single operation performed by the algorithm</div>
                    </div>
                </div>
                
                <div class="code-block">
                    <pre><code><span class="comment"># Detailed Operation Analysis</span>
<span class="keyword">def</span> <span class="function">sum_array_with_analysis</span>(arr):
    <span class="comment">"""
    Let's count every single operation:
    """</span>
    <span class="variable">total</span> = <span class="number">0</span>                <span class="comment"># 1 operation: assignment</span>
    <span class="variable">n</span> = <span class="function">len</span>(arr)            <span class="comment"># 2 operations: len() call + assignment</span>
    <span class="variable">i</span> = <span class="number">0</span>                    <span class="comment"># 1 operation: assignment</span>
    
    <span class="keyword">while</span> i < <span class="variable">n</span>:            <span class="comment"># n+1 operations: n true comparisons + 1 false</span>
        <span class="variable">total</span> = <span class="variable">total</span> + arr[i]  <span class="comment"># 3n operations: n reads + n adds + n assigns</span>
        i = i + <span class="number">1</span>            <span class="comment"># 2n operations: n adds + n assigns</span>
    
    <span class="keyword">return</span> <span class="variable">total</span>             <span class="comment"># 1 operation: return</span>
    
    <span class="comment"># Total: 1 + 2 + 1 + (n+1) + 3n + 2n + 1 = 6n + 6 operations</span>
    <span class="comment"># Big-O: O(n) - linear time complexity</span></code></pre>
                </div>
            </div>
            
            <div class="content-block">
                <h3>Big-O Notation: The Universal Language of Efficiency</h3>
                
                <p>Big-O notation describes the upper bound of an algorithm's growth rate. It answers the question: "How does the runtime grow as the input size approaches infinity?" This mathematical framework allows us to classify algorithms into complexity classes and predict their behavior at scale.</p>
                
                <div class="deep-dive">
                    <h4>Deep Dive: The Mathematics Behind Big-O</h4>
                    <p>Formally, we say f(n) = O(g(n)) if there exist positive constants c and n₀ such that:</p>
                    <p style="text-align: center; font-family: 'Courier New', monospace;">f(n) ≤ c · g(n) for all n ≥ n₀</p>
                    
                    <p>This means that beyond some input size n₀, the function f(n) grows no faster than g(n) times some constant. Let's see this with a concrete example:</p>
                    
                    <p>If f(n) = 3n² + 5n + 2, we can prove f(n) = O(n²):</p>
                    <ul>
                        <li>For n ≥ 1: 3n² + 5n + 2 ≤ 3n² + 5n² + 2n² = 10n²</li>
                        <li>So f(n) ≤ 10n² for all n ≥ 1</li>
                        <li>Therefore f(n) = O(n²) with c = 10 and n₀ = 1</li>
                    </ul>
                    
                    <p><strong>Why We Drop Constants and Lower-Order Terms:</strong></p>
                    <ul>
                        <li>At n = 10: 3n² + 5n + 2 = 352, while n² = 100 (n² is 28% of total)</li>
                        <li>At n = 100: 3n² + 5n + 2 = 30,502, while n² = 10,000 (n² is 98% of total)</li>
                        <li>At n = 1,000: 3n² + 5n + 2 = 3,005,002, while n² = 1,000,000 (n² is 99.8% of total)</li>
                    </ul>
                    <p>As n grows, the highest-order term dominates completely, making constants and lower-order terms negligible.</p>
                </div>
                
                <div class="callout">
                    <div class="callout-title">Mountain Analogy for Growth Rates</div>
                    <p>Imagine different algorithms as different terrains you need to climb:</p>
                    <ul>
                        <li><strong>O(1) - Flat ground:</strong> No matter how far you need to go (n), the effort remains the same</li>
                        <li><strong>O(log n) - Gentle hill:</strong> The slope increases very slowly, barely noticeable</li>
                        <li><strong>O(n) - Steady slope:</strong> Linear increase, like walking up a constant incline</li>
                        <li><strong>O(n log n) - Moderate mountain:</strong> Steeper than linear but still manageable</li>
                        <li><strong>O(n²) - Steep mountain:</strong> Gets dramatically harder as you go higher</li>
                        <li><strong>O(2ⁿ) - Vertical cliff:</strong> Becomes impossible very quickly</li>
                    </ul>
                </div>
                
                <div class="chart-container" id="complexity-chart">
                    <canvas id="chart-canvas" width="800" height="350"></canvas>
                </div>
                <div style="margin-top: 1rem; text-align: center;">
                    <span class="complexity-badge o-1" onclick="highlightComplexity('O(1)')">O(1)</span>
                    <span class="complexity-badge o-log-n" onclick="highlightComplexity('O(log n)')">O(log n)</span>
                    <span class="complexity-badge o-n" onclick="highlightComplexity('O(n)')">O(n)</span>
                    <span class="complexity-badge o-n-log-n" onclick="highlightComplexity('O(n log n)')">O(n log n)</span>
                    <span class="complexity-badge o-n2" onclick="highlightComplexity('O(n²)')">O(n²)</span>
                    <span class="complexity-badge o-2n" onclick="highlightComplexity('O(2ⁿ)')">O(2ⁿ)</span>
                </div>
                
                <div class="deep-dive">
                    <h4>Deep Dive: Common Complexity Classes in Detail</h4>
                    
                    <h5>O(1) - Constant Time</h5>
                    <p>Operations that take the same amount of time regardless of input size. Examples:</p>
                    <ul>
                        <li>Array access by index: arr[5]</li>
                        <li>Hash table lookup (average case)</li>
                        <li>Push/pop on a stack</li>
                        <li>Simple arithmetic operations</li>
                    </ul>
                    
                    <h5>O(log n) - Logarithmic Time</h5>
                    <p>Algorithms that cut the problem size by a constant factor with each step. The base of the logarithm doesn't matter for Big-O. Examples:</p>
                    <ul>
                        <li>Binary search in sorted array</li>
                        <li>Finding height of a balanced binary tree</li>
                        <li>Binary search tree operations (balanced)</li>
                    </ul>
                    
                    <h5>O(n) - Linear Time</h5>
                    <p>Algorithms that must examine each input element once. Examples:</p>
                    <ul>
                        <li>Finding maximum/minimum in unsorted array</li>
                        <li>Linear search</li>
                        <li>Counting elements</li>
                        <li>Simple traversal of data structure</li>
                    </ul>
                    
                    <h5>O(n log n) - Linearithmic Time</h5>
                    <p>Common in efficient sorting algorithms that use divide-and-conquer. Examples:</p>
                    <ul>
                        <li>Merge sort</li>
                        <li>Heap sort</li>
                        <li>Efficient implementations of quicksort</li>
                        <li>Building a balanced binary search tree</li>
                    </ul>
                    
                    <h5>O(n²) - Quadratic Time</h5>
                    <p>Algorithms with nested iterations over the input. Examples:</p>
                    <ul>
                        <li>Bubble sort, insertion sort, selection sort</li>
                        <li>Comparing all pairs of elements</li>
                        <li>Simple matrix multiplication</li>
                        <li>Finding duplicates in array (naive approach)</li>
                    </ul>
                    
                    <h5>O(2ⁿ) - Exponential Time</h5>
                    <p>Algorithms that explore all subsets or solve problems through exhaustive search. Examples:</p>
                    <ul>
                        <li>Finding all subsets of a set</li>
                        <li>Recursive Fibonacci (naive implementation)</li>
                        <li>Traveling salesman (brute force)</li>
                        <li>Tower of Hanoi</li>
                    </ul>
                </div>
            </div>
        </article>
        
        <!-- Space Complexity Section -->
        <article id="space-complexity" class="section">
            <div class="section-header">
                <h2 class="section-title">Space Complexity - Memory Usage Explained</h2>
                <p class="section-subtitle">Understanding how algorithms consume memory</p>
            </div>
            
            <div class="content-block">
                <h3>Understanding Computer Memory Architecture</h3>
                
                <p>To truly understand space complexity, we need to understand how computer memory is organized and allocated. Modern computers use a hierarchical memory structure, with different types of memory serving different purposes.</p>
                
                <div class="deep-dive">
                    <h4>Deep Dive: Memory Hierarchy and Performance</h4>
                    <p>Computer memory is organized in a hierarchy based on speed and cost:</p>
                    <ol>
                        <li><strong>CPU Registers (bytes):</strong> Fastest, directly accessible by CPU, ~1 cycle access</li>
                        <li><strong>L1 Cache (32-64 KB):</strong> Very fast, ~4 cycles access</li>
                        <li><strong>L2 Cache (256 KB - 1 MB):</strong> Fast, ~10 cycles access</li>
                        <li><strong>L3 Cache (8-32 MB):</strong> Moderate, ~40 cycles access</li>
                        <li><strong>RAM/Main Memory (GB):</strong> Slower, ~100-200 cycles access</li>
                        <li><strong>SSD/Hard Disk (TB):</strong> Very slow, millions of cycles</li>
                    </ol>
                    <p>Space complexity becomes critical not just for fitting data in available RAM, but also for cache efficiency. Algorithms with better locality of reference (accessing nearby memory locations) perform significantly better due to cache effects.</p>
                </div>
                
                <h4>Stack vs Heap Memory</h4>
                <p>Programs use two main memory regions for storing data:</p>
                
                <div class="code-block">
                    <pre><code><span class="comment">Memory Layout Visualization:</span>
┌─────────────────────────┐ High Memory Addresses
│      Command Line       │
│       Arguments         │
├─────────────────────────┤
│     Stack Memory        │ ← Grows downward
│  - Local variables      │
│  - Function parameters  │
│  - Return addresses     │
│          ↓              │
├─────────────────────────┤
│      Free Space         │
├─────────────────────────┤
│          ↑              │
│      Heap Memory        │ ← Grows upward
│  - Dynamic allocation   │
│  - Objects              │
│  - Large data structures│
├─────────────────────────┤
│   Static/Global Data    │
├─────────────────────────┤
│      Code Segment       │
└─────────────────────────┘ Low Memory Addresses</code></pre>
                </div>
                
                <div class="deep-dive">
                    <h4>Deep Dive: Stack Memory Characteristics</h4>
                    <ul>
                        <li><strong>Allocation:</strong> Automatic, happens when entering function scope</li>
                        <li><strong>Deallocation:</strong> Automatic, happens when leaving function scope</li>
                        <li><strong>Access Speed:</strong> Very fast, uses simple pointer arithmetic</li>
                        <li><strong>Size Limit:</strong> Typically 1-8 MB (can cause stack overflow)</li>
                        <li><strong>Memory Layout:</strong> Contiguous, excellent cache locality</li>
                        <li><strong>Thread Safety:</strong> Each thread has its own stack</li>
                    </ul>
                    
                    <h4>Deep Dive: Heap Memory Characteristics</h4>
                    <ul>
                        <li><strong>Allocation:</strong> Manual (malloc/new) or garbage collected</li>
                        <li><strong>Deallocation:</strong> Manual (free/delete) or garbage collected</li>
                        <li><strong>Access Speed:</strong> Slower, requires memory management overhead</li>
                        <li><strong>Size Limit:</strong> Limited by available system memory</li>
                        <li><strong>Memory Layout:</strong> Fragmented, poorer cache locality</li>
                        <li><strong>Thread Safety:</strong> Shared across threads, requires synchronization</li>
                    </ul>
                </div>
            </div>
            
            <div class="content-block">
                <h3>Types of Space Complexity Analysis</h3>
                
                <div class="deep-dive">
                    <h4>1. Auxiliary Space Complexity</h4>
                    <p>This measures the extra space used by an algorithm beyond the space taken by the inputs. It's often what we care about most, as the input space is usually given and unavoidable.</p>
                    
                    <p>Example: In-place sorting algorithms like heap sort have O(1) auxiliary space because they rearrange the input array without using significant extra memory.</p>
                    
                    <h4>2. Total Space Complexity</h4>
                    <p>This includes both the input space and auxiliary space. For recursive algorithms, this includes the call stack space.</p>
                    
                    <p>Example: Merge sort has O(n) auxiliary space for the temporary arrays, making its total space complexity O(n) as well (since input is also O(n)).</p>
                </div>
                
                <div class="code-block">
                    <pre><code><span class="comment"># Space Complexity Examples with Detailed Analysis</span>
<span class="keyword">def</span> <span class="function">space_complexity_examples</span>(n):
    <span class="comment">"""
    Demonstrating different space complexity scenarios
    """</span>
    
    <span class="comment"># O(1) Space - Constant</span>
    <span class="comment"># Only using a fixed number of variables</span>
    <span class="variable">counter</span> = <span class="number">0</span>
    <span class="variable">sum_value</span> = <span class="number">0</span>
    <span class="variable">temp</span> = <span class="number">0</span>
    <span class="comment"># No matter how large n is, we use the same 3 variables</span>
    
    <span class="comment"># O(n) Space - Linear</span>
    <span class="comment"># Creating array proportional to input</span>
    <span class="variable">array</span> = [<span class="number">0</span>] * n
    <span class="comment"># Uses n memory cells</span>
    
    <span class="comment"># O(n²) Space - Quadratic</span>
    <span class="comment"># Creating 2D matrix</span>
    <span class="variable">matrix</span> = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="function">range</span>(n)]
    <span class="comment"># Uses n × n = n² memory cells</span>
    
    <span class="comment"># O(log n) Space - Logarithmic (recursive)</span>
    <span class="keyword">def</span> <span class="function">binary_search_recursive</span>(arr, target, left, right):
        <span class="comment"># Each recursive call uses O(1) space</span>
        <span class="comment"># Maximum recursion depth is log n</span>
        <span class="comment"># Total space: O(log n) for call stack</span>
        <span class="keyword">if</span> left > right:
            <span class="keyword">return</span> <span class="number">-1</span>
        mid = (left + right) // <span class="number">2</span>
        <span class="keyword">if</span> arr[mid] == target:
            <span class="keyword">return</span> mid
        <span class="keyword">elif</span> arr[mid] < target:
            <span class="keyword">return</span> <span class="function">binary_search_recursive</span>(arr, target, mid + <span class="number">1</span>, right)
        <span class="keyword">else</span>:
            <span class="keyword">return</span> <span class="function">binary_search_recursive</span>(arr, target, left, mid - <span class="number">1</span>)</code></pre>
                </div>
                
                <div class="interactive-example">
                    <h4>Memory Allocation Visualizer</h4>
                    <p>See how different data structures consume memory in real-time.</p>
                    
                    <div class="example-controls">
                        <label>Size (n): </label>
                        <input type="number" id="memory-size" value="5" min="1" max="10">
                        <select id="memory-structure">
                            <option value="constant">O(1) - Constant</option>
                            <option value="linear">O(n) - Linear Array</option>
                            <option value="quadratic">O(n²) - 2D Matrix</option>
                        </select>
                        <button class="control-button" onclick="visualizeMemory()">Visualize Memory</button>
                    </div>
                    
                    <div id="memory-visualization" style="margin-top: 1rem;">
                        <!-- Memory blocks will be visualized here -->
                    </div>
                    
                    <div class="example-output" id="memory-output">
                        <div>Select a data structure to visualize its memory consumption</div>
                    </div>
                </div>
            </div>
        </article>
        
        <!-- Practice Section -->
        <article id="practice" class="section">
            <div class="section-header">
                <h2 class="section-title">Practice & Quick Reference</h2>
                <p class="section-subtitle">Test your knowledge and reference guide</p>
            </div>
            
            <div class="content-block">
                <h3>Algorithm Complexity Quick Reference</h3>
                
                <table>
                    <thead>
                        <tr>
                            <th>Algorithm/Operation</th>
                            <th>Best Case</th>
                            <th>Average Case</th>
                            <th>Worst Case</th>
                            <th>Space</th>
                            <th>Notes</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Array Access</td>
                            <td><span class="complexity-badge o-1">O(1)</span></td>
                            <td><span class="complexity-badge o-1">O(1)</span></td>
                            <td><span class="complexity-badge o-1">O(1)</span></td>
                            <td><span class="complexity-badge o-1">O(1)</span></td>
                            <td>Direct memory address calculation</td>
                        </tr>
                        <tr>
                            <td>Linear Search</td>
                            <td><span class="complexity-badge o-1">O(1)</span></td>
                            <td><span class="complexity-badge o-n">O(n)</span></td>
                            <td><span class="complexity-badge o-n">O(n)</span></td>
                            <td><span class="complexity-badge o-1">O(1)</span></td>
                            <td>Must check each element sequentially</td>
                        </tr>
                        <tr>
                            <td>Binary Search</td>
                            <td><span class="complexity-badge o-1">O(1)</span></td>
                            <td><span class="complexity-badge o-log-n">O(log n)</span></td>
                            <td><span class="complexity-badge o-log-n">O(log n)</span></td>
                            <td><span class="complexity-badge o-1">O(1)</span></td>
                            <td>Requires sorted data</td>
                        </tr>
                        <tr>
                            <td>Bubble Sort</td>
                            <td><span class="complexity-badge o-n">O(n)</span></td>
                            <td><span class="complexity-badge o-n2">O(n²)</span></td>
                            <td><span class="complexity-badge o-n2">O(n²)</span></td>
                            <td><span class="complexity-badge o-1">O(1)</span></td>
                            <td>In-place but inefficient</td>
                        </tr>
                        <tr>
                            <td>Merge Sort</td>
                            <td><span class="complexity-badge o-n-log-n">O(n log n)</span></td>
                            <td><span class="complexity-badge o-n-log-n">O(n log n)</span></td>
                            <td><span class="complexity-badge o-n-log-n">O(n log n)</span></td>
                            <td><span class="complexity-badge o-n">O(n)</span></td>
                            <td>Stable, predictable performance</td>
                        </tr>
                        <tr>
                            <td>Quick Sort</td>
                            <td><span class="complexity-badge o-n-log-n">O(n log n)</span></td>
                            <td><span class="complexity-badge o-n-log-n">O(n log n)</span></td>
                            <td><span class="complexity-badge o-n2">O(n²)</span></td>
                            <td><span class="complexity-badge o-log-n">O(log n)</span></td>
                            <td>Usually fastest in practice</td>
                        </tr>
                        <tr>
                            <td>Hash Table Insert</td>
                            <td><span class="complexity-badge o-1">O(1)</span></td>
                            <td><span class="complexity-badge o-1">O(1)</span></td>
                            <td><span class="complexity-badge o-n">O(n)</span></td>
                            <td><span class="complexity-badge o-n">O(n)</span></td>
                            <td>Worst case with all collisions</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <div class="content-block">
                <h3>Key Takeaways and Best Practices</h3>
                
                <div class="deep-dive">
                    <h4>When to Optimize for Time vs Space</h4>
                    <ul>
                        <li><strong>Optimize for Time when:</strong>
                            <ul>
                                <li>User-facing operations requiring low latency</li>
                                <li>Real-time systems with strict deadlines</li>
                                <li>High-frequency trading or gaming applications</li>
                                <li>Memory is abundant but speed is critical</li>
                            </ul>
                        </li>
                        <li><strong>Optimize for Space when:</strong>
                            <ul>
                                <li>Working with embedded systems or IoT devices</li>
                                <li>Processing massive datasets that approach memory limits</li>
                                <li>Mobile applications where memory is constrained</li>
                                <li>Cloud computing where memory costs money</li>
                            </ul>
                        </li>
                    </ul>
                    
                    <h4>Common Optimization Techniques</h4>
                    <ol>
                        <li><strong>Caching/Memoization:</strong> Trade space for time by storing computed results</li>
                        <li><strong>Indexing:</strong> Use additional data structures to speed up lookups</li>
                        <li><strong>Preprocessing:</strong> Spend time upfront to save time on repeated operations</li>
                        <li><strong>Approximation Algorithms:</strong> Trade accuracy for speed when exact answers aren't required</li>
                        <li><strong>Parallelization:</strong> Use multiple processors to reduce wall-clock time</li>
                        <li><strong>Data Structure Selection:</strong> Choose the right tool for the job</li>
                    </ol>
                </div>
            </div>
        </article>
    </main>
    
    <footer>
        <div class="container">
            <p>2025 Rover | Time & Space Complexity Analysis Tutorial</p>
        </div>
    </footer>
    
    <script>
        // Progress Bar
        window.addEventListener('scroll', function() {
            const winScroll = document.body.scrollTop || document.documentElement.scrollTop;
            const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
            const scrolled = (winScroll / height) * 100;
            document.getElementById('reading-progress').style.width = scrolled + '%';
        });
        
        // Make sections visible on scroll
        const sections = document.querySelectorAll('.section');
        
        // Check if device is mobile
        const isMobile = window.innerWidth <= 768;
        
        // For mobile devices, make all sections visible immediately
        if (isMobile) {
            sections.forEach(section => {
                section.classList.add('visible');
            });
        } else {
            // For desktop, use IntersectionObserver for scroll animations
            const observerOptions = {
                threshold: 0.05,  // Lower threshold for better detection
                rootMargin: '0px 0px -20px 0px'  // Smaller negative margin
            };
            
            // Check if IntersectionObserver is supported
            if ('IntersectionObserver' in window) {
                const observer = new IntersectionObserver(function(entries, observer) {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            entry.target.classList.add('visible');
                        }
                    });
                }, observerOptions);
                
                sections.forEach(section => {
                    observer.observe(section);
                });
            } else {
                // Fallback for browsers without IntersectionObserver support
                sections.forEach(section => {
                    section.classList.add('visible');
                });
            }
        }
        
        // Initialize search array visualization
        let searchArray = [];
        let searchTarget = 0;
        let searchAnimationInterval = null;
        let currentSearchStep = 0;
        
        function initializeSearchArray() {
            const arrayContainer = document.getElementById('search-array');
            searchArray = [];
            for (let i = 0; i < 20; i++) {
                searchArray.push(i * 5 + Math.floor(Math.random() * 3));
            }
            searchTarget = searchArray[Math.floor(Math.random() * searchArray.length)];
            
            arrayContainer.innerHTML = '';
            searchArray.forEach((val, idx) => {
                const elem = document.createElement('div');
                elem.className = 'array-element';
                elem.innerHTML = `<span class="index">${idx}</span>${val}`;
                elem.id = `search-elem-${idx}`;
                arrayContainer.appendChild(elem);
            });
        }
        
        // Linear Search Animation with Step Trace
        function startLinearSearchAnimation() {
            clearInterval(searchAnimationInterval);
            initializeSearchArray();
            
            const traceContainer = document.getElementById('search-trace');
            const outputContainer = document.getElementById('search-output');
            const speed = document.getElementById('animation-speed').value;
            
            traceContainer.innerHTML = '<div><strong>Linear Search Trace - Target: ' + searchTarget + '</strong></div>';
            outputContainer.innerHTML = '<div><strong>Starting Linear Search...</strong></div>';
            
            let stepCount = 0;
            let comparisons = 0;
            currentSearchStep = 0;
            
            searchAnimationInterval = setInterval(() => {
                // Clear previous highlights
                document.querySelectorAll('.array-element').forEach(elem => {
                    elem.classList.remove('active', 'compared', 'found');
                });
                
                if (currentSearchStep >= searchArray.length) {
                    clearInterval(searchAnimationInterval);
                    outputContainer.innerHTML = `
                        <div><strong>Linear Search Complete</strong></div>
                        <div>Target ${searchTarget} not found</div>
                        <div>Total comparisons: ${comparisons}</div>
                        <div>Time Complexity: O(n)</div>
                    `;
                    return;
                }
                
                const currentElem = document.getElementById(`search-elem-${currentSearchStep}`);
                currentElem.classList.add('active');
                comparisons++;
                
                // Add trace step
                const traceStep = document.createElement('div');
                traceStep.className = 'trace-step active';
                traceStep.innerHTML = `
                    Step ${stepCount + 1}: Check index [${currentSearchStep}] = ${searchArray[currentSearchStep]}
                    ${searchArray[currentSearchStep] === searchTarget ? ' ← FOUND!' : ' ← Not a match, continue'}
                `;
                traceContainer.appendChild(traceStep);
                
                // Scroll trace to bottom
                traceContainer.scrollTop = traceContainer.scrollHeight;
                
                // Mark previous steps as completed
                const allSteps = traceContainer.querySelectorAll('.trace-step');
                if (allSteps.length > 1) {
                    allSteps[allSteps.length - 2].classList.remove('active');
                    allSteps[allSteps.length - 2].classList.add('completed');
                }
                
                if (searchArray[currentSearchStep] === searchTarget) {
                    currentElem.classList.add('found');
                    clearInterval(searchAnimationInterval);
                    outputContainer.innerHTML = `
                        <div><strong>Linear Search Complete</strong></div>
                        <div>Target ${searchTarget} found at index ${currentSearchStep}</div>
                        <div>Total comparisons: ${comparisons}</div>
                        <div>Time Complexity: O(n) - Had to check ${comparisons} elements</div>
                    `;
                    return;
                }
                
                currentSearchStep++;
                stepCount++;
            }, parseInt(speed));
        }
        
        // Binary Search Animation with Step Trace
        function startBinarySearchAnimation() {
            clearInterval(searchAnimationInterval);
            initializeSearchArray();
            searchArray.sort((a, b) => a - b); // Binary search requires sorted array
            
            // Re-render sorted array
            const arrayContainer = document.getElementById('search-array');
            arrayContainer.innerHTML = '';
            searchArray.forEach((val, idx) => {
                const elem = document.createElement('div');
                elem.className = 'array-element';
                elem.innerHTML = `<span class="index">${idx}</span>${val}`;
                elem.id = `search-elem-${idx}`;
                arrayContainer.appendChild(elem);
            });
            
            const traceContainer = document.getElementById('search-trace');
            const outputContainer = document.getElementById('search-output');
            const speed = document.getElementById('animation-speed').value;
            
            traceContainer.innerHTML = '<div><strong>Binary Search Trace - Target: ' + searchTarget + '</strong></div>';
            traceContainer.innerHTML += '<div>Array is sorted for binary search</div>';
            outputContainer.innerHTML = '<div><strong>Starting Binary Search...</strong></div>';
            
            let left = 0;
            let right = searchArray.length - 1;
            let comparisons = 0;
            let stepCount = 0;
            
            searchAnimationInterval = setInterval(() => {
                // Clear previous highlights
                document.querySelectorAll('.array-element').forEach(elem => {
                    elem.classList.remove('active', 'compared');
                });
                
                if (left > right) {
                    clearInterval(searchAnimationInterval);
                    outputContainer.innerHTML = `
                        <div><strong>Binary Search Complete</strong></div>
                        <div>Target ${searchTarget} not found</div>
                        <div>Total comparisons: ${comparisons}</div>
                        <div>Time Complexity: O(log n)</div>
                    `;
                    return;
                }
                
                const mid = Math.floor((left + right) / 2);
                comparisons++;
                
                // Highlight search range
                for (let i = left; i <= right; i++) {
                    document.getElementById(`search-elem-${i}`).classList.add('compared');
                }
                document.getElementById(`search-elem-${mid}`).classList.add('active');
                
                // Add trace step
                const traceStep = document.createElement('div');
                traceStep.className = 'trace-step active';
                traceStep.innerHTML = `
                    Step ${stepCount + 1}: Search range [${left}..${right}], Mid = ${mid}, Value = ${searchArray[mid]}
                    <br>Compare: ${searchArray[mid]} ${searchArray[mid] === searchTarget ? '==' : (searchArray[mid] < searchTarget ? '<' : '>')} ${searchTarget}
                    ${searchArray[mid] === searchTarget ? ' ← FOUND!' : (searchArray[mid] < searchTarget ? ' ← Search right half' : ' ← Search left half')}
                `;
                traceContainer.appendChild(traceStep);
                
                // Scroll trace to bottom
                traceContainer.scrollTop = traceContainer.scrollHeight;
                
                // Mark previous steps as completed
                const allSteps = traceContainer.querySelectorAll('.trace-step');
                if (allSteps.length > 1) {
                    allSteps[allSteps.length - 2].classList.remove('active');
                    allSteps[allSteps.length - 2].classList.add('completed');
                }
                
                if (searchArray[mid] === searchTarget) {
                    document.getElementById(`search-elem-${mid}`).classList.add('found');
                    clearInterval(searchAnimationInterval);
                    outputContainer.innerHTML = `
                        <div><strong>Binary Search Complete</strong></div>
                        <div>Target ${searchTarget} found at index ${mid}</div>
                        <div>Total comparisons: ${comparisons}</div>
                        <div>Time Complexity: O(log n) - Only needed ${comparisons} comparisons!</div>
                        <div>Linear search would have needed up to ${searchArray.length} comparisons</div>
                    `;
                    return;
                } else if (searchArray[mid] < searchTarget) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
                
                stepCount++;
            }, parseInt(speed));
        }
        
        function resetSearchAnimation() {
            clearInterval(searchAnimationInterval);
            initializeSearchArray();
            document.getElementById('search-trace').innerHTML = '<div>Select an algorithm to see step-by-step execution trace</div>';
            document.getElementById('search-output').innerHTML = `
                <div><strong>Algorithm Comparison Overview</strong></div>
                <div>• Linear Search: Checks elements sequentially from start to end</div>
                <div>• Binary Search: Divides search space in half with each comparison</div>
                <div>• Binary Search requires sorted data but is exponentially faster</div>
            `;
        }
        
        // Prime Number Algorithm Trace
        function tracePrimeAlgorithms() {
            const n = parseInt(document.getElementById('prime-input').value);
            const traceContainer = document.getElementById('prime-trace');
            const outputContainer = document.getElementById('prime-output');
            
            if (n < 2) {
                outputContainer.innerHTML = '<div style="color: var(--redbull-red);">Please enter a number greater than or equal to 2</div>';
                return;
            }
            
            traceContainer.innerHTML = '<div><strong>Prime Check Trace for n = ' + n + '</strong></div>';
            
            // Naive approach trace
            traceContainer.innerHTML += '<div style="margin-top: 1rem;"><strong>Naive Approach (Check all numbers):</strong></div>';
            let naiveSteps = 0;
            let isPrimeNaive = true;
            
            if (n < 2) {
                isPrimeNaive = false;
            } else {
                for (let i = 2; i < n && i <= 10; i++) { // Limit trace to first 10 for readability
                    naiveSteps++;
                    const step = document.createElement('div');
                    step.className = 'trace-step completed';
                    step.innerHTML = `Check: ${n} % ${i} = ${n % i}${n % i === 0 ? ' ← Divisible! Not prime' : ' ← Not divisible, continue'}`;
                    traceContainer.appendChild(step);
                    
                    if (n % i === 0) {
                        isPrimeNaive = false;
                        break;
                    }
                }
                if (n > 12 && isPrimeNaive) {
                    traceContainer.innerHTML += '<div class="trace-step completed">... (continuing checks up to ' + (n-1) + ')</div>';
                    naiveSteps = n - 2;
                }
            }
            
            // Optimized approach trace
            traceContainer.innerHTML += '<div style="margin-top: 1rem;"><strong>Optimized Approach (Check up to √n):</strong></div>';
            let optimizedSteps = 0;
            let isPrimeOptimized = true;
            
            if (n < 2) {
                isPrimeOptimized = false;
            } else if (n === 2) {
                traceContainer.innerHTML += '<div class="trace-step completed">n = 2 is prime (base case)</div>';
            } else if (n % 2 === 0) {
                optimizedSteps++;
                traceContainer.innerHTML += '<div class="trace-step completed">Check: ' + n + ' % 2 = 0 ← Even number, not prime</div>';
                isPrimeOptimized = false;
            } else {
                const limit = Math.floor(Math.sqrt(n));
                traceContainer.innerHTML += '<div class="trace-step completed">√' + n + ' = ' + limit + ' ← Only need to check up to here</div>';
                
                for (let i = 3; i <= limit && i <= 23; i += 2) { // Limit trace for readability
                    optimizedSteps++;
                    const step = document.createElement('div');
                    step.className = 'trace-step completed';
                    step.innerHTML = `Check: ${n} % ${i} = ${n % i}${n % i === 0 ? ' ← Divisible! Not prime' : ' ← Not divisible, continue'}`;
                    traceContainer.appendChild(step);
                    
                    if (n % i === 0) {
                        isPrimeOptimized = false;
                        break;
                    }
                }
                if (limit > 23 && isPrimeOptimized) {
                    traceContainer.innerHTML += '<div class="trace-step completed">... (continuing odd checks up to ' + limit + ')</div>';
                    optimizedSteps = Math.floor((limit - 1) / 2);
                }
            }
            
            // Summary
            const naiveTotalSteps = n - 2;
            const optimizedTotalSteps = Math.floor(Math.sqrt(n));
            const speedup = Math.floor(naiveTotalSteps / optimizedTotalSteps);
            
            outputContainer.innerHTML = `
                <div><strong>Prime Check Results for n = ${n}</strong></div>
                <br>
                <div><strong>Naive Algorithm:</strong></div>
                <div>• Result: ${n} is ${isPrimeNaive ? 'PRIME' : 'NOT PRIME'}</div>
                <div>• Operations: ${naiveTotalSteps} divisions to check</div>
                <div>• Time Complexity: O(n)</div>
                <br>
                <div><strong>Optimized Algorithm:</strong></div>
                <div>• Result: ${n} is ${isPrimeOptimized ? 'PRIME' : 'NOT PRIME'}</div>
                <div>• Operations: ~${optimizedTotalSteps} divisions to check</div>
                <div>• Time Complexity: O(√n)</div>
                <br>
                <div style="color: var(--o1-color);"><strong>Speedup: ${speedup}x faster!</strong></div>
                <div>As n grows larger, this difference becomes even more dramatic</div>
            `;
        }
        
        function resetPrimeTrace() {
            document.getElementById('prime-trace').innerHTML = '<div>Enter a number and click "Run Both Algorithms" to see detailed execution trace</div>';
            document.getElementById('prime-output').innerHTML = '<div>Prime checking algorithms demonstrate the power of mathematical optimization</div>';
        }
        
        // Operation Counter Trace
        function startOperationTrace() {
            const n = parseInt(document.getElementById('operation-n').value);
            const traceContainer = document.getElementById('operation-trace');
            const outputContainer = document.getElementById('operation-output');
            
            traceContainer.innerHTML = '<div><strong>Operation Count Trace for array of size ' + n + '</strong></div>';
            
            // Initialize
            let operationCount = 0;
            const array = [];
            for (let i = 0; i < n; i++) {
                array.push(i + 1);
            }
            
            // Step 1: Initialize total
            operationCount++;
            traceContainer.innerHTML += `
                <div class="trace-step completed">
                    <strong>Line 1:</strong> total = 0 
                    <span style="color: var(--meta-blue);">[1 assignment operation]</span>
                </div>
            `;
            
            // Step 2: Get array length
            operationCount += 2;
            traceContainer.innerHTML += `
                <div class="trace-step completed">
                    <strong>Line 2:</strong> n = len(arr) 
                    <span style="color: var(--meta-blue);">[1 function call + 1 assignment = 2 operations]</span>
                </div>
            `;
            
            // Step 3: Initialize i
            operationCount++;
            traceContainer.innerHTML += `
                <div class="trace-step completed">
                    <strong>Line 3:</strong> i = 0 
                    <span style="color: var(--meta-blue);">[1 assignment operation]</span>
                </div>
            `;
            
            // Step 4: Loop
            let total = 0;
            for (let i = 0; i < n; i++) {
                // Comparison
                operationCount++;
                traceContainer.innerHTML += `
                    <div class="trace-step completed">
                        <strong>Loop iteration ${i + 1}:</strong> Check i < n (${i} < ${n}) 
                        <span style="color: var(--meta-blue);">[1 comparison]</span>
                    </div>
                `;
                
                // Array access + addition + assignment
                operationCount += 3;
                total += array[i];
                traceContainer.innerHTML += `
                    <div class="trace-step completed">
                        <strong>Loop body:</strong> total = total + arr[${i}] = ${total - array[i]} + ${array[i]} = ${total}
                        <span style="color: var(--meta-blue);">[1 array access + 1 addition + 1 assignment = 3 operations]</span>
                    </div>
                `;
                
                // Increment i
                operationCount += 2;
                traceContainer.innerHTML += `
                    <div class="trace-step completed">
                        <strong>Loop increment:</strong> i = i + 1 = ${i} + 1 = ${i + 1}
                        <span style="color: var(--meta-blue);">[1 addition + 1 assignment = 2 operations]</span>
                    </div>
                `;
            }
            
            // Final comparison (loop exit)
            operationCount++;
            traceContainer.innerHTML += `
                <div class="trace-step completed">
                    <strong>Loop exit:</strong> Check i < n (${n} < ${n}) = false 
                    <span style="color: var(--meta-blue);">[1 comparison]</span>
                </div>
            `;
            
            // Return
            operationCount++;
            traceContainer.innerHTML += `
                <div class="trace-step completed">
                    <strong>Line 5:</strong> return total = ${total}
                    <span style="color: var(--meta-blue);">[1 return operation]</span>
                </div>
            `;
            
            // Add variable state display
            traceContainer.innerHTML += `
                <div class="variable-state" style="margin-top: 1rem;">
                    <strong>Final State:</strong><br>
                    • total = ${total}<br>
                    • n = ${n}<br>
                    • Operations executed = ${operationCount}
                </div>
            `;
            
            outputContainer.innerHTML = `
                <div><strong>Operation Count Analysis</strong></div>
                <div>• Initialization: 4 operations</div>
                <div>• Per iteration: 6 operations (comparison + body + increment)</div>
                <div>• Loop runs n times + 1 final comparison</div>
                <div>• Return: 1 operation</div>
                <br>
                <div><strong>Total: 4 + 6n + 1 + 1 = 6n + 6 operations</strong></div>
                <div>For n = ${n}: 6(${n}) + 6 = ${operationCount} operations</div>
                <br>
                <div>In Big-O notation: O(6n + 6) = O(n)</div>
                <div>We drop constants because as n grows, the coefficient becomes insignificant</div>
            `;
        }
        
        function resetOperationTrace() {
            document.getElementById('operation-trace').innerHTML = '<div>Click "Trace Operations" to see step-by-step execution</div>';
            document.getElementById('operation-output').innerHTML = '<div>This example will count every single operation performed by the algorithm</div>';
        }
        
        // Memory Visualization
        function visualizeMemory() {
            const n = parseInt(document.getElementById('memory-size').value);
            const structure = document.getElementById('memory-structure').value;
            const vizContainer = document.getElementById('memory-visualization');
            const outputContainer = document.getElementById('memory-output');
            
            vizContainer.innerHTML = '';
            
            if (structure === 'constant') {
                // O(1) - Just a few variables
                vizContainer.innerHTML = `
                    <div style="margin: 1rem;">
                        <strong>O(1) - Constant Space:</strong><br>
                        <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
                            <div class="memory-block">var1</div>
                            <div class="memory-block">var2</div>
                            <div class="memory-block">var3</div>
                        </div>
                    </div>
                `;
                outputContainer.innerHTML = `
                    <div><strong>Constant Space - O(1)</strong></div>
                    <div>• Always uses the same amount of memory</div>
                    <div>• Independent of input size n = ${n}</div>
                    <div>• Memory used: 3 units (fixed)</div>
                    <div>• Examples: counters, flags, temporary variables</div>
                `;
            } else if (structure === 'linear') {
                // O(n) - Array
                const blocks = [];
                for (let i = 0; i < n; i++) {
                    blocks.push(`<div class="memory-block">${i}</div>`);
                }
                vizContainer.innerHTML = `
                    <div style="margin: 1rem;">
                        <strong>O(n) - Linear Space (Array of size ${n}):</strong><br>
                        <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem; flex-wrap: wrap;">
                            ${blocks.join('')}
                        </div>
                    </div>
                `;
                outputContainer.innerHTML = `
                    <div><strong>Linear Space - O(n)</strong></div>
                    <div>• Memory grows linearly with input size</div>
                    <div>• For n = ${n}, uses ${n} memory units</div>
                    <div>• Memory used: ${n} units</div>
                    <div>• Examples: copying an array, hash table, stack</div>
                `;
            } else if (structure === 'quadratic') {
                // O(n²) - 2D Matrix
                let matrixHTML = '<table style="border-collapse: collapse; margin-top: 0.5rem;">';
                for (let i = 0; i < n; i++) {
                    matrixHTML += '<tr>';
                    for (let j = 0; j < n; j++) {
                        matrixHTML += `<td class="memory-block" style="display: table-cell;">[${i},${j}]</td>`;
                    }
                    matrixHTML += '</tr>';
                }
                matrixHTML += '</table>';
                
                vizContainer.innerHTML = `
                    <div style="margin: 1rem;">
                        <strong>O(n²) - Quadratic Space (${n}×${n} Matrix):</strong><br>
                        ${matrixHTML}
                    </div>
                `;
                outputContainer.innerHTML = `
                    <div><strong>Quadratic Space - O(n²)</strong></div>
                    <div>• Memory grows quadratically with input size</div>
                    <div>• For n = ${n}, uses ${n}×${n} = ${n * n} memory units</div>
                    <div>• Memory used: ${n * n} units</div>
                    <div>• Examples: adjacency matrix, dynamic programming table, image processing</div>
                    <div>• Warning: Becomes very large quickly! n=1000 needs 1 million units</div>
                `;
            }
        }
        
        function highlightComplexity(complexity) {
            // This could be expanded to highlight specific complexity on the chart
            console.log('Highlighting complexity:', complexity);
            
            // Update chart to emphasize selected complexity
            const canvas = document.getElementById('chart-canvas');
            if (canvas) {
                drawComplexityChart(complexity);
            }
        }
        
        // Draw complexity chart
        function drawComplexityChart(highlightedComplexity = null) {
            const canvas = document.getElementById('chart-canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Set up coordinate system
            const padding = 40;
            const maxN = 100;
            const maxY = 10000;
            
            // Draw axes
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(padding, padding);
            ctx.stroke();
            
            // Draw grid lines
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 0.5;
            for (let i = 1; i <= 10; i++) {
                const y = height - padding - (i * (height - 2 * padding) / 10);
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }
            
            // Function to convert n to x coordinate
            function nToX(n) {
                return padding + (n / maxN) * (width - 2 * padding);
            }
            
            // Function to convert y value to y coordinate
            function valToY(val) {
                const normalized = Math.min(val / maxY, 1);
                return height - padding - normalized * (height - 2 * padding);
            }
            
            // Complexity functions
            const complexities = [
                { name: 'O(1)', fn: n => 10, color: '#3fb950' },
                { name: 'O(log n)', fn: n => Math.log2(n + 1) * 100, color: '#0081FB' },
                { name: 'O(n)', fn: n => n * 50, color: '#FFA040' },
                { name: 'O(n log n)', fn: n => n * Math.log2(n + 1) * 5, color: '#FF8000' },
                { name: 'O(n²)', fn: n => n * n, color: '#DC0000' },
                { name: 'O(2ⁿ)', fn: n => Math.pow(2, n / 10) * 10, color: '#bc8cff' }
            ];
            
            // Draw complexity curves
            complexities.forEach(comp => {
                ctx.strokeStyle = comp.color;
                ctx.lineWidth = comp.name === highlightedComplexity ? 3 : 1.5;
                ctx.globalAlpha = comp.name === highlightedComplexity ? 1 : 0.6;
                
                ctx.beginPath();
                for (let n = 0; n <= maxN; n++) {
                    const x = nToX(n);
                    const y = valToY(comp.fn(n));
                    
                    if (n === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // Draw label
                ctx.fillStyle = comp.color;
                ctx.font = '12px Quicksand';
                ctx.globalAlpha = 1;
                const labelX = nToX(maxN) + 5;
                const labelY = valToY(comp.fn(maxN));
                if (labelY >= padding && labelY <= height - padding) {
                    ctx.fillText(comp.name, labelX, labelY);
                }
            });
            
            ctx.globalAlpha = 1;
            
            // Draw axis labels
            ctx.fillStyle = '#888';
            ctx.font = '12px Quicksand';
            ctx.fillText('n (input size)', width / 2, height - 10);
            ctx.save();
            ctx.translate(10, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Operations', 0, 0);
            ctx.restore();
        }
        
        // Hamburger Menu Toggle
        const hamburgerMenu = document.getElementById('hamburgerMenu');
        const navLinks = document.getElementById('navLinks');
        
        if (hamburgerMenu && navLinks) {
            hamburgerMenu.addEventListener('click', function() {
                hamburgerMenu.classList.toggle('active');
                navLinks.classList.toggle('active');
            });
            
            // Close menu when clicking on a nav link (mobile)
            document.querySelectorAll('.nav-link').forEach(link => {
                link.addEventListener('click', function() {
                    if (window.innerWidth <= 768) {
                        hamburgerMenu.classList.remove('active');
                        navLinks.classList.remove('active');
                    }
                });
            });
            
            // Close menu when clicking outside
            document.addEventListener('click', function(event) {
                if (window.innerWidth <= 768) {
                    if (!hamburgerMenu.contains(event.target) && !navLinks.contains(event.target)) {
                        hamburgerMenu.classList.remove('active');
                        navLinks.classList.remove('active');
                    }
                }
            });
        }
        
        // Initialize on load
        window.addEventListener('DOMContentLoaded', function() {
            initializeSearchArray();
            drawComplexityChart();
        });
    </script>
</body>
</html>