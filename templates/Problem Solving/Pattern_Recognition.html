<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ROVER's Training Protocol - Pattern Recognition | Rover</title>
    <link rel="stylesheet" href="/static/main.css">
    <style>
        /* Page specific styles */
        body {
            background: #000000 !important;
            color: var(--text-primary);
            line-height: 1.8;
            min-height: 100vh;
        }

        .content-wrapper {
            max-width: 1200px;
            margin: 0 auto;
            padding: var(--spacing-2xl) var(--spacing-lg);
            padding-top: 100px;
            background: #000000;
        }

        /* Back button */
        .back-button {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: var(--mclaren-orange);
            color: white;
            padding: var(--spacing-sm) var(--spacing-lg);
            border-radius: var(--radius-full);
            text-decoration: none;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-xs);
            transition: var(--transition-base);
            box-shadow: 0 4px 12px rgba(255, 128, 0, 0.3);
        }

        .back-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 128, 0, 0.5);
        }

        /* Header */
        .page-header {
            text-align: center;
            margin-bottom: var(--spacing-2xl);
            padding: var(--spacing-2xl);
            background: var(--bg-card);
            border-radius: var(--radius-lg);
            border: 1px solid rgba(255, 128, 0, 0.2);
        }

        .page-title {
            font-size: var(--font-size-4xl);
            font-weight: 800;
            color: var(--mclaren-orange);
            margin-bottom: var(--spacing-md);
            line-height: 1.2;
        }

        .page-subtitle {
            font-size: var(--font-size-xl);
            color: var(--text-secondary);
            font-weight: 600;
        }

        .page-intro {
            font-size: var(--font-size-lg);
            color: var(--text-secondary);
            max-width: 800px;
            margin: var(--spacing-lg) auto 0;
            line-height: 1.8;
        }

        /* Section styles */
        .section {
            background: #0a0a0a;
            border-radius: var(--radius-lg);
            padding: var(--spacing-2xl);
            margin-bottom: var(--spacing-xl);
            border: 1px solid rgba(255, 128, 0, 0.2);
            transition: var(--transition-base);
            box-shadow: 0 4px 20px rgba(255, 128, 0, 0.1);
        }

        .section:hover {
            border-color: rgba(255, 128, 0, 0.5);
            box-shadow: 0 8px 32px rgba(255, 128, 0, 0.2);
            transform: translateY(-2px);
        }

        .section-header {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            padding-bottom: var(--spacing-md);
            border-bottom: 2px solid var(--mclaren-orange);
            cursor: pointer;
            user-select: none;
        }

        .section-icon {
            font-size: 2rem;
            flex-shrink: 0;
        }

        .section-title {
            font-size: var(--font-size-2xl);
            font-weight: 700;
            color: var(--text-primary);
            flex: 1;
        }

        .toggle-icon {
            font-size: var(--font-size-xl);
            color: var(--mclaren-orange);
            transition: transform 0.3s ease;
        }

        .section.collapsed .toggle-icon {
            transform: rotate(-90deg);
        }

        .section.collapsed .section-content {
            display: none;
        }

        /* Pattern cards */
        .pattern-card {
            background: #050505;
            border: 1px solid rgba(255, 128, 0, 0.15);
            border-left: 4px solid var(--mclaren-orange);
            border-radius: var(--radius-md);
            padding: var(--spacing-xl);
            margin-bottom: var(--spacing-lg);
            transition: var(--transition-base);
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.5);
        }

        .pattern-card:hover {
            background: #0d0d0d;
            border-left-width: 6px;
            transform: translateX(6px);
            box-shadow: 0 4px 20px rgba(255, 128, 0, 0.15);
        }

        .pattern-title {
            font-size: var(--font-size-xl);
            font-weight: 700;
            color: var(--mclaren-orange);
            margin-bottom: var(--spacing-sm);
        }

        .pattern-subtitle {
            font-size: var(--font-size-base);
            color: var(--text-secondary);
            font-style: italic;
            margin-bottom: var(--spacing-md);
        }

        /* Code blocks */
        .code-block {
            background: #000000;
            border: 1px solid rgba(255, 128, 0, 0.3);
            border-radius: var(--radius-md);
            padding: var(--spacing-lg);
            margin: var(--spacing-md) 0;
            overflow-x: auto;
            position: relative;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8);
        }

        .code-block pre {
            margin: 0;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: var(--font-size-sm);
            line-height: 1.6;
            color: #e2e8f0;
        }

        .copy-button {
            position: absolute;
            top: var(--spacing-sm);
            right: var(--spacing-sm);
            background: var(--mclaren-orange);
            color: white;
            border: none;
            padding: 0.375rem 0.75rem;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: var(--font-size-xs);
            font-weight: 600;
            transition: var(--transition-base);
        }

        .copy-button:hover {
            background: #ff9933;
            transform: scale(1.05);
        }

        /* Lists */
        .content-list {
            list-style: none;
            padding-left: 0;
        }

        .content-list li {
            padding: var(--spacing-sm) var(--spacing-md);
            margin-bottom: var(--spacing-xs);
            background: rgba(255, 255, 255, 0.02);
            border-left: 3px solid var(--meta-blue);
            border-radius: var(--radius-sm);
            transition: var(--transition-base);
        }

        .content-list li:hover {
            background: rgba(24, 119, 242, 0.1);
            border-left-width: 4px;
            transform: translateX(4px);
        }

        /* Emphasis */
        .highlight {
            color: var(--mclaren-orange);
            font-weight: 600;
        }

        .insight-box {
            background: rgba(255, 128, 0, 0.1);
            border-left: 4px solid var(--mclaren-orange);
            padding: var(--spacing-md);
            margin: var(--spacing-md) 0;
            border-radius: var(--radius-sm);
        }

        .insight-title {
            font-weight: 700;
            color: var(--mclaren-orange);
            margin-bottom: var(--spacing-xs);
        }

        /* Steps */
        .step {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-md);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        .step-number {
            display: inline-block;
            background: var(--mclaren-orange);
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            text-align: center;
            line-height: 28px;
            font-weight: 700;
            margin-right: var(--spacing-sm);
        }

        /* Progress tracker */
        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            height: 4px;
            background: var(--mclaren-orange);
            z-index: 9999;
            transition: width 0.3s ease;
        }

        /* Search box */
        .search-container {
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 999;
        }

        .search-box {
            background: var(--bg-card);
            border: 1px solid rgba(255, 128, 0, 0.3);
            border-radius: var(--radius-full);
            padding: var(--spacing-sm) var(--spacing-md);
            color: var(--text-primary);
            font-size: var(--font-size-sm);
            width: 200px;
            outline: none;
            transition: var(--transition-base);
        }

        .search-box:focus {
            border-color: var(--mclaren-orange);
            box-shadow: 0 0 0 3px rgba(255, 128, 0, 0.1);
            width: 300px;
        }

        .highlight-match {
            background: var(--mclaren-orange);
            color: white;
            padding: 0.125rem 0.25rem;
            border-radius: 2px;
        }

        /* Theme toggle */
        .theme-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 999;
            background: var(--mclaren-orange);
            color: white;
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition-base);
            box-shadow: 0 4px 12px rgba(255, 128, 0, 0.3);
        }

        .theme-toggle:hover {
            transform: scale(1.1) rotate(15deg);
            box-shadow: 0 6px 20px rgba(255, 128, 0, 0.5);
        }

        /* Responsive Design - Tablet */
        @media (max-width: 1024px) {
            .content-wrapper {
                max-width: 100%;
                padding: var(--spacing-xl) var(--spacing-lg);
            }

            .pattern-card {
                padding: var(--spacing-lg);
            }

            .code-block {
                font-size: 0.9rem;
            }
        }

        /* Responsive Design - Mobile */
        @media (max-width: 768px) {
            body {
                font-size: 15px;
            }

            .content-wrapper {
                padding: var(--spacing-xl) var(--spacing-md);
                padding-top: 80px;
            }

            .page-header {
                padding: var(--spacing-lg);
                margin-bottom: var(--spacing-lg);
            }

            .page-title {
                font-size: var(--font-size-2xl);
                line-height: 1.3;
            }

            .page-subtitle {
                font-size: var(--font-size-lg);
            }

            .page-intro {
                font-size: var(--font-size-base);
            }

            .section {
                padding: var(--spacing-lg);
                margin-bottom: var(--spacing-lg);
            }

            .section-title {
                font-size: var(--font-size-lg);
                line-height: 1.4;
            }

            .section-icon {
                font-size: 1.5rem;
            }

            .pattern-card {
                padding: var(--spacing-md);
                margin-bottom: var(--spacing-md);
            }

            .pattern-title {
                font-size: var(--font-size-lg);
                line-height: 1.4;
            }

            .code-block {
                padding: var(--spacing-md);
                font-size: 0.85rem;
                margin: var(--spacing-sm) 0;
            }

            .code-block pre {
                font-size: 0.8rem;
                line-height: 1.5;
            }

            .copy-button {
                padding: 0.25rem 0.5rem;
                font-size: 0.7rem;
            }

            .insight-box {
                padding: var(--spacing-sm);
                margin: var(--spacing-sm) 0;
            }

            .content-list li {
                padding: var(--spacing-xs) var(--spacing-sm);
                font-size: 0.95rem;
            }

            .search-container {
                position: static;
                margin-bottom: var(--spacing-md);
                width: 100%;
            }

            .search-box {
                width: 100%;
                font-size: 0.9rem;
            }

            .search-box:focus {
                width: 100%;
            }

            .back-button {
                padding: var(--spacing-xs) var(--spacing-md);
                font-size: 0.9rem;
            }

            .theme-toggle {
                width: 45px;
                height: 45px;
                font-size: 1.2rem;
                bottom: 15px;
                right: 15px;
            }

            .step {
                padding: var(--spacing-sm);
                margin-bottom: var(--spacing-xs);
            }

            .step-number {
                width: 24px;
                height: 24px;
                line-height: 24px;
                font-size: 0.85rem;
            }
        }

        /* Responsive Design - Small Mobile */
        @media (max-width: 480px) {
            body {
                font-size: 14px;
            }

            .content-wrapper {
                padding: var(--spacing-lg) var(--spacing-sm);
                padding-top: 70px;
            }

            .page-header {
                padding: var(--spacing-md);
            }

            .page-title {
                font-size: var(--font-size-xl);
            }

            .page-subtitle {
                font-size: var(--font-size-base);
            }

            .section {
                padding: var(--spacing-md);
                border-radius: var(--radius-md);
            }

            .section-header {
                gap: var(--spacing-sm);
                padding-bottom: var(--spacing-sm);
            }

            .section-title {
                font-size: var(--font-size-base);
            }

            .pattern-card {
                padding: var(--spacing-sm);
                border-left-width: 3px;
            }

            .pattern-card:hover {
                transform: translateX(3px);
                border-left-width: 4px;
            }

            .pattern-title {
                font-size: var(--font-size-base);
            }

            .code-block {
                padding: var(--spacing-sm);
                font-size: 0.75rem;
                border-radius: var(--radius-sm);
            }

            .code-block pre {
                font-size: 0.75rem;
                line-height: 1.4;
            }

            .copy-button {
                padding: 0.2rem 0.4rem;
                font-size: 0.65rem;
                top: var(--spacing-xs);
                right: var(--spacing-xs);
            }

            .back-button {
                padding: var(--spacing-xs) var(--spacing-sm);
                font-size: 0.85rem;
                top: 10px;
                left: 10px;
            }

            .theme-toggle {
                width: 40px;
                height: 40px;
                font-size: 1rem;
                bottom: 10px;
                right: 10px;
            }
        }
    </style>
</head>
<body>
    <!-- Progress Bar -->
    <div class="progress-bar" id="progressBar"></div>

    <!-- Back Button -->
    <a href="/dashboard" class="back-button">
        <span>←</span>
        <span>Back to Dashboard</span>
    </a>

    <!-- Search Box -->
    <div class="search-container">
        <input type="search" class="search-box" id="searchBox" placeholder="🔍 Search content...">
    </div>

    <!-- Theme Toggle -->
    <button class="theme-toggle" id="themeToggle" title="Toggle theme">
        🌙
    </button>

    <!-- Main Content -->
    <div class="content-wrapper">
        <!-- Page Header -->
        <header class="page-header">
            <h1 class="page-title">🎯 ROVER'S TRAINING PROTOCOL</h1>
            <h2 class="page-subtitle">LOGIC BUILDING & PATTERN RECOGNITION</h2>
            <p class="page-intro">
                <strong>🧠 THE ALGORITHMIC MIND - DEVELOPING YOUR PROBLEM-SOLVING INSTINCTS</strong>
            </p>
            <p class="page-intro">
                Welcome to the most crucial hour of your algorithmic journey. This isn't just about memorizing patterns - this is about rewiring your brain to think like ROVER Master. You'll learn to see through problems, recognize their underlying structures, and solve them with surgical precision.
            </p>
        </header>

        <!-- Section 1: THE 5 UNIVERSAL PROBLEM-SOLVING PATTERNS -->
        <section class="section">
            <div class="section-header">
                <span class="section-icon">🧩</span>
                <h2 class="section-title">[MINUTE 0-10] THE 5 UNIVERSAL PROBLEM-SOLVING PATTERNS</h2>
                <span class="toggle-icon">▼</span>
            </div>
            <div class="section-content">
                
                <!-- Pattern 1: Counter/Tracker -->
                <div class="pattern-card">
                    <h3 class="pattern-title">🎯 PATTERN 1: THE COUNTER/TRACKER - THE MEMORY FOUNDATION</h3>
                    <p class="pattern-subtitle">Core Idea: Keep track of what you've seen - this is the foundation of all memory-efficient algorithms.</p>
                    
                    <div class="insight-box">
                        <div class="insight-title">🧠 The Philosophy Behind Tracking</div>
                        <p>Imagine your brain as you read a book - you naturally remember characters, plot points, and themes you've encountered. The Counter/Tracker pattern mimics this human cognitive ability in code. Instead of repeatedly scanning through data (expensive), we maintain a "memory" of what we've seen, allowing instant recall.</p>
                        <p style="margin-top: 0.5rem;"><strong>Key Insight:</strong> We sacrifice a small amount of space (O(n) in worst case) to gain massive time savings (from O(n²) to O(n)). This is the fundamental space-time tradeoff that powers modern computing.</p>
                    </div>
                    
                    <p style="margin-top: 1rem;">Let me explain this with the Feynman Technique: If you can't explain it simply, you don't understand it well enough.</p>
                    
                    <p><strong>Example: Find first repeating character in "programming"</strong></p>
                    
                    <p style="margin-top: 0.75rem; color: #94a3b8;">💡 <em>Why this problem matters:</em> This pattern appears everywhere - from detecting duplicate entries in databases, to finding cycles in linked lists, to implementing caching systems. Master this, and you unlock solutions to hundreds of real-world problems.</p>
                    
                    <p>Step-by-step execution:</p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>Input: "programming"
Goal: Find first character that repeats

Step 1: 'p' → seen = {'p': True}
Step 2: 'r' → seen = {'p': True, 'r': True}  
Step 3: 'o' → seen = {'p': True, 'r': True, 'o': True}
Step 4: 'g' → seen = {'p': True, 'r': True, 'o': True, 'g': True}
Step 5: 'r' → 'r' is already in seen! Return 'r' ✅

The insight: We're trading O(n) space to get O(1) lookup time</pre>
                    </div>
                    
                    <div class="insight-box">
                        <div class="insight-title">When to use this pattern:</div>
                        <ul class="content-list">
                            <li>Finding duplicates (like in our example)</li>
                            <li>Counting occurrences of elements</li>
                            <li>Checking if something exists in a collection</li>
                            <li>Tracking visited nodes in graphs</li>
                        </ul>
                    </div>
                    
                    <p><strong>The deeper logic:</strong> Hash maps give us O(1) average time complexity for lookups, which transforms many O(n²) problems into O(n) problems. This is the space-time tradeoff in action.</p>
                </div>

                <!-- Pattern 2: Two Pointers -->
                <div class="pattern-card">
                    <h3 class="pattern-title">🎯 PATTERN 2: THE TWO POINTERS - THE NAVIGATION ART</h3>
                    <p class="pattern-subtitle">Core Idea: Process from both ends or maintain a window - the art of intelligent navigation.</p>
                    
                    <div class="insight-box">
                        <div class="insight-title">🧠 The Dance of Two Pointers</div>
                        <p>Think of two pointers as two dancers on opposite sides of a stage, moving in perfect choreography. They can approach each other (like checking palindromes), move together at different speeds (like detecting cycles with fast/slow pointers), or slide as a window maintaining a specific size or condition.</p>
                        <p style="margin-top: 0.5rem;"><strong>The Power:</strong> By processing data from multiple positions simultaneously, we eliminate the need for nested loops. What would take O(n²) with brute force becomes O(n) with two pointers. This is algorithmic elegance at its finest.</p>
                        <p style="margin-top: 0.5rem;"><strong>Real-World Analogy:</strong> Imagine searching for a word in a sorted dictionary. Instead of starting from the beginning, you open it in the middle, then adjust left or right based on alphabetical order. Two pointers work the same way - smart navigation beats blind iteration every time.</p>
                    </div>
                    
                    <p style="margin-top: 1rem;"><strong>Example: Check if "racecar" is a palindrome</strong></p>
                    
                    <p style="margin-top: 0.75rem; color: #94a3b8;">💡 <em>Why palindromes matter:</em> Beyond word games, palindrome checking is the foundation for DNA sequence analysis, data compression algorithms, and detecting symmetry in images. The two-pointer technique here scales to solve problems in computational biology and computer vision.</p>
                    
                    <p>Step-by-step execution:</p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>String: "racecar"
        ↑     ↑
       left  right

Step 1: left=0, right=6 → 'r' == 'r' → Move inward
Step 2: left=1, right=5 → 'a' == 'a' → Move inward  
Step 3: left=2, right=4 → 'c' == 'c' → Move inward
Step 4: left=3, right=3 → left >= right → Stop, it's a palindrome!

The insight: Instead of checking all pairs O(n²), we only check n/2 pairs O(n)</pre>
                    </div>
                    
                    <div class="insight-box">
                        <div class="insight-title">Three variations:</div>
                        <ol class="content-list">
                            <li><strong>Opposite Ends:</strong> Start from both ends, move toward center (like palindrome checking)</li>
                            <li><strong>Same End (Fast/Slow):</strong> Both start at beginning, move at different speeds (like cycle detection)</li>
                            <li><strong>Sliding Window:</strong> Maintain a range, slide it across data (like fixed window problems)</li>
                        </ol>
                    </div>
                    
                    <p><strong>The deeper logic:</strong> We eliminate redundant comparisons by using the structure of the problem. In palindromes, we only need to check symmetric positions.</p>
                </div>

                <!-- Pattern 3: Divide & Conquer -->
                <div class="pattern-card">
                    <h3 class="pattern-title">🎯 PATTERN 3: THE DIVIDE & CONQUER - THE RECURSIVE MASTERY</h3>
                    <p class="pattern-subtitle">Core Idea: Break big problem into smaller identical problems - the recursive master's approach.</p>
                    
                    <div class="insight-box">
                        <div class="insight-title">🧠 The Recursion Tree Philosophy</div>
                        <p>Divide & Conquer is how nature solves complex problems. A tree doesn't grow all at once - it splits into branches, which split into smaller branches. Each branch follows the same growth pattern (recursion), creating exponential complexity from simple rules.</p>
                        <p style="margin-top: 0.5rem;"><strong>The Magic of Logarithms:</strong> By halving the problem space at each step, we achieve O(log n) complexity. This is why binary search beats linear search - searching 1 billion items takes only 30 comparisons! Each division doubles your efficiency.</p>
                        <p style="margin-top: 0.5rem;"><strong>Three Sacred Steps:</strong></p>
                        <ol style="margin: 0.5rem 0 0 1.5rem; line-height: 1.8;">
                            <li><strong>DIVIDE:</strong> Split the problem into independent subproblems</li>
                            <li><strong>CONQUER:</strong> Solve each subproblem recursively (or directly if small enough)</li>
                            <li><strong>COMBINE:</strong> Merge the solutions into the final answer</li>
                        </ol>
                        <p style="margin-top: 0.5rem;"><strong>Real-World Applications:</strong> Merge sort powers Google's distributed sorting, quicksort is the default in most programming languages, and the Fast Fourier Transform (FFT) using divide & conquer revolutionized signal processing - it's why MP3s exist!</p>
                    </div>
                    
                    <p style="margin-top: 1rem;"><strong>Example: Find maximum in [3, 7, 2, 9, 1] using divide and conquer</strong></p>
                    
                    <p style="margin-top: 0.75rem; color: #94a3b8;">💡 <em>Why not just loop?</em> For finding a max, looping is simpler. But divide & conquer trains your mind to break down problems systematically. This same pattern scales to merge sort (O(n log n)), binary search (O(log n)), and parallel processing where multiple CPU cores can work on subproblems simultaneously - that's where the real power lies.</p>
                    
                    <p>Step-by-step execution:</p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>Original: [3, 7, 2, 9, 1]
Divide: [3, 7, 2] and [9, 1]
Divide: [3, 7] and [2], [9] and [1]
Base cases: [3], [7], [2], [9], [1]
Combine: max(3,7)=7, max(7,2)=7, max(9,1)=9, max(7,9)=9

The recursion tree:
                [3,7,2,9,1]
                /         \
           [3,7,2]       [9,1]
           /     \       /    \
        [3,7]    [2]   [9]   [1]
        /   \     |     |     |
      [3]   [7]   2     9     1
       |     |
       3     7</pre>
                    </div>
                    
                    <div class="insight-box">
                        <div class="insight-title">When to use:</div>
                        <ul class="content-list">
                            <li>Sorting algorithms (merge sort, quick sort)</li>
                            <li>Searching in sorted data (binary search)</li>
                            <li>Tree problems (traversals, operations)</li>
                            <li>Large number multiplication (Karatsuba algorithm)</li>
                        </ul>
                    </div>
                    
                    <p><strong>The deeper logic:</strong> We break the problem into identical subproblems, solve them recursively, then combine results. This often gives us O(n log n) complexity, which is much better than O(n²).</p>
                </div>

                <!-- Pattern 4: Builder/Accumulator -->
                <div class="pattern-card">
                    <h3 class="pattern-title">🎯 PATTERN 4: THE BUILDER/ACCUMULATOR - THE INCREMENTAL CONSTRUCTION</h3>
                    <p class="pattern-subtitle">Core Idea: Build result step by step - the iterative approach to complex construction.</p>
                    
                    <div class="insight-box">
                        <div class="insight-title">🧠 The Art of Incremental Growth</div>
                        <p>Think of building a snowman: you start with a small snowball and roll it, gradually accumulating more snow. Each rotation adds to what you already have. The Builder/Accumulator pattern works the same way - start with a base case (empty result), then incrementally add to it.</p>
                        <p style="margin-top: 0.5rem;"><strong>State Evolution:</strong> Unlike recursion which breaks down, or loops which iterate, the accumulator pattern <em>evolves state</em>. Each iteration transforms the current state into the next state, like cellular automata or dynamic programming. You're not just processing - you're <strong>growing</strong> the solution.</p>
                        <p style="margin-top: 0.5rem;"><strong>When to Choose This Pattern:</strong></p>
                        <ul style="margin: 0.5rem 0 0 1.5rem; line-height: 1.8;">
                            <li>Generating combinations, permutations, or power sets</li>
                            <li>Building strings character by character</li>
                            <li>Accumulating results from stream processing</li>
                            <li>Dynamic programming where each state builds on previous states</li>
                        </ul>
                        <p style="margin-top: 0.5rem;"><strong>Real-World Applications:</strong> Pascal's triangle for binomial coefficients, Fibonacci with memoization, building syntax trees in compilers, and React's state updates - all use incremental accumulation to construct complex results from simple rules.</p>
                    </div>
                    
                    <p style="margin-top: 1rem;"><strong>Example: Generate all subsets of [1, 2, 3]</strong></p>
                    
                    <p style="margin-top: 0.75rem; color: #94a3b8;">💡 <em>The subset insight:</em> For each element, you have two choices: include it or don't. This creates 2^n total subsets. The accumulator pattern lets you build these iteratively: for each new element, take all existing subsets and add versions with the new element. It's exponential growth made manageable through incremental construction.</p>
                    
                    <p>Step-by-step execution:</p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>Start: [[]]
Add 1: [[]] + [[1]] → [[], [1]]
Add 2: [[], [1]] + [[2], [1,2]] → [[], [1], [2], [1,2]]
Add 3: [[], [1], [2], [1,2]] + [[3], [1,3], [2,3], [1,2,3]] 
       → [[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]

The insight: Each new element doubles the number of subsets</pre>
                    </div>
                    
                    <div class="insight-box">
                        <div class="insight-title">When to use:</div>
                        <ul class="content-list">
                            <li>Generating combinations/permutations</li>
                            <li>Building strings/arrays incrementally</li>
                            <li>Dynamic programming approaches</li>
                            <li>Path construction in graphs</li>
                        </ul>
                    </div>
                    
                    <p><strong>The deeper logic:</strong> We build complex structures by adding one element at a time to all existing structures. This is fundamental to many algorithmic approaches.</p>
                </div>

                <!-- Pattern 5: Optimizer -->
                <div class="pattern-card">
                    <h3 class="pattern-title">🎯 PATTERN 5: THE OPTIMIZER (GREEDY/DYNAMIC) - THE INTELLIGENT DECISION MAKING</h3>
                    <p class="pattern-subtitle">Core Idea: Make optimal choices at each step - the art of intelligent decision making.</p>
                    
                    <div class="insight-box">
                        <div class="insight-title">🧠 Greedy vs Dynamic Programming: When to Trust Your Instincts</div>
                        <p><strong>Greedy Algorithms:</strong> Make the locally optimal choice at each step, hoping it leads to a global optimum. Like climbing a mountain by always going upward - works if there's only one peak, fails if there are local maxima.</p>
                        <p style="margin-top: 0.5rem;"><strong>When Greedy Works:</strong></p>
                        <ul style="margin: 0.5rem 0 0 1.5rem; line-height: 1.8;">
                            <li><strong>Optimal Substructure:</strong> Global optimum contains optimal solutions to subproblems</li>
                            <li><strong>Greedy Choice Property:</strong> Local optimal choices lead to global optimum</li>
                            <li><strong>Examples:</strong> Dijkstra's shortest path, Huffman coding, activity selection, fractional knapsack</li>
                        </ul>
                        <p style="margin-top: 0.5rem;"><strong>When Greedy Fails:</strong> If your problem has overlapping subproblems or making a greedy choice now blocks a better choice later, you need <strong>Dynamic Programming</strong> (DP). DP explores all possibilities systematically, memoizing results to avoid recomputation.</p>
                        <p style="margin-top: 0.5rem;"><strong>The Trade-off:</strong> Greedy is fast (O(n log n) typical) but doesn't always work. DP is slower (O(n²) or O(n³) common) but guarantees optimal solutions when greedy fails. The key skill? <em>Recognizing which paradigm fits your problem.</em></p>
                        <p style="margin-top: 0.5rem;"><strong>Real-World Applications:</strong> GPS routing (Dijkstra's), file compression (Huffman), job scheduling (greedy intervals), video encoding (DP for optimal bit allocation), and stock trading strategies (DP for max profit with multiple transactions).</p>
                    </div>
                    
                    <p style="margin-top: 1rem;"><strong>Example: Coin change with [25, 10, 5, 1] coins for amount 67</strong></p>
                    
                    <p style="margin-top: 0.75rem; color: #94a3b8;">💡 <em>Why this works greedily:</em> US coin denominations have a special property - each coin is at least 2× the next smaller coin (mostly). This guarantees that taking the largest coin first is always optimal. Try coins [1, 3, 4] for amount 6: greedy gives [4,1,1] (3 coins) but optimal is [3,3] (2 coins). That's when you need DP!</p>
                    
                    <p>Step-by-step execution:</p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>Amount: 67
Step 1: 67 >= 25 → Take 25, amount = 42, result = [25]
Step 2: 42 >= 25 → Take 25, amount = 17, result = [25, 25]
Step 3: 17 >= 10 → Take 10, amount = 7, result = [25, 25, 10]
Step 4: 7 >= 5 → Take 5, amount = 2, result = [25, 25, 10, 5]
Step 5: 2 >= 1 → Take 1, amount = 1, result = [25, 25, 10, 5, 1]
Step 6: 1 >= 1 → Take 1, amount = 0, result = [25, 25, 10, 5, 1, 1]

The insight: Greedy works because our coin system is canonical</pre>
                    </div>
                    
                    <div class="insight-box">
                        <div class="insight-title">When to use:</div>
                        <ul class="content-list">
                            <li>Optimization problems (minimize/maximize)</li>
                            <li>Scheduling problems</li>
                            <li>Path finding (when greedy choice property holds)</li>
                            <li>Resource allocation problems</li>
                        </ul>
                    </div>
                    
                    <p><strong>The deeper logic:</strong> We make locally optimal choices hoping for global optimality. This works when the problem has optimal substructure and greedy choice property.</p>
                </div>
                
            </div>
        </section>

        <!-- Section 2: PATTERN RECOGNITION TRAINING -->
        <section class="section">
            <div class="section-header">
                <span class="section-icon">🧠</span>
                <h2 class="section-title">[MINUTE 10-25] PATTERN RECOGNITION TRAINING - THE MASTERY DRILL</h2>
                <span class="toggle-icon">▼</span>
            </div>
            <div class="section-content">
                
                <!-- Exercise 1 -->
                <div class="pattern-card">
                    <h3 class="pattern-title">🎯 Exercise 1: Pattern Identification - The Recognition Game</h3>
                    
                    <div class="insight-box">
                        <div class="insight-title">🧠 The Power of Problem Transformation</div>
                        <p>Most optimization comes not from clever coding, but from <strong>reframing the question</strong>. Instead of asking "Does any pair sum to target?", ask "For each number x, does (target - x) exist?" This transforms a nested loop problem into a lookup problem.</p>
                        <p style="margin-top: 0.5rem;"><strong>Why Hash Maps Are Your Secret Weapon:</strong> Hash maps provide O(1) average-case lookup. When you need to check "have I seen this before?", a hash map turns an O(n) search into O(1). This single data structure choice is the difference between O(n²) and O(n) for countless problems.</p>
                        <p style="margin-top: 0.5rem;"><strong>The Pattern:</strong> "Find a pair/triplet that satisfies condition" → Think hash map or two pointers. You're looking for relationships between elements, not processing elements independently.</p>
                    </div>
                    
                    <p style="margin-top: 1rem;"><strong>Problem A: "Find if array has two numbers that sum to target"</strong></p>
                    
                    <p style="margin-top: 0.75rem; color: #94a3b8;">💡 <em>Real-world application:</em> This two-sum pattern appears everywhere - in recommendation systems (finding complementary products), financial analysis (finding transactions that balance), and cryptography (finding hash collisions). Master this pattern, and you've unlocked dozens of real problems.</p>
                    
                    <p style="margin-top: 0.75rem;">The naive approach (O(n²)):</p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>def twosumnaive(arr, target):
    for i in range(len(arr)):
        for j in range(i+1, len(arr)):
            if arr[i] + arr[j] == target:
                return [i, j]
    return []</pre>
                    </div>
                    
                    <p>The ROVER Master approach (O(n)):</p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>def twosumoptimal(arr, target):
    seen = {}   # Track what we've seen
    for i, num in enumerate(arr):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i
    return []</pre>
                    </div>
                    
                    <p>Step-by-step simulation with arr=[2,7,11,15], target=9:</p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>i=0, num=2: complement=7, not in seen, seen={2:0}
i=1, num=7: complement=2, found in seen at index 0! Return [0,1] ✅

Why this is better:
Naive: Check n×(n-1)/2 pairs = O(n²)
Optimal: Single pass with O(1) lookups = O(n)</pre>
                    </div>
                    
                    <p><strong>The deeper insight:</strong> We transform the problem from "find two numbers that sum to target" to "for each number, check if its complement exists." This is the power of problem transformation.</p>
                </div>

                <div class="pattern-card">
                    <p><strong>Problem B: "Remove duplicates from sorted array in-place"</strong></p>
                    
                    <p>The pattern recognition: Array is SORTED + in-place modification → Perfect for TWO POINTERS pattern!</p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>def removeduplicates(arr):
    if not arr:
        return 0
    
    writepos = 1   # Where to write next unique element
    
    for readpos in range(1, len(arr)):
        if arr[readpos] != arr[readpos - 1]:
            arr[writepos] = arr[readpos]
            writepos += 1
    
    return writepos</pre>
                    </div>
                    
                    <p>Step-by-step simulation with arr=[1,1,2,2,3,4,4]:</p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>read=1: arr[1]==arr[0] (1==1), skip
read=2: arr[2]!=arr[1] (2!=1), write 2 at pos 1, writepos=2
read=3: arr[3]==arr[2] (2==2), skip
read=4: arr[4]!=arr[3] (3!=2), write 3 at pos 2, writepos=3
read=5: arr[5]!=arr[4] (4!=3), write 4 at pos 3, writepos=4
read=6: arr[6]==arr[5] (4==4), skip
Result: [1,2,3,4,,,], length=4

The insight: Maintain two invariants - elements before writepos are unique, elements after readpos are unprocessed</pre>
                    </div>
                </div>

                <!-- Exercise 2 -->
                <div class="pattern-card">
                    <h3 class="pattern-title">🎯 Exercise 2: Complexity Pattern Recognition - The Rapid Analysis</h3>
                    
                    <div class="insight-box">
                        <div class="insight-title">🧠 Seeing Hidden Costs: The Complexity Detective</div>
                        <p>Complexity analysis is about counting operations, but beginners often miss hidden loops. That innocent <code>.sort()</code>? That's O(n log n). That <code>.contains()</code> on a list? O(n) lookup. That recursive call? Could be exponential if you're not careful.</p>
                        <p style="margin-top: 0.5rem;"><strong>The Detective's Toolkit:</strong> Always ask three questions:</p>
                        <ol style="margin: 0.5rem 0 0 1.5rem; line-height: 1.8;">
                            <li><strong>"How many times does each operation run?"</strong> - Count loop iterations</li>
                            <li><strong>"Are there hidden operations?"</strong> - Check method calls for internal loops</li>
                            <li><strong>"What's the worst-case scenaROVER?"</strong> - Big O measures worst case, not average</li>
                        </ol>
                        <p style="margin-top: 0.5rem;"><strong>Pro tip:</strong> When analyzing nested structures, multiply complexities. Loop inside a loop? O(n) × O(n) = O(n²). Sort inside a loop? O(n) × O(n log n) = O(n² log n). The outer operation repeats everything inside it.</p>
                    </div>
                    
                    <p style="margin-top: 1rem;"><strong>Quick rules for spotting complexity:</strong></p>
                    
                    <ol class="content-list">
                        <li><strong>Single loop = O(n):</strong> One iteration per input element</li>
                        <li><strong>Nested loops = O(n²):</strong> For each element, process all other elements</li>
                        <li><strong>Halving = O(log n):</strong> Problem size reduces by half each time (binary search, balanced trees)</li>
                        <li><strong>Recursive halving = O(log n):</strong> One recursive call with halved input (divide & conquer base case)</li>
                        <li><strong>Multiple recursive calls = Often exponential:</strong> Binary tree of calls (Fibonacci naive, all subsets)</li>
                        <li><strong>Hash map operations = O(1) average:</strong> But O(n) worst case with hash collisions</li>
                        <li><strong>Sorting = O(n log n):</strong> Best possible for comparison-based sorting</li>
                    </ol>
                    
                    <p style="margin-top: 0.75rem; color: #94a3b8;">💡 <em>Memory matters too:</em> Space complexity follows similar rules. Recursive calls stack up - O(log n) for balanced trees, O(n) for linear recursion. Hash maps that store n items? That's O(n) space. Always analyze both time AND space.</p>
                </div>

                <!-- Exercise 3 -->
                <div class="pattern-card">
                    <h3 class="pattern-title">🎯 Exercise 3: Approach Transformation - The Optimization Drill</h3>
                    
                    <div class="insight-box">
                        <div class="insight-title">🧠 Multi-Approach Thinking: The Optimizer's Mindset</div>
                        <p>Great engineers don't settle for the first solution that works. They ask: <em>"What if I approached this differently?"</em> The same problem can have 3-5 valid solutions with wildly different trade-offs. Your job? Know them all, choose wisely.</p>
                        <p style="margin-top: 0.5rem;"><strong>The Trade-off Triangle:</strong> Every algorithm balances three factors:</p>
                        <ul style="margin: 0.5rem 0 0 1.5rem; line-height: 1.8;">
                            <li><strong>Time Complexity:</strong> How fast does it run?</li>
                            <li><strong>Space Complexity:</strong> How much memory does it use?</li>
                            <li><strong>Implementation Complexity:</strong> How hard is it to code and maintain?</li>
                        </ul>
                        <p style="margin-top: 0.5rem;">Sometimes a "slower" O(n log n) solution that's simple is better than a complex O(n) solution in production. Context matters. Interview problems optimize for time/space; real systems optimize for maintainability too.</p>
                        <p style="margin-top: 0.5rem;"><strong>The Optimization Ladder:</strong> Start with brute force (proves correctness), optimize to good enough (sort, hash maps), then optimize to optimal (clever algorithms, data structures). Each step teaches you something new.</p>
                    </div>
                    
                    <p style="margin-top: 1rem;"><strong>Problem: Find the kth largest element in array</strong></p>
                    
                    <p style="margin-top: 0.75rem; color: #94a3b8;">💡 <em>Why this problem matters:</em> Finding top-k elements appears in recommendation systems (top k products), analytics (top k users), and databases (ORDER BY LIMIT). The naive "sort everything" approach wastes work - you don't need full order, just the kth largest. This insight drives the optimization.</p>
                    
                    <p style="margin-top: 0.75rem;"><strong>Approach 1: Sort and index - O(n log n)</strong></p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>def kthlargestv1(arr, k):
    arr.sort(reverse=True)   # O(n log n)
    return arr[k-1]          # O(1)</pre>
                    </div>
                    
                    <p><strong>Approach 2: Use max heap - O(n + k log n)</strong></p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>import heapq
def kthlargestv2(arr, k):
    heap = [-x for x in arr]    # O(n)
    heapq.heapify(heap)         # O(n)
    for _ in range(k-1):        # O(k)
        heapq.heappop(heap)     # O(log n)
    return -heapq.heappop(heap)  # O(log n)</pre>
                    </div>
                    
                    <p><strong>Approach 3: Use min heap of size k - O(n log k) - Best approach!</strong></p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>def kthlargestv3(arr, k):
    heap = arr[:k]              # O(k)
    heapq.heapify(heap)         # O(k)
    
    for num in arr[k:]:         # O(n-k)
        if num > heap[0]:       # O(1) - compare with smallest in heap
            heapq.heapreplace(heap, num)    # O(log k)
    
    return heap[0]              # O(1)</pre>
                    </div>
                    
                    <p><strong>Approach 4: QuickSelect - O(n) average, O(n²) worst</strong></p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>def kthlargestv4(arr, k):
    def quickselect(left, right, k):
        # Partition around pivot
        pivot = arr[right]
        partitionpos = left
        
        for i in range(left, right):
            if arr[i] >= pivot:
                arr[i], arr[partitionpos] = arr[partitionpos], arr[i]
                partitionpos += 1
        
        arr[partitionpos], arr[right] = arr[right], arr[partitionpos]
        
        if partitionpos == k - 1:
            return arr[partitionpos]
        elif partitionpos < k - 1:
            return quickselect(partitionpos + 1, right, k)
        else:
            return quickselect(left, partitionpos - 1, k)
    
    return quickselect(0, len(arr) - 1, k)</pre>
                    </div>
                    
                    <p><strong>The deeper lesson:</strong> Same problem, different complexities. Always consider multiple approaches and their trade-offs.</p>
                </div>
                
            </div>
        </section>

        <!-- Section 3: COMPLEXITY ANALYSIS LOGIC BUILDING -->
        <section class="section">
            <div class="section-header">
                <span class="section-icon">🧮</span>
                <h2 class="section-title">[MINUTE 25-40] COMPLEXITY ANALYSIS LOGIC BUILDING - THE SYSTEMATIC FRAMEWORK</h2>
                <span class="toggle-icon">▼</span>
            </div>
            <div class="section-content">
                
                <div class="pattern-card">
                    <h3 class="pattern-title">🎯 The Step-by-Step Analysis Method - ROVER's Systematic Approach</h3>
                    
                    <p><strong>STEP 1: Mark the Operations</strong></p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>def exampleanalysis(arr):
    n = len(arr)             # ← 1 operation, O(1)
    maxval = arr[0]         # ← 1 operation, O(1) 
    minval = arr[0]         # ← 1 operation, O(1)
    
    for i in range(n):       # ← n iterations
        if arr[i] > maxval:     # ← 1 comparison × n = O(n)
            maxval = arr[i]      # ← 1 assignment × (worst: n) = O(n)
        if arr[i] < minval:     # ← 1 comparison × n = O(n)
            minval = arr[i]      # ← 1 assignment × (worst: n) = O(n)
    
    return maxval - minval   # ← 1 operation, O(1)

# Total: O(1) + O(1) + O(1) + O(n) + O(n) + O(n) + O(n) + O(1) = O(n)</pre>
                    </div>
                    
                    <p><strong>STEP 2: Identify the Loops</strong></p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>def loopanalysis(matrix):
    rows = len(matrix)         # O(1)
    cols = len(matrix[0])      # O(1)
    
    # Single loop: O(rows)
    for i in range(rows):
        print(i)
    
    # Nested loops: O(rows × cols)
    for i in range(rows):
        for j in range(cols):
            print(matrix[i][j])
    
    # Logarithmic: O(log rows)
    k = rows
    while k > 1:
        k = k // 2
    
# Total: O(1) + O(1) + O(rows) + O(rows × cols) + O(log rows) = O(rows × cols)</pre>
                    </div>
                    
                    <p><strong>STEP 3: Analyze Recursive Calls</strong></p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>def recursiveanalysis(n):
    if n <= 1:                # O(1)
        return 1
    
    result = 0                # O(1)
    result += recursiveanalysis(n-1)   # T(n-1)
    result += recursiveanalysis(n-2)   # T(n-2)
    return result             # O(1)

# Recurrence: T(n) = T(n-1) + T(n-2) + O(1)
# Creates binary tree: Number of nodes ≈ 2ⁿ, so O(2ⁿ)</pre>
                    </div>
                </div>

                <div class="pattern-card">
                    <h3 class="pattern-title">🎯 Logic Building Exercise: Trace and Count - The Manual Simulation</h3>
                    
                    <p><strong>Problem: Analyze this code step by step</strong></p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>def mysteryfunction(arr):
    n = len(arr)
    result = 0
    
    # Part A: Calculate sum of all elements
    for i in range(n):
        result += arr[i]
    
    # Part B: Check all pairs for sum condition
    for i in range(n):
        for j in range(i+1, n):
            if arr[i] + arr[j] == result:
                return True
    
    return False</pre>
                    </div>
                    
                    <p>Step-by-step simulation with arr = [1, 2, 3, 4]:</p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>n = 4
Part A: Calculate sum
  i=0: result = 0 + 1 = 1
  i=1: result = 1 + 2 = 3
  i=2: result = 3 + 3 = 6
  i=3: result = 6 + 4 = 10
Part A operations: n additions = O(n)

Part B: Check all pairs
  i=0: j=1,2,3 → Check (1,2), (1,3), (1,4) → 3 checks
  i=1: j=2,3   → Check (2,3), (2,4)       → 2 checks
  i=2: j=3     → Check (3,4)              → 1 check
Total checks: 3+2+1 = n(n-1)/2 = O(n²)

Overall: O(n) + O(n²) = O(n²)</pre>
                    </div>
                </div>

                <div class="pattern-card">
                    <h3 class="pattern-title">🎯 Common Complexity Pitfalls - The Hidden Traps</h3>
                    
                    <p><strong>Pitfall 1: Hidden Function Costs</strong></p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>def sneakycomplexity(arr):
    for i in range(len(arr)):
        if i in arr:            # O(n) - searches entire array linearly!
            arr.remove(i)       # O(n) - shifts all elements after removed element
            arr.sort()          # O(n log n) - sorts entire array again

# Actual complexity: O(n) × (O(n) + O(n) + O(n log n)) = O(n² log n)</pre>
                    </div>
                    
                    <p><strong>Pitfall 2: String Operations</strong></p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>def stringcomplexity(n):
    result = ""
    for i in range(n):
        result = result + str(i)   # Creates NEW string object each time!

# In many languages: O(1) + O(2) + O(3) + ... + O(n) = O(n²)

# Better approach:
def stringcomplexitybetter(n):
    result = []
    for i in range(n):
        result.append(str(i))   # O(1) amortized
    return "".join(result)      # O(n) - single concatenation
# Total: O(n) - much better!</pre>
                    </div>
                </div>
                
            </div>
        </section>

        <!-- Section 4: THE ART OF OPTIMIZATION THINKING -->
        <section class="section">
            <div class="section-header">
                <span class="section-icon">🚀</span>
                <h2 class="section-title">[MINUTE 40-50] THE ART OF OPTIMIZATION THINKING - THE MASTERY PRINCIPLES</h2>
                <span class="toggle-icon">▼</span>
            </div>
            <div class="section-content">
                
                <div class="pattern-card">
                    <h3 class="pattern-title">🎯 The Optimization Mindset - ROVER's Philosophy</h3>
                    
                    <p><strong>Ask these questions for EVERY problem:</strong></p>
                    
                    <ol class="content-list">
                        <li><strong>Can I eliminate unnecessary work?</strong> → Remove redundant operations</li>
                        <li><strong>Can I reuse previous computations?</strong> → Memoization, caching, precomputation</li>
                        <li><strong>Can I trade space for time?</strong> → Hash maps, prefix sums, lookup tables</li>
                        <li><strong>Can I reorganize data for faster access?</strong> → Sorting, indexing, different data structures</li>
                        <li><strong>Can I exit early?</strong> → Early termination, pruning, short-circuiting</li>
                    </ol>
                </div>

                <div class="pattern-card">
                    <h3 class="pattern-title">🎯 Optimization Technique 1: Precomputation - The Setup Payoff</h3>
                    
                    <div class="insight-box">
                        <div class="insight-title">🧠 The Setup Cost vs Query Benefit Analysis</div>
                        <p>Precomputation is an investment: you spend time once during setup to save time on every future query. Like building an index in a database - takes time upfront, but pays dividends on every search.</p>
                        <p style="margin-top: 0.5rem;"><strong>When Precomputation Wins:</strong></p>
                        <ul style="margin: 0.5rem 0 0 1.5rem; line-height: 1.8;">
                            <li>Multiple queries on the same data (amortize setup cost)</li>
                            <li>Setup cost is reasonable (O(n) setup for O(1) queries is amazing)</li>
                            <li>Data doesn't change frequently (avoid re-preprocessing)</li>
                        </ul>
                        <p style="margin-top: 0.5rem;"><strong>Classic Examples:</strong> Prefix sums, cumulative products, suffix arrays, Fenwick trees, segment trees. All follow the same pattern: invest O(n) or O(n log n) to make queries logarithmic or constant.</p>
                    </div>
                    
                    <p style="margin-top: 1rem;"><strong>Problem: Multiple queries for sum of range [left, right]</strong></p>
                    
                    <p style="margin-top: 0.75rem; color: #94a3b8;">💡 <em>Real-world analogy:</em> Think of prefix sums like odometer readings on a car. To find distance between mile 20 and mile 50, you don't count every mile - you subtract odometer readings (50 - 20 = 30 miles). We're doing the same with cumulative sums!</p>
                    
                    <p style="margin-top: 0.75rem;">The slow approach:</p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>class RangeSumSlow:
    def __init__(self, arr):
        self.arr = arr
    
    def sumrange(self, left, right):
        total = 0
        for i in range(left, right+1):
            total += self.arr[i]
        return total
    # Each query: O(n) - inefficient for multiple queries!</pre>
                    </div>
                    
                    <p>The optimized approach:</p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>class RangeSumFast:
    def __init__(self, arr):
        self.arr = arr
        # Precompute prefix sums - O(n) setup
        self.prefix = [0]
        for num in arr:
            self.prefix.append(self.prefix[-1] + num)
    
    def sumrange(self, left, right):
        return self.prefix[right+1] - self.prefix[left]
    # Each query: O(1)!

# Example: arr = [1, 2, 3, 4, 5]
# prefix = [0, 1, 3, 6, 10, 15]
# sum(1,3) = prefix[4] - prefix[1] = 10 - 1 = 9
# Indeed: arr[1] + arr[2] + arr[3] = 2 + 3 + 4 = 9 ✓</pre>
                    </div>
                    
                    <p><strong>The deeper insight:</strong> We trade O(n) space to get O(1) queries. This is the space-time tradeoff principle in action.</p>
                </div>

                <div class="pattern-card">
                    <h3 class="pattern-title">🎯 Optimization Technique 2: Early Termination - The Smart Exit</h3>
                    
                    <div class="insight-box">
                        <div class="insight-title">🧠 Short-Circuit Logic: Know When to Stop</div>
                        <p>Why check every element when the first violation answers your question? Early termination is about recognizing when you have enough information. It's the algorithmic equivalent of "no need to check the rest of the house if you found your keys in the first room."</p>
                        <p style="margin-top: 0.5rem;"><strong>The Best-Case vs Worst-Case Paradox:</strong> Early termination doesn't change worst-case complexity, but it dramatically improves average and best-case performance. In practice, many problems terminate early - this is why hash maps feel so fast even though they're O(n) worst case.</p>
                        <p style="margin-top: 0.5rem;"><strong>Where to Apply:</strong></p>
                        <ul style="margin: 0.5rem 0 0 1.5rem; line-height: 1.8;">
                            <li>Searching for existence (found it? return immediately)</li>
                            <li>Boolean conditions (false in AND chain? stop checking)</li>
                            <li>Sorted data (passed the target? it won't appear later)</li>
                            <li>Pruning in recursion (this branch can't lead to solution? cut it)</li>
                        </ul>
                    </div>
                    
                    <p style="margin-top: 1rem;"><strong>Problem: Check if array has duplicates</strong></p>
                    
                    <p style="margin-top: 0.75rem; color: #94a3b8;">💡 <em>The psychology of early termination:</em> Human intuition says "check everything to be sure," but algorithms don't need exhaustive proof once they find counterexample. This mindset shift - from proving completeness to finding existence - is key to optimization thinking.</p>
                    
                    <p style="margin-top: 0.75rem;">The slow approach:</p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>def hasduplicatesslow(arr):
    for i in range(len(arr)):
        for j in range(i+1, len(arr)):
            if arr[i] == arr[j]:
                return True   # Early termination
    return False
# Worst case: O(n²), Best case: O(1)</pre>
                    </div>
                    
                    <p>The fast approach:</p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>def hasduplicatesfast(arr):
    seen = set()
    for num in arr:
        if num in seen:     # O(1) lookup
            return True     # Early termination with better complexity
        seen.add(num)       # O(1) insertion
    return False
# Worst case: O(n), Best case: O(1)</pre>
                    </div>
                    
                    <p><strong>The deeper insight:</strong> We maintain the early termination benefit but improve the lookup complexity from O(n) to O(1).</p>
                </div>

                <div class="pattern-card">
                    <h3 class="pattern-title">🎯 Optimization Technique 3: Space-Time Tradeoff - The Memory Magic</h3>
                    
                    <p><strong>Problem: Nth Fibonacci number</strong></p>
                    
                    <p>Pure recursion - O(2ⁿ) time, O(n) space:</p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>def fibslow(n):
    if n <= 1:
        return n
    return fibslow(n-1) + fibslow(n-2)
# Creates exponential number of recursive calls!</pre>
                    </div>
                    
                    <p>With memoization - O(n) time, O(n) space:</p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>def fibmemo(n, cache={}):
    if n in cache:       # O(1) lookup
        return cache[n]
    if n <= 1:
        return n
    cache[n] = fibmemo(n-1, cache) + fibmemo(n-2, cache)   # O(1) store
    return cache[n]
# Each value calculated only once!</pre>
                    </div>
                    
                    <p>Iterative - O(n) time, O(1) space - Best approach!:</p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>def fiboptimal(n):
    if n <= 1:
        return n
    prev, curr = 0, 1    # Only store last two values
    for _ in range(2, n+1):
        prev, curr = curr, prev + curr   # Update in place
    return curr
# Optimal space usage!</pre>
                    </div>
                </div>

                <div class="pattern-card">
                    <h3 class="pattern-title">🎯 Optimization Technique 4: Better Data Structures - The Right Tool</h3>
                    
                    <p><strong>Problem: Design data structure with O(1) insert, delete, getRandom</strong></p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>import random

class RandomizedSet:
    def __init__(self):
        self.nums = []         # Array for O(1) random access
        self.positions = {}    # Hash map for O(1) lookup
    
    def insert(self, val):
        if val in self.positions:
            return False
        self.nums.append(val)
        self.positions[val] = len(self.nums) - 1
        return True
    
    def remove(self, val):
        if val not in self.positions:
            return False
        
        # Swap with last element (O(1))
        pos = self.positions[val]
        lastval = self.nums[-1]
        
        self.nums[pos] = lastval
        self.positions[lastval] = pos
        
        # Remove last element (O(1))
        self.nums.pop()
        del self.positions[val]
        return True
    
    def getRandom(self):
        return random.choice(self.nums)

# All operations are O(1)! Masterful combination of array and hash map.</pre>
                    </div>
                    
                    <p><strong>The deeper insight:</strong> We use array for random access and hash map for position tracking. When removing, we swap with last element to maintain O(1) removal!</p>
                </div>
                
            </div>
        </section>

        <!-- Section 5: MENTAL MODELS & PROBLEM DECOMPOSITION -->
        <section class="section">
            <div class="section-header">
                <span class="section-icon">🧠</span>
                <h2 class="section-title">[MINUTE 50-60] MENTAL MODELS & PROBLEM DECOMPOSITION - THE FRAMEWORK MASTERY</h2>
                <span class="toggle-icon">▼</span>
            </div>
            <div class="section-content">
                
                <div class="pattern-card">
                    <h3 class="pattern-title">🎯 The UMPIRE Method - ROVER's Problem-Solving Framework</h3>
                    
                    <ul class="content-list">
                        <li><strong>U</strong> - Understand the problem completely</li>
                        <li><strong>M</strong> - Match with known patterns</li>
                        <li><strong>P</strong> - Plan the approach systematically</li>
                        <li><strong>I</strong> - Implement with clean code</li>
                        <li><strong>R</strong> - Review the complexity and edge cases</li>
                        <li><strong>E</strong> - Evaluate optimizations and alternatives</li>
                    </ul>
                </div>

                <div class="pattern-card">
                    <h3 class="pattern-title">🎯 Mental Model 1: The Input-Output Transform - The Black Box Philosophy</h3>
                    
                    <div class="insight-box">
                        <div class="insight-title">🧠 Function Thinking: From Specification to Implementation</div>
                        <p>Every algorithm is a function: given specific inputs, produce specific outputs. Before you write code, define the contract: What comes in? What goes out? What constraints exist? This is <strong>specification-first thinking</strong>.</p>
                        <p style="margin-top: 0.5rem;"><strong>The Three-Layer Problem Model:</strong></p>
                        <ol style="margin: 0.5rem 0 0 1.5rem; line-height: 1.8;">
                            <li><strong>Interface Layer:</strong> What does the outside world see? (function signature, input/output types)</li>
                            <li><strong>Algorithm Layer:</strong> How do we transform input to output? (the actual logic)</li>
                            <li><strong>Complexity Layer:</strong> What are the performance guarantees? (time/space bounds)</li>
                        </ol>
                        <p style="margin-top: 0.5rem;">Master this separation, and you can solve any problem systematically. It's how software engineers think about APIs, how computer scientists analyze algorithms, and how interview problems are structured.</p>
                    </div>
                    
                    <p style="margin-top: 1rem;">Think of every problem as:</p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>INPUT → [ALGORITHM BLACK BOX] → OUTPUT</pre>
                    </div>
                    
                    <p style="margin-top: 0.75rem;"><strong>Your job:</strong> Design the black box efficiently and correctly.</p>
                    
                    <p style="margin-top: 0.75rem;"><strong>Example: Find missing number in array [0, 1, 3, 4, 5] where n=5</strong></p>
                    
                    <p style="margin-top: 0.5rem; color: #94a3b8;">💡 <em>Multiple paths to same destination:</em> Notice how different algorithms (math, XOR, set difference) solve the same input→output contract with different trade-offs. That's algorithmic diversity - learn many tools, pick the right one.</p>
                    
                    <p>Method 1: Use math (Gaussian sum formula):</p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>def findmissingmath(arr, n):
    # Sum of 0 to n = n(n+1)/2
    expectedsum = n * (n + 1) // 2
    actualsum = sum(arr)
    return expectedsum - actualsum
# Time: O(n), Space: O(1) - Perfect efficiency!</pre>
                    </div>
                    
                    <p>Method 2: Use XOR (bit manipulation):</p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>def findmissingxor(arr, n):
    # XOR all numbers 0 to n and all array elements
    # Duplicates cancel out, leaving only missing
    result = 0
    for i in range(n + 1):
        result ^= i
    for num in arr:
        result ^= num
    return result
# Time: O(n), Space: O(1) - Elegant bit manipulation!</pre>
                    </div>
                    
                    <p><strong>The deeper insight:</strong> Sometimes math is the best algorithm. XOR property: a ^ a = 0, a ^ 0 = a.</p>
                </div>

                <div class="pattern-card">
                    <h3 class="pattern-title">🎯 Mental Model 2: The State Machine - The Transition Philosophy</h3>
                    
                    <p>Many problems involve:</p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>Current State + Input → Next State</pre>
                    </div>
                    
                    <p><strong>Example: Valid parentheses checker</strong></p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>def isvalidparentheses(s):
    # State = stack of opening brackets
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}
    
    for char in s:
        if char in mapping:
            # Closing bracket - check if matches
            if not stack or stack[-1] != mapping[char]:
                return False
            stack.pop()   # Remove matched opening bracket
        else:
            # Opening bracket - add to state
            stack.append(char)
    
    return len(stack) == 0</pre>
                    </div>
                    
                    <p>Step-by-step simulation with "([{}])":</p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>Input '(': stack = ['('] (opening bracket)
Input '{': stack = ['(', '{'] (opening bracket)
Input '[': stack = ['(', '{', '['] (opening bracket)
Input ']': matches '[', stack = ['(', '{'] (closing bracket)
Input '}': matches '{', stack = ['('] (closing bracket)
Input ')': matches '(', stack = [] (closing bracket)
Final: stack is empty → Valid! ✅</pre>
                    </div>
                    
                    <p><strong>The deeper insight:</strong> The stack maintains the "state" of unmatched opening brackets. Each closing bracket must match the most recent opening bracket.</p>
                </div>

                <div class="pattern-card">
                    <h3 class="pattern-title">🎯 Mental Model 3: The Invariant - The Consistency Principle</h3>
                    
                    <p><strong>Maintain a property that's always true<br>Use it to guide your algorithm<br>Invariants help ensure correctness</strong></p>
                    
                    <p><strong>Example: Dutch National Flag (sort 0s, 1s, 2s)</strong></p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>def sortcolors(nums):
    # Invariant: 
    # [0, low) = all 0s (red)
    # [low, mid) = all 1s (white) 
    # [mid, high] = unknown (to be processed)
    # (high, n) = all 2s (blue)
    
    low = mid = 0
    high = len(nums) - 1
    
    while mid <= high:
        if nums[mid] == 0:
            nums[low], nums[mid] = nums[mid], nums[low]
            low += 1     # Expand red section
            mid += 1     # Move to next unknown
        elif nums[mid] == 1:
            mid += 1     # Move to next unknown (already in correct place)
        else:   # nums[mid] == 2
            nums[mid], nums[high] = nums[high], nums[mid]
            high -= 1    # Expand blue section
            # Don't increment mid - need to check swapped element!</pre>
                    </div>
                    
                    <p>Step-by-step simulation with [2, 0, 1, 2, 1, 0]:</p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>Initial: low=0, mid=0, high=5, array=[2,0,1,2,1,0]
nums[0]=2: swap with nums[5], → [0,0,1,2,1,2], high=4
nums[0]=0: swap with self, → low=1, mid=1, [0,0,1,2,1,2]
nums[1]=0: swap with self, → low=2, mid=2, [0,0,1,2,1,2]
nums[2]=1: → mid=3, [0,0,1,2,1,2]
nums[3]=2: swap with nums[4], → [0,0,1,1,2,2], high=3
nums[3]=1: → mid=4, [0,0,1,1,2,2]
mid > high: stop, [0,0,1,1,2,2]</pre>
                    </div>
                    
                    <p><strong>The deeper insight:</strong> The invariant is maintained throughout: elements before 'low' are 0s, elements between 'low' and 'mid' are 1s, elements after 'high' are 2s.</p>
                </div>

                <div class="pattern-card">
                    <h3 class="pattern-title">🎯 Problem Decomposition Framework - The Systematic Breakdown</h3>
                    
                    <p><strong>Every complex problem can be broken down systematically:</strong></p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>COMPLEX PROBLEM
├── SUBPROBLEM 1: [Identify core component]
│   ├── SUB-SUBPROBLEM 1.1: [Simplify further]
│   └── SUB-SUBPROBLEM 1.2: [Simplify further]
├── SUBPROBLEM 2: [Identify core component] 
├── SUBPROBLEM 3: [Identify core component]
└── COMBINATION LOGIC: [How to combine subproblem solutions]</pre>
                    </div>
                    
                    <p><strong>Example: Merge k sorted lists</strong></p>
                    
                    <div class="code-block">
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                        <pre>def mergeklists(lists):
    # Decomposition:
    # SUBPROBLEM 1: How to merge two sorted lists? (Base case)
    # SUBPROBLEM 2: How to merge k lists efficiently? (Combine strategy)
    
    def mergetwolists(l1, l2):
        dummy = current = ListNode(0)
        
        while l1 and l2:
            if l1.val <= l2.val:
                current.next = l1
                l1 = l1.next
            else:
                current.next = l2
                l2 = l2.next
            current = current.next
        
        current.next = l1 or l2
        return dummy.next
    
    # Divide & conquer approach
    if not lists:
        return None
    
    while len(lists) > 1:
        merged = []
        
        # Merge adjacent pairs
        for i in range(0, len(lists), 2):
            l1 = lists[i]
            l2 = lists[i+1] if i+1 < len(lists) else None
            merged.append(mergetwolists(l1, l2))
        
        lists = merged   # Replace with merged pairs
    
    return lists[0]

# Complexity: O(nklog k) where n = avg list length, k = number of lists</pre>
                    </div>
                    
                    <p><strong>The deeper insight:</strong> We break the complex problem into: (1) merge two lists (simple), (2) merge many lists using divide and conquer (efficient).</p>
                </div>
                
            </div>
        </section>

        <!-- Section 6: FINAL SYNTHESIS -->
        <section class="section">
            <div class="section-header">
                <span class="section-icon">🏁</span>
                <h2 class="section-title">FINAL SYNTHESIS - THE MASTERY CHECKLIST</h2>
                <span class="toggle-icon">▼</span>
            </div>
            <div class="section-content">
                
                <div class="pattern-card">
                    <h3 class="pattern-title">🧠 Your Logic Building Toolkit - ROVER's Mastery Framework</h3>
                    
                    <div class="insight-box">
                        <div class="insight-title">Pattern Recognition Checklist:</div>
                        <ul class="content-list">
                            <li>Can I use a hash map to track seen elements? → Counter/Tracker pattern</li>
                            <li>Can two pointers solve this more efficiently? → Two Pointers pattern</li>
                            <li>Is this a divide & conquer problem? → Divide & Conquer pattern</li>
                            <li>Should I build the solution incrementally? → Builder/Accumulator pattern</li>
                            <li>Can I make greedy choices? → Optimizer pattern</li>
                        </ul>
                    </div>
                    
                    <div class="insight-box">
                        <div class="insight-title">Complexity Analysis Checklist:</div>
                        <ul class="content-list">
                            <li>Count loops and their iterations → Identify dominant terms</li>
                            <li>Check hidden costs in library functions → Don't assume O(1)</li>
                            <li>Analyze recursive call trees → Count nodes and depth</li>
                            <li>Consider best/average/worst cases → Not just worst case</li>
                            <li>Look for optimization opportunities → Always ask "can this be better?"</li>
                        </ul>
                    </div>
                    
                    <div class="insight-box">
                        <div class="insight-title">Problem-Solving Checklist:</div>
                        <ul class="content-list">
                            <li>Understand inputs/outputs completely → Define the transformation</li>
                            <li>Identify the pattern → Match to known approaches</li>
                            <li>Consider multiple approaches → Don't settle for first idea</li>
                            <li>Choose optimal data structures → Right tool for the job</li>
                            <li>Think about edge cases → Empty, single element, duplicates</li>
                        </ul>
                    </div>
                </div>

                <div class="pattern-card">
                    <h3 class="pattern-title">🧠 Quick Mental Exercises - Pattern Recognition Drill</h3>
                    
                    <div class="step">
                        <span class="step-number">1</span>
                        <strong>What's the pattern?</strong>
                        <ul class="content-list" style="margin-top: 0.5rem;">
                            <li>Find pair with target sum → Two Pointers or Hash Map</li>
                            <li>Find shortest path → BFS/Dijkstra</li>
                            <li>Generate all possibilities → Backtracking</li>
                            <li>Optimize selection → Dynamic Programming/Greedy</li>
                        </ul>
                    </div>
                    
                    <div class="step">
                        <span class="step-number">2</span>
                        <strong>What's the complexity?</strong>
                        <div class="code-block" style="margin-top: 0.5rem;">
                            <button class="copy-button" onclick="copyCode(this)">Copy</button>
                            <pre>for i in range(n):
    for j in range(i):
        print(i, j)</pre>
                        </div>
                        <p style="margin-top: 0.5rem;"><strong>Answer:</strong> O(n²) - triangular iteration creates n(n-1)/2 operations</p>
                    </div>
                    
                    <div class="step">
                        <span class="step-number">3</span>
                        <strong>How to optimize?</strong>
                        <ul class="content-list" style="margin-top: 0.5rem;">
                            <li>Nested loops checking all pairs → Use hash map for O(1) lookups</li>
                            <li>Recalculating same values → Memoization to avoid redundant work</li>
                            <li>Searching unsorted array repeatedly → Sort once for O(log n) searches</li>
                            <li>Multiple queries → Precompute results for O(1) access</li>
                        </ul>
                    </div>
                </div>

                <div class="pattern-card" style="background: linear-gradient(135deg, rgba(255, 128, 0, 0.1), rgba(255, 128, 0, 0.05)); border: 2px solid var(--mclaren-orange);">
                    <h3 class="pattern-title">🚀 BRIDGING TO THE NEXT LEVEL - ROVER'S MASTER'S MANTRA</h3>
                    
                    <div class="insight-box" style="background: rgba(0, 0, 0, 0.5); border-left: 4px solid var(--mclaren-orange);">
                        <div class="insight-title">🧠 From Pattern Recognition to Problem Mastery</div>
                        <p>You've learned the patterns. You understand complexity. You can optimize. Now comes the crucial step: <strong>synthesis</strong>. True mastery isn't knowing 100 patterns - it's recognizing which of the 5 core patterns applies to any problem you face.</p>
                        <p style="margin-top: 0.5rem;">Think of these patterns as your algorithmic vocabulary. Just as a writer combines 26 letters into infinite stories, you'll combine these 5 patterns into solutions for thousands of problems. The magic isn't in the patterns themselves - it's in your ability to see them hiding in disguise.</p>
                        <p style="margin-top: 0.5rem;"><strong>What separates good from great?</strong> Good engineers memorize solutions. Great engineers recognize patterns. Master engineers see multiple patterns in one problem and choose the optimal combination. That's where you're headed.</p>
                    </div>
                    
                    <p style="margin-top: 1rem;"><strong>You now have ROVER's complete logic building foundation:</strong></p>
                    
                    <ol class="content-list">
                        <li><strong>Pattern recognition skills</strong> - You can identify the 5 universal patterns</li>
                        <li><strong>Complexity analysis ability</strong> - You can analyze any algorithm systematically</li>
                        <li><strong>Optimization mindset</strong> - You know how to improve any solution</li>
                        <li><strong>Problem decomposition tools</strong> - You can break down complex problems</li>
                    </ol>
                    
                    <div class="insight-box" style="margin-top: 1.5rem; background: rgba(255, 128, 0, 0.15); border-left-width: 6px;">
                        <div class="insight-title" style="font-size: 1.1rem;">ROVER's Master's Mantra:</div>
                        <p style="font-style: italic; font-size: 1.05rem; line-height: 1.9; margin-top: 0.75rem;">
                            "In the realm of algorithms, patterns repeat, but solutions evolve. Master the patterns, optimize the approach, and decompose the complexity. Every problem is a puzzle waiting for the right mental model. The algorithmic mind sees through the surface to the underlying structure, transforms complexity into simplicity, and turns problems into solutions."
                        </p>
                    </div>
                    
                    <p style="margin-top: 1.5rem; font-size: 1.05rem; line-height: 1.8;">
                        This is not just about solving problems - this is about <span class="highlight">thinking like ROVER Master</span>. Every problem becomes an opportunity to apply these patterns, every algorithm becomes a tool in your mental arsenal, every optimization becomes a step toward mastery.
                    </p>
                    
                    <p style="margin-top: 1rem; font-size: 1.05rem; line-height: 1.8; font-weight: 600; color: var(--mclaren-orange);">
                        The journey continues. The patterns are now part of your algorithmic DNA. Use them wisely, apply them consistently, and watch as complex problems become simple exercises in pattern recognition and systematic thinking.
                    </p>
                </div>
                </div>
                
            </div>
        </section>

    </div>

    <!-- JavaScript for Interactivity -->
    <script>
        // Progress bar on scroll
        window.addEventListener('scroll', () => {
            const windowHeight = window.innerHeight;
            const documentHeight = document.documentElement.scrollHeight - windowHeight;
            const scrolled = window.scrollY;
            const progress = (scrolled / documentHeight) * 100;
            document.getElementById('progressBar').style.width = progress + '%';
        });

        // Section collapse/expand
        document.querySelectorAll('.section-header').forEach(header => {
            header.addEventListener('click', () => {
                const section = header.parentElement;
                section.classList.toggle('collapsed');
            });
        });

        // Copy code functionality
        function copyCode(button) {
            const codeBlock = button.nextElementSibling;
            const code = codeBlock.textContent;
            
            navigator.clipboard.writeText(code).then(() => {
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.style.background = '#00FF00';
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = '';
                }, 2000);
            });
        }

        // Search functionality
        const searchBox = document.getElementById('searchBox');
        let originalContent = null;

        searchBox.addEventListener('input', (e) => {
            const searchTerm = e.target.value.toLowerCase();
            
            if (!originalContent) {
                originalContent = document.querySelector('.content-wrapper').innerHTML;
            }
            
            if (searchTerm === '') {
                document.querySelector('.content-wrapper').innerHTML = originalContent;
                // Re-attach event listeners
                attachEventListeners();
                return;
            }
            
            // Simple search highlighting
            const contentWrapper = document.querySelector('.content-wrapper');
            const allText = contentWrapper.querySelectorAll('p, li, pre, h1, h2, h3');
            
            allText.forEach(element => {
                const text = element.textContent;
                if (text.toLowerCase().includes(searchTerm)) {
                    element.style.display = '';
                    // Highlight match
                    const regex = new RegExp(`(${searchTerm})`, 'gi');
                    if (element.tagName !== 'PRE') {
                        element.innerHTML = element.textContent.replace(regex, '<span class="highlight-match">$1</span>');
                    }
                } else {
                    if (element.tagName === 'P' || element.tagName === 'LI') {
                        element.style.display = 'none';
                    }
                }
            });
        });

        // Theme toggle
        const themeToggle = document.getElementById('themeToggle');
        let isDark = true;

        themeToggle.addEventListener('click', () => {
            isDark = !isDark;
            document.body.style.background = isDark ? '#0a0a0a' : '#f5f5f5';
            document.body.style.color = isDark ? '#e2e8f0' : '#1a1a1a';
            themeToggle.textContent = isDark ? '🌙' : '☀️';
            
            // Update card backgrounds
            document.querySelectorAll('.section, .pattern-card, .code-block').forEach(el => {
                if (isDark) {
                    el.style.background = el.classList.contains('code-block') ? 
                        'rgba(0, 0, 0, 0.4)' : 'rgba(255, 255, 255, 0.05)';
                } else {
                    el.style.background = el.classList.contains('code-block') ? 
                        'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.9)';
                }
            });
        });

        // Attach event listeners function
        function attachEventListeners() {
            document.querySelectorAll('.section-header').forEach(header => {
                header.addEventListener('click', () => {
                    const section = header.parentElement;
                    section.classList.toggle('collapsed');
                });
            });
        }

        // Initialize
        attachEventListeners();

        // Smooth scroll for back button
        document.querySelector('.back-button').addEventListener('click', (e) => {
            e.preventDefault();
            window.location.href = '/dashboard';
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ctrl/Cmd + F for search
            if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                e.preventDefault();
                searchBox.focus();
            }
            // Escape to clear search
            if (e.key === 'Escape') {
                searchBox.value = '';
                searchBox.dispatchEvent(new Event('input'));
            }
        });
    </script>
</body>
</html>